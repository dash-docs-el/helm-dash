<HTML>
<HEAD>
<META HTTP-EQUIV="Content-type" content="text/html; charset=ISO-8859-1">
<TITLE>Vim documentation: syntax</TITLE>
</HEAD>
<BODY BGCOLOR="#ffffff">
<H1>Vim documentation: syntax</H1>
<A NAME="top"></A>
<A HREF="index.html">main help file</A>

<HR>
<PRE>

*<A NAME="syntax.txt"></A><B>syntax.txt</B>*	For Vim version 7.4.  Last change: 2013 Jul 05


		  VIM REFERENCE MANUAL	  by <A HREF="intro.html#Bram">Bram</A> <A HREF="intro.html#Moolenaar">Moolenaar</A>



<A HREF="autocmd.html#Syntax">Syntax</A> highlighting		*<A NAME="syntax"></A><B>syntax</B>* *<A NAME="syntax-highlighting"></A><B>syntax-highlighting</B>* *<A NAME="coloring"></A><B>coloring</B>*

<A HREF="autocmd.html#Syntax">Syntax</A> highlighting enables Vim to show parts of the text in another font or
color.	Those parts can be specific keywords or text matching a <A HREF="pattern.html#pattern">pattern</A>.  Vim
doesn't parse the whole file (to keep <A HREF="motion.html#it">it</A> fast), so the highlighting has its
limitations.  Lexical highlighting might be a better name, but since everybody
calls <A HREF="motion.html#it">it</A> <A HREF="#syntax">syntax</A> highlighting we'll stick with that.

Vim supports <A HREF="#syntax">syntax</A> highlighting on all terminals.  But since most ordinary
terminals have very limited highlighting possibilities, <A HREF="motion.html#it">it</A> works best in the
<A HREF="gui.html#GUI">GUI</A> version, <A HREF="starting.html#gvim">gvim</A>.

In the <A HREF="autocmd.html#User">User</A> Manual:
|<A HREF="usr_06.html">usr_06.txt</A>| introduces <A HREF="#syntax">syntax</A> highlighting.
|<A HREF="usr_44.html">usr_44.txt</A>| introduces <A HREF="editing.html#writing">writing</A> a <A HREF="#syntax">syntax</A> file.

1.  Quick start			|<A HREF="#:syn-qstart">:syn-qstart</A>|
2.  <A HREF="autocmd.html#Syntax">Syntax</A> files		|<A HREF="#:syn-files">:syn-files</A>|
3.  <A HREF="autocmd.html#Syntax">Syntax</A> loading procedure	|<A HREF="#syntax-loading">syntax-loading</A>|
4.  <A HREF="autocmd.html#Syntax">Syntax</A> file remarks		|<A HREF="#:syn-file-remarks">:syn-file-remarks</A>|
5.  Defining a <A HREF="#syntax">syntax</A>		|<A HREF="#:syn-define">:syn-define</A>|
6.  <A HREF="#:syntax">:syntax</A> arguments		|<A HREF="#:syn-arguments">:syn-arguments</A>|
7.  <A HREF="autocmd.html#Syntax">Syntax</A> patterns		|<A HREF="#:syn-pattern">:syn-pattern</A>|
8.  <A HREF="autocmd.html#Syntax">Syntax</A> clusters		|<A HREF="#:syn-cluster">:syn-cluster</A>|
9.  Including <A HREF="#syntax">syntax</A> files	|<A HREF="#:syn-include">:syn-include</A>|
10. Synchronizing		|<A HREF="#:syn-sync">:syn-sync</A>|
11. Listing syntax items	|<A HREF="#:syntax">:syntax</A>|
12. Highlight command		|<A HREF="#:highlight">:highlight</A>|
13. Linking groups		|<A HREF="#:highlight-link">:highlight-link</A>|
14. Cleaning up			|<A HREF="#:syn-clear">:syn-clear</A>|
15. Highlighting <A HREF="tagsrch.html#tags">tags</A>		|<A HREF="#tag-highlight">tag-highlight</A>|
16. Window-local syntax		|<A HREF="#:ownsyntax">:ownsyntax</A>|
17. Color xterms		|<A HREF="#xterm-color">xterm-color</A>|
18. When <A HREF="#syntax">syntax</A> is slow		|<A HREF="#:syntime">:syntime</A>|

{Vi does not have any of these commands}

<A HREF="autocmd.html#Syntax">Syntax</A> highlighting is not available when the |<A HREF="various.html#+syntax">+syntax</A>| feature has been
disabled at compile time.

==============================================================================

1. Quick start						*<A NAME=":syn-qstart"></A><B>:syn-qstart</B>*


						*<A NAME=":syn-enable"></A><B>:syn-enable</B>* *<A NAME=":syntax-enable"></A><B>:syntax-enable</B>*
This command switches on <A HREF="#syntax">syntax</A> highlighting:

<B>	:syntax enable</B>

What this command actually does is to execute the command
<B>	:source $VIMRUNTIME/syntax/syntax.vim</B>

If the VIM environment variable is not set, Vim will try to find
the path in another way (see |<A HREF="starting.html#$VIMRUNTIME">$VIMRUNTIME</A>|).  Usually this works just
fine.  If <A HREF="motion.html#it">it</A> doesn't, try setting the VIM environment variable to the
directory where the Vim stuff is located.  For example, if your <A HREF="#syntax">syntax</A> files
are in the &quot;/usr/vim/vim50/syntax&quot; directory, set <A HREF="starting.html#$VIMRUNTIME">$VIMRUNTIME</A> to
&quot;/usr/vim/vim50&quot;.  You must <A HREF="diff.html#do">do</A> this in the shell, before starting Vim.


							*<A NAME=":syn-on"></A><B>:syn-on</B>* *<A NAME=":syntax-on"></A><B>:syntax-on</B>*
The &quot;<A HREF="#:syntax">:syntax</A> enable&quot; command will keep your current color settings.  This
allows using &quot;<A HREF="#:highlight">:highlight</A>&quot; commands to set your preferred colors before or
after using this command.  If you want Vim to overrule your settings with the
defaults, use:
<B>	:syntax on</B>
 

					*<A NAME=":hi-normal"></A><B>:hi-normal</B>* *<A NAME=":highlight-normal"></A><B>:highlight-normal</B>*
If you are running in the <A HREF="gui.html#GUI">GUI</A>, you can get white text on a black background
with:
<B>	:highlight Normal guibg=Black guifg=White</B>
For a color terminal see |<A HREF="#:hi-normal-cterm">:hi-normal-cterm</A>|.
For setting up your own colors <A HREF="#syntax">syntax</A> highlighting see |<A HREF="#syncolor">syncolor</A>|.

NOTE: The <A HREF="#syntax">syntax</A> files on <A HREF="os_msdos.html#MS-DOS">MS-DOS</A> and Windows have lines that end in &lt;CR&gt;&lt;NL&gt;.
The files for <A HREF="os_unix.html#Unix">Unix</A> end in <A HREF="motion.html#&lt;NL&gt;">&lt;NL&gt;</A>.  This means you should use the right type of
file for your system.  Although on <A HREF="os_msdos.html#MS-DOS">MS-DOS</A> and Windows the right format is
automatically selected if the <A HREF="options.html#'fileformats'">'fileformats'</A> option is not empty.

NOTE: When using reverse video (&quot;gvim <A HREF="gui_x11.html#-fg">-fg</A> white <A HREF="gui_x11.html#-bg">-bg</A> black&quot;), the default value
of <A HREF="options.html#'background'">'background'</A> will not be set until the <A HREF="gui.html#GUI">GUI</A> <A HREF="windows.html#window">window</A> is opened, which is after
reading the |<A HREF="gui.html#gvimrc">gvimrc</A>|.  This will cause the wrong default highlighting to be
used.  To set the default value of <A HREF="options.html#'background'">'background'</A> before switching on
highlighting, include the &quot;<A HREF="gui_x11.html#:gui">:gui</A>&quot; command in the YXXYgvimrc|:

<B>   :gui		" open window and set default for 'background'</B>
<B>   :syntax on	" start highlighting, use 'background' to set colors</B>

NOTE: Using &quot;<A HREF="gui_x11.html#:gui">:gui</A>&quot; in the |<A HREF="gui.html#gvimrc">gvimrc</A>| means that &quot;gvim -f&quot; won't start in the
foreground!  Use &quot;<A HREF="gui_x11.html#:gui">:gui</A> -f&quot; then.


							*<A NAME="g:syntax_on"></A><B>g:syntax_on</B>*
You can toggle the <A HREF="#syntax">syntax</A> on/off with this command:
<B>   :if exists("g:syntax_on") | syntax off | else | syntax enable | endif</B>

To put this into a <A HREF="map.html#mapping">mapping</A>, you can use:
<B>   :map &lt;F7&gt; :if exists("g:syntax_on") &lt;Bar&gt;</B>
<B>	\   syntax off &lt;Bar&gt;</B>
<B>	\ else &lt;Bar&gt;</B>
<B>	\   syntax enable &lt;Bar&gt;</B>
<B>	\ endif &lt;CR&gt;</B>
[using the |<A HREF="intro.html#&lt;&gt;">&lt;&gt;</A>| <A HREF="intro.html#notation">notation</A>, type this literally]

Details:
The &quot;<A HREF="#:syntax">:syntax</A>&quot; commands are implemented by sourcing a file.  To see exactly how
this works, look in the file:
<B><FONT COLOR="PURPLE">    command		file </FONT></B>
    <A HREF="#:syntax">:syntax</A> enable	$VIMRUNTIME/syntax/syntax.vim
    <A HREF="#:syntax">:syntax</A> on		$VIMRUNTIME/syntax/syntax.vim
    <A HREF="#:syntax">:syntax</A> manual	$VIMRUNTIME/syntax/manual.vim
    <A HREF="#:syntax">:syntax</A> off		$VIMRUNTIME/syntax/nosyntax.vim
Also see |<A HREF="#syntax-loading">syntax-loading</A>|.

NOTE: If displaying long lines is slow and switching off <A HREF="#syntax">syntax</A> highlighting
makes <A HREF="motion.html#it">it</A> fast, consider setting the <A HREF="options.html#'synmaxcol'">'synmaxcol'</A> option to a lower value.

==============================================================================

2. <A HREF="autocmd.html#Syntax">Syntax</A> files						*<A NAME=":syn-files"></A><B>:syn-files</B>*

The <A HREF="#syntax">syntax</A> and highlighting commands for one language are normally stored in
a <A HREF="#syntax">syntax</A> file.	The name convention is: &quot;{name}.vim&quot;.  Where {name} is the
name of the language, or an abbreviation (to fit the name in 8.3 characters,
a requirement in <A HREF="change.html#case">case</A> the file is used on a <A HREF="os_dos.html#DOS">DOS</A> filesystem).
Examples:
	<A HREF="#c.vim">c.vim</A>		<A HREF="#perl.vim">perl.vim</A>	<A HREF="#java.vim">java.vim</A>	<A HREF="#html.vim">html.vim</A>
	<A HREF="#cpp.vim">cpp.vim</A>		<A HREF="#sh.vim">sh.vim</A>		<A HREF="#csh.vim">csh.vim</A>

The <A HREF="#syntax">syntax</A> file can contain any <A HREF="intro.html#Ex">Ex</A> commands, just like a <A HREF="starting.html#vimrc">vimrc</A> file.  But
the idea is that only commands for a specific language are included.  When a
language is a superset of another language, <A HREF="motion.html#it">it</A> may include the other one,
for example, the <A HREF="#cpp.vim">cpp.vim</A> file could include the <A HREF="#c.vim">c.vim</A> file:
<B>   :so $VIMRUNTIME/syntax/c.vim</B>

The .vim files are normally loaded with an <A HREF="autocmd.html#autocommand">autocommand</A>.  For example:
<B>   :au Syntax c	    runtime! syntax/c.vim</B>
<B>   :au Syntax cpp   runtime! syntax/cpp.vim</B>
These commands are normally in the file $VIMRUNTIME/syntax/synload.vim.



MAKING YOUR OWN SYNTAX FILES				*<A NAME="mysyntaxfile"></A><B>mysyntaxfile</B>*

When you create your own <A HREF="#syntax">syntax</A> files, and you want to have Vim use these
automatically with &quot;<A HREF="#:syntax">:syntax</A> enable&quot;, <A HREF="diff.html#do">do</A> this:

1. Create your user runtime directory.	You would normally use the first item
   of the <A HREF="options.html#'runtimepath'">'runtimepath'</A> option.  Example for <A HREF="os_unix.html#Unix">Unix</A>:
<B>	mkdir ~/.vim</B>

2. Create a directory in there called &quot;<A HREF="#syntax">syntax</A>&quot;.  For <A HREF="os_unix.html#Unix">Unix</A>:
<B>	mkdir ~/.vim/syntax</B>

3. Write the Vim <A HREF="#syntax">syntax</A> file.  Or <A HREF="intro.html#download">download</A> one from the <A HREF="intro.html#internet">internet</A>.  Then write
   <A HREF="motion.html#it">it</A> in your <A HREF="#syntax">syntax</A> directory.  For example, for the &quot;mine&quot; <A HREF="#syntax">syntax</A>:
<B>	:w ~/.vim/syntax/mine.vim</B>

Now you can start using your <A HREF="#syntax">syntax</A> file manually:
<B>	:set syntax=mine</B>
You don't have to exit Vim to use this.

If you also want Vim to detect the type of file, see |<A HREF="filetype.html#new-filetype">new-filetype</A>|.

If you are setting up a system with many users and you don't want each user
to add the same <A HREF="#syntax">syntax</A> file, you can use another directory from <A HREF="options.html#'runtimepath'">'runtimepath'</A>.



ADDING TO AN EXISTING SYNTAX FILE		*<A NAME="mysyntaxfile-add"></A><B>mysyntaxfile-add</B>*

If you are mostly satisfied with an existing <A HREF="#syntax">syntax</A> file, but would like to
add a few items or change the highlighting, follow these steps:

1. Create your user directory from <A HREF="options.html#'runtimepath'">'runtimepath'</A>, see above.

2. Create a directory in there called &quot;after/syntax&quot;.  For <A HREF="os_unix.html#Unix">Unix</A>:
<B>	mkdir ~/.vim/after</B>
<B>	mkdir ~/.vim/after/syntax</B>

3. Write a Vim <A HREF="usr_41.html#script">script</A> that contains the commands you want to use.  For
   example, to change the colors for the C <A HREF="#syntax">syntax</A>:
<B>	highlight cComment ctermfg=Green guifg=Green</B>

4. Write that file in the &quot;after/syntax&quot; directory.  Use the name of the
   <A HREF="#syntax">syntax</A>, with &quot;.vim&quot; added.  For our C <A HREF="#syntax">syntax</A>:
<B>	:w ~/.vim/after/syntax/c.vim</B>

That's <A HREF="motion.html#it">it</A>.  The next time you edit a C file the Comment color will be
different.  You don't even have to restart Vim.

If you have multiple files, you can use the <A HREF="filetype.html#filetype">filetype</A> <A HREF="motion.html#as">as</A> the directory name.
All the &quot;*.vim&quot; files in this directory will be used, for example:
	~/.vim/after/syntax/c/one.vim
	~/.vim/after/syntax/c/two.vim



REPLACING AN EXISTING SYNTAX FILE			*<A NAME="mysyntaxfile-replace"></A><B>mysyntaxfile-replace</B>*

If you don't like a distributed <A HREF="#syntax">syntax</A> file, or you have downloaded a new
version, follow the same steps <A HREF="motion.html#as">as</A> for |<A HREF="#mysyntaxfile">mysyntaxfile</A>| above.  Just make sure
that you write the <A HREF="#syntax">syntax</A> file in a directory that is early in <A HREF="options.html#'runtimepath'">'runtimepath'</A>.
Vim will only load the first <A HREF="#syntax">syntax</A> file found, assuming that <A HREF="motion.html#it">it</A> sets
b:current_syntax.



NAMING CONVENTIONS		    *<A NAME="group-name"></A><B>group-name</B>* *<A NAME="{group-name}"></A><B>{group-name}</B>* *<A NAME="E669"></A><B>E669</B>* *<A NAME="W18"></A><B>W18</B>*

A <A HREF="#syntax">syntax</A> group name is to be used for <A HREF="#syntax">syntax</A> items that match the same kind of
thing.  These are then linked to a highlight group that specifies the color.
A <A HREF="#syntax">syntax</A> group name doesn't specify any color or attributes itself.

The name for a highlight or <A HREF="#syntax">syntax</A> group must consist of ASCII letters, digits
and the underscore.  As a <A HREF="pattern.html#regexp">regexp</A>: &quot;[a-zA-Z0-9_]*&quot;

To be able to allow each user to pick his favorite set of colors, there must
be preferred names for highlight groups that are common for many languages.
These are the suggested group names (if <A HREF="#syntax">syntax</A> highlighting works properly
you can see the actual color, except for &quot;Ignore&quot;):

	*Comment	any comment

	*Constant	any constant
	 String		a string constant: &quot;this is a string&quot;
	 Character	a character constant: '<A HREF="change.html#c">c</A>', '\n'
	 <A HREF="eval.html#Number">Number</A>		a number constant: 234, 0xff
	 Boolean	a <A HREF="options.html#boolean">boolean</A> constant: TRUE, false
	 <A HREF="eval.html#Float">Float</A>		a floating point constant: 2.3e10

	*Identifier	any variable name
	 Function	function name (also: methods for classes)

	*Statement	any statement
	 Conditional	if, then, else, endif, switch, etc.
	 Repeat		for, <A HREF="diff.html#do">do</A>, while, etc.
	 Label		<A HREF="change.html#case">case</A>, default, etc.
	 Operator	&quot;sizeof&quot;, &quot;<A HREF="motion.html#+">+</A>&quot;, &quot;*&quot;, etc.
	 Keyword	any other keyword
	 Exception	try, catch, throw

	*PreProc	generic Preprocessor
	 Include	preprocessor #include
	 Define		preprocessor #define
	 Macro		same <A HREF="motion.html#as">as</A> Define
	 PreCondit	preprocessor #if, #else, #endif, etc.

	*Type		int, long, char, etc.
	 StorageClass	static, <A HREF="sponsor.html#register">register</A>, volatile, etc.
	 Structure	struct, union, enum, etc.
	 Typedef	A typedef

	*Special	any special symbol
	 SpecialChar	special character in a constant
	 Tag		you can use <A HREF="tagsrch.html#CTRL-]">CTRL-]</A> on this
	 Delimiter	character that needs attention
	 SpecialComment	special things inside a comment
	 Debug		debugging statements

	*Underlined	text that stands out, HTML links

	*Ignore		left blank, hidden  |<A HREF="#hl-Ignore">hl-Ignore</A>|

	*Error		any erroneous construct

	*Todo		anything that needs extra attention; mostly the
			keywords TODO FIXME and XXX

The names marked with &#42; are the preferred groups; the others are minor groups.
For the preferred groups, the &quot;syntax.vim&quot; file contains default highlighting.
The minor groups are linked to the preferred groups, so they get the same
highlighting.  You can override these defaults by using &quot;<A HREF="#:highlight">:highlight</A>&quot; commands
after sourcing the &quot;syntax.vim&quot; file.

Note that highlight group names are not <A HREF="change.html#case">case</A> sensitive.  &quot;String&quot; and &quot;string&quot;
can be used for the same group.

The following names are reserved and cannot be used <A HREF="motion.html#as">as</A> a group name:
	NONE   ALL   ALLBUT   contains	 contained


							*<A NAME="hl-Ignore"></A><B>hl-Ignore</B>*
When using the Ignore group, you may also consider using the <A HREF="#conceal">conceal</A>
mechanism.  See |<A HREF="#conceal">conceal</A>|.

==============================================================================

3. <A HREF="autocmd.html#Syntax">Syntax</A> loading procedure				*<A NAME="syntax-loading"></A><B>syntax-loading</B>*

This explains the details that happen when the command &quot;<A HREF="#:syntax">:syntax</A> enable&quot; is
issued.  When Vim initializes itself, <A HREF="motion.html#it">it</A> finds out where the runtime files are
located.  This is used here <A HREF="motion.html#as">as</A> the variable |<A HREF="starting.html#$VIMRUNTIME">$VIMRUNTIME</A>|.

&quot;<A HREF="#:syntax">:syntax</A> enable&quot; and &quot;<A HREF="#:syntax">:syntax</A> on&quot; <A HREF="diff.html#do">do</A> the following:

    Source $VIMRUNTIME/syntax/syntax.vim
    |
    +-	Clear out any old <A HREF="#syntax">syntax</A> by sourcing $VIMRUNTIME/syntax/nosyntax.vim
    |
    +-	Source first syntax/synload.vim in <A HREF="options.html#'runtimepath'">'runtimepath'</A>
    &#124;	|
    &#124;	+-  Setup the colors for <A HREF="#syntax">syntax</A> highlighting.  If a color scheme is
    &#124;	&#124;   defined <A HREF="motion.html#it">it</A> is loaded again with &quot;:colors {name}&quot;.  Otherwise
    &#124;	&#124;   &quot;:runtime! syntax/syncolor.vim&quot; is used.  &quot;<A HREF="#:syntax">:syntax</A> on&quot; overrules
    &#124;	&#124;   existing colors, &quot;<A HREF="#:syntax">:syntax</A> enable&quot; only sets groups that weren't
    &#124;	&#124;   set yet.
    &#124;	|
    &#124;	+-  Set up <A HREF="#syntax">syntax</A> autocmds to load the appropriate <A HREF="#syntax">syntax</A> file when

    &#124;	&#124;   the <A HREF="options.html#'syntax'">'syntax'</A> option is set. *<A NAME="synload-1"></A><B>synload-1</B>*
    &#124;	|
    &#124;	+-  Source the user's optional file, from the |<A HREF="#mysyntaxfile">mysyntaxfile</A>| variable.

    &#124;	    This is for backwards compatibility with Vim 5.x only. *<A NAME="synload-2"></A><B>synload-2</B>*
    |
    +-	Do &quot;<A HREF="filetype.html#:filetype">:filetype</A> on&quot;, which does &quot;:runtime! filetype.vim&quot;.  It loads any
    &#124;	filetype.vim files found.  It should always Source
    &#124;	$VIMRUNTIME/filetype.vim, which does the following.
    &#124;	|
    &#124;	+-  Install autocmds based on suffix to set the <A HREF="options.html#'filetype'">'filetype'</A> option
    &#124;	&#124;   This is where the connection between file name and file type is

    &#124;	&#124;   made for known file types. *<A NAME="synload-3"></A><B>synload-3</B>*
    &#124;	|

    &#124;	+-  Source the user's optional file, from the *<A NAME="myfiletypefile"></A><B>myfiletypefile</B>*
    &#124;	&#124;   variable.  This is for backwards compatibility with Vim 5.x only.

    &#124;	&#124;   *<A NAME="synload-4"></A><B>synload-4</B>*
    &#124;	|
    &#124;	+-  Install one <A HREF="autocmd.html#autocommand">autocommand</A> which sources scripts.vim when no file

    &#124;	&#124;   type was detected yet. *<A NAME="synload-5"></A><B>synload-5</B>*
    &#124;	|
    &#124;	+-  Source $VIMRUNTIME/menu.vim, to setup the <A HREF="autocmd.html#Syntax">Syntax</A> menu. |<A HREF="menu.html">menu.vim</A>|
    |
    +-	Install a <A HREF="autocmd.html#FileType">FileType</A> <A HREF="autocmd.html#autocommand">autocommand</A> to set the <A HREF="options.html#'syntax'">'syntax'</A> option when a file

    &#124;	type has been detected. *<A NAME="synload-6"></A><B>synload-6</B>*
    |
    +-	Execute <A HREF="#syntax">syntax</A> autocommands to start <A HREF="#syntax">syntax</A> highlighting for each
	already loaded buffer.


Upon loading a file, Vim finds the relevant <A HREF="#syntax">syntax</A> file <A HREF="motion.html#as">as</A> follows:

    Loading the file triggers the <A HREF="autocmd.html#BufReadPost">BufReadPost</A> autocommands.
    |
    +-	If there is a match with one of the autocommands from |<A HREF="#synload-3">synload-3</A>|
    &#124;	(known file types) or |<A HREF="#synload-4">synload-4</A>| (user's file types), the <A HREF="options.html#'filetype'">'filetype'</A>
    &#124;	option is set to the file type.
    |
    +-	The <A HREF="autocmd.html#autocommand">autocommand</A> at |<A HREF="#synload-5">synload-5</A>| is triggered.  If the file type was not
    &#124;	found yet, then scripts.vim is searched for in <A HREF="options.html#'runtimepath'">'runtimepath'</A>.  This
    &#124;	should always load $VIMRUNTIME/scripts.vim, which does the following.
    &#124;	|

    &#124;	+-  Source the user's optional file, from the *<A NAME="myscriptsfile"></A><B>myscriptsfile</B>*
    &#124;	&#124;   variable.  This is for backwards compatibility with Vim 5.x only.
    &#124;	|
    &#124;	+-  If the file type is still unknown, check the contents of the file,
    &#124;	    again with checks like &quot;getline(1) =~ pattern&quot; <A HREF="motion.html#as">as</A> to whether the
    &#124;	    file type can be recognized, and set <A HREF="options.html#'filetype'">'filetype'</A>.
    |
    +-	When the file type was determined and <A HREF="options.html#'filetype'">'filetype'</A> was set, this
    &#124;	triggers the <A HREF="autocmd.html#FileType">FileType</A> <A HREF="autocmd.html#autocommand">autocommand</A> |<A HREF="#synload-6">synload-6</A>| above.  It sets
    &#124;	<A HREF="options.html#'syntax'">'syntax'</A> to the determined file type.
    |
    +-	When the <A HREF="options.html#'syntax'">'syntax'</A> option was set above, this triggers an <A HREF="autocmd.html#autocommand">autocommand</A>
    &#124;	from |<A HREF="#synload-1">synload-1</A>| (and |<A HREF="#synload-2">synload-2</A>|).  This find the main <A HREF="#syntax">syntax</A> file in
    &#124;	<A HREF="options.html#'runtimepath'">'runtimepath'</A>, with this command:
    &#124;		runtime! syntax/&lt;name&gt;.vim
    |
    +-	Any other user installed <A HREF="autocmd.html#FileType">FileType</A> or <A HREF="autocmd.html#Syntax">Syntax</A> autocommands are
	triggered.  This can be used to change the highlighting for a specific
	<A HREF="#syntax">syntax</A>.

==============================================================================

4. <A HREF="autocmd.html#Syntax">Syntax</A> file remarks					*<A NAME=":syn-file-remarks"></A><B>:syn-file-remarks</B>*


						*<A NAME="b:current_syntax-variable"></A><B>b:current_syntax-variable</B>*
Vim stores the name of the <A HREF="#syntax">syntax</A> that has been loaded in the
&quot;b:current_syntax&quot; variable.  You can use this if you want to load other
settings, depending on which <A HREF="#syntax">syntax</A> is active.	Example:
<B>   :au BufReadPost * if b:current_syntax == "csh"</B>
<B>   :au BufReadPost *   do-some-things</B>
<B>   :au BufReadPost * endif</B>



2HTML						*<A NAME="2html.vim"></A><B>2html.vim</B>* *<A NAME="convert-to-HTML"></A><B>convert-to-HTML</B>*

This is not a <A HREF="#syntax">syntax</A> file itself, but a <A HREF="usr_41.html#script">script</A> that converts the current
<A HREF="windows.html#window">window</A> into HTML. Vim opens a new <A HREF="windows.html#window">window</A> in which <A HREF="motion.html#it">it</A> builds the HTML file.

After you save the resulting file, you can <A HREF="starting.html#view">view</A> <A HREF="motion.html#it">it</A> with any browser. The
colors should be exactly the same <A HREF="motion.html#as">as</A> you see them in Vim.  With
|<A HREF="#g:html_line_ids">g:html_line_ids</A>| you can jump to specific lines by adding (for example) #L123
or #123 to the end of the URL in your browser's address <A HREF="motion.html#bar">bar</A>. And with
|<A HREF="#g:html_dynamic_folds">g:html_dynamic_folds</A>| enabled, you can show or hide the text that is folded
in Vim.

You are not supposed to set the <A HREF="options.html#'filetype'">'filetype'</A> or <A HREF="options.html#'syntax'">'syntax'</A> option to &quot;2html&quot;!
Source the <A HREF="usr_41.html#script">script</A> to convert the current file:

<B>	:runtime! syntax/2html.vim</B>
 
Many <A HREF="eval.html#variables">variables</A> affect the output of <A HREF="#2html.vim">2html.vim</A>; see below. Any of the on/off
<A HREF="options.html#options">options</A> listed below can be enabled or disabled by setting them explicitly to
the desired value, or restored to their default by removing the variable using
|<A HREF="eval.html#:unlet">:unlet</A>|.

Remarks:
- Some truly ancient browsers may not show the background colors.
- From most browsers you can also print the file (in color)!
- The latest TOhtml may actually work with older versions of Vim, but some
  features such <A HREF="motion.html#as">as</A> <A HREF="#conceal">conceal</A> support will not function, and the colors may be
  incorrect for an old Vim without <A HREF="gui.html#GUI">GUI</A> support compiled in.

Here is an example how to run the <A HREF="usr_41.html#script">script</A> over all .c and .h files from a
<A HREF="os_unix.html#Unix">Unix</A> shell:
<B>   for f in *.[ch]; do gvim -f +"syn on" +"run! syntax/2html.vim" +"wq" +"q" $f; done</B>
 

					*<A NAME="g:html_start_line"></A><B>g:html_start_line</B>* *<A NAME="g:html_end_line"></A><B>g:html_end_line</B>*
To restrict the conversion to a range of lines, use a range with the |<A HREF="#:TOhtml">:TOhtml</A>|
command below, or set &quot;<A HREF="#g:html_start_line">g:html_start_line</A>&quot; and &quot;<A HREF="#g:html_end_line">g:html_end_line</A>&quot; to the first
and last line to be converted.  Example, using the last set <A HREF="visual.html#Visual">Visual</A> area:

<B>	:let g:html_start_line = line("'&lt;")</B>
<B>	:let g:html_end_line = line("'&gt;")</B>
<B>	:runtime! syntax/2html.vim</B>
 

							*<A NAME=":TOhtml"></A><B>:TOhtml</B>*
:[range]TOhtml		The &quot;<A HREF="#:TOhtml">:TOhtml</A>&quot; command is defined in a standard <A HREF="usr_05.html#plugin">plugin</A>.
			This command will source |<A HREF="2html.html">2html.vim</A>| for you. When a
			range is given, set |<A HREF="#g:html_start_line">g:html_start_line</A>| and
			|<A HREF="#g:html_end_line">g:html_end_line</A>| to the start and end of the range,
			respectively. Default range is the entire buffer.

                        If the current <A HREF="windows.html#window">window</A> is part of a |<A HREF="diff.html#diff">diff</A>|, unless
                        |<A HREF="#g:html_diff_one_file">g:html_diff_one_file</A>| is set, <A HREF="#:TOhtml">:TOhtml</A> will convert
                        all <A HREF="windows.html#windows">windows</A> which are part of the <A HREF="diff.html#diff">diff</A> in the current
                        <A HREF="intro.html#tab">tab</A> and place them side-by-side in a &lt;table&gt; element
                        in the generated HTML. With |<A HREF="#g:html_line_ids">g:html_line_ids</A>| you can
                        jump to lines in specific <A HREF="windows.html#windows">windows</A> with (for example)
                        #W1L42 for line <A HREF="usr_42.html#42">42</A> in the first diffed <A HREF="windows.html#window">window</A>, or
                        #W3L87 for line 87 in the third.

			Examples:

<B>	:10,40TOhtml " convert lines 10-40 to html</B>
<B>	:'&lt;,'&gt;TOhtml " convert current/last visual selection</B>
<B>	:TOhtml      " convert entire buffer</B>
 

							*<A NAME="g:html_diff_one_file"></A><B>g:html_diff_one_file</B>*
Default: 0.
When 0, and using |<A HREF="#:TOhtml">:TOhtml</A>| all <A HREF="windows.html#windows">windows</A> involved in a |<A HREF="diff.html#diff">diff</A>| in the current <A HREF="intro.html#tab">tab</A>
page are converted to HTML and placed side-by-side in a &lt;table&gt; element. When
1, only the current buffer is converted.
Example:

<B>	let g:html_diff_one_file = 1</B>
 

							 *<A NAME="g:html_whole_filler"></A><B>g:html_whole_filler</B>*
Default: 0.
When 0, if |<A HREF="#g:html_diff_one_file">g:html_diff_one_file</A>| is 1, a sequence of more than 3 filler lines
is displayed <A HREF="motion.html#as">as</A> three lines with the middle line mentioning the total number
of inserted lines.
When 1, always display all inserted lines <A HREF="motion.html#as">as</A> if |<A HREF="#g:html_diff_one_file">g:html_diff_one_file</A>| were
not set.

<B>    :let g:html_whole_filler = 1</B>
 

				     *<A NAME="TOhtml-performance"></A><B>TOhtml-performance</B>* *<A NAME="g:html_no_progress"></A><B>g:html_no_progress</B>*
Default: 0.
When 0, display a progress <A HREF="motion.html#bar">bar</A> in the statusline for each major step in the
<A HREF="#2html.vim">2html.vim</A> conversion process.
When 1, <A HREF="diff.html#do">do</A> not display the progress <A HREF="motion.html#bar">bar</A>. This offers a minor speed improvement
but you won't have any idea how much longer the conversion might take; for big
files <A HREF="motion.html#it">it</A> can take a long time!
Example:

<B>	let g:html_no_progress = 1</B>
 
You can obtain better performance improvements by also instructing Vim to not
run interactively, so that too much time is not taken to redraw <A HREF="motion.html#as">as</A> the <A HREF="usr_41.html#script">script</A>
moves through the buffer, switches <A HREF="windows.html#windows">windows</A>, and the like:

<B>  vim -E -s -c "let g:html_no_progress=1" -c "syntax on" -c "set ft=c" -c "runtime syntax/2html.vim" -cwqa myfile.c</B>
 
Note that the <A HREF="starting.html#-s">-s</A> flag prevents loading your <A HREF="starting.html#.vimrc">.vimrc</A> and any plugins, so you
need to explicitly source/enable anything that will affect the HTML
conversion. See |<A HREF="starting.html#-E">-E</A>| and |<A HREF="starting.html#-s-ex">-s-ex</A>| for details. It is probably best to create a
<A HREF="usr_41.html#script">script</A> to replace all the <A HREF="starting.html#-c">-c</A> commands and use <A HREF="motion.html#it">it</A> with the <A HREF="starting.html#-u">-u</A> flag instead of
specifying each command separately.


							 *<A NAME="g:html_number_lines"></A><B>g:html_number_lines</B>*
Default: current <A HREF="options.html#'number'">'number'</A> setting.
When 0, buffer text is displayed in the generated HTML without line numbering.
When 1, a column of line numbers is added to the generated HTML with the same
highlighting <A HREF="motion.html#as">as</A> the line number column in Vim (|<A HREF="#hl-LineNr">hl-LineNr</A>|).
Force line numbers even if <A HREF="options.html#'number'">'number'</A> is not set:
<B>   :let g:html_number_lines = 1</B>
Force to omit the line numbers:
<B>   :let g:html_number_lines = 0</B>
Go back to the default to use <A HREF="options.html#'number'">'number'</A> by <A HREF="change.html#deleting">deleting</A> the variable:
<B>   :unlet g:html_number_lines</B>
 

                                                             *<A NAME="g:html_line_ids"></A><B>g:html_line_ids</B>*
Default: 1 if |<A HREF="#g:html_number_lines">g:html_number_lines</A>| is set, 0 otherwise.
When 1, adds an HTML id attribute to each line number, or to an empty &lt;span&gt;
inserted for that purpose if no line numbers are shown. This ID attribute
takes the form of L123 for single-buffer HTML pages, or W2L123 for diff-view
pages, and is used to jump to a specific line (in a specific <A HREF="windows.html#window">window</A> of a <A HREF="diff.html#diff">diff</A>
<A HREF="starting.html#view">view</A>). Javascript is inserted to open any closed dynamic <A HREF="fold.html#folds">folds</A>
(|<A HREF="#g:html_dynamic_folds">g:html_dynamic_folds</A>|) containing the specificed line before jumping. The
javascript also allows omitting the <A HREF="windows.html#window">window</A> ID in the url, and the leading <A HREF="motion.html#L">L</A>.
For example:

<B>	page.html#L123	jumps to line 123 in a single-buffer file</B>
<B>	page.html#123	does the same</B>

<B>	diff.html#W1L42	jumps to line 42 in the first window in a diff</B>
<B>	diff.html#42	does the same</B>
 

							      *<A NAME="g:html_use_css"></A><B>g:html_use_css</B>*
Default: 1.
When 1, generate valid HTML 4.01 markup with CSS1 styling, supported in all
modern browsers and most old browsers.
When 0, generate &lt;font&gt; <A HREF="tagsrch.html#tags">tags</A> and similar outdated markup. This is not
recommended but <A HREF="motion.html#it">it</A> may work better in really old browsers, email clients,
forum posts, and similar situations where basic CSS support is unavailable.
Example:
<B>   :let g:html_use_css = 0</B>
 

						       *<A NAME="g:html_ignore_conceal"></A><B>g:html_ignore_conceal</B>*
Default: 0.
When 0, concealed text is removed from the HTML and replaced with a character
from |<A HREF="#:syn-cchar">:syn-cchar</A>| or <A HREF="options.html#'listchars'">'listchars'</A> <A HREF="motion.html#as">as</A> appropriate, depending on the current
value of <A HREF="options.html#'conceallevel'">'conceallevel'</A>.
When 1, include all text from the buffer in the generated HTML, even if <A HREF="motion.html#it">it</A> is
YXXYconceal|ed.

Either of the following commands will ensure that all text in the buffer is
included in the generated HTML (unless <A HREF="motion.html#it">it</A> is folded):
<B>   :let g:html_ignore_conceal = 1</B>
<B>   :setl conceallevel=0</B>
 

						       *<A NAME="g:html_ignore_folding"></A><B>g:html_ignore_folding</B>*
Default: 0.
When 0, text in a closed fold is replaced by the text shown for the fold in
Vim (|<A HREF="fold.html#fold-foldtext">fold-foldtext</A>|). See |<A HREF="#g:html_dynamic_folds">g:html_dynamic_folds</A>| if you also want to allow
the user to expand the fold <A HREF="motion.html#as">as</A> in Vim to see the text inside.
When 1, include all text from the buffer in the generated HTML; whether the
text is in a fold has no impact at all. |<A HREF="#g:html_dynamic_folds">g:html_dynamic_folds</A>| has no effect.

Either of these commands will ensure that all text in the buffer is included
in the generated HTML (unless <A HREF="motion.html#it">it</A> is concealed):
<B>   zR</B>
<B>   :let g:html_ignore_folding = 1</B>
 

							*<A NAME="g:html_dynamic_folds"></A><B>g:html_dynamic_folds</B>*
Default: 0.
When 0, text in a closed fold is not included at all in the generated HTML.
When 1, generate javascript to open a fold and show the text within, just like
in Vim.

Setting this variable to 1 causes <A HREF="#2html.vim">2html.vim</A> to always use CSS for styling,
regardless of what |<A HREF="#g:html_use_css">g:html_use_css</A>| is set to.

This variable is ignored when |<A HREF="#g:html_ignore_folding">g:html_ignore_folding</A>| is set.

<B>   :let g:html_dynamic_folds = 1</B>
 

							*<A NAME="g:html_no_foldcolumn"></A><B>g:html_no_foldcolumn</B>*
Default: 0.
When 0, if |<A HREF="#g:html_dynamic_folds">g:html_dynamic_folds</A>| is 1, generate a column of text similar to
Vim's foldcolumn (|<A HREF="fold.html#fold-foldcolumn">fold-foldcolumn</A>|) the user can click on to toggle <A HREF="fold.html#folds">folds</A>
open or closed. The minimum width of the generated text column is the current
<A HREF="options.html#'foldcolumn'">'foldcolumn'</A> setting.
When 1, <A HREF="diff.html#do">do</A> not generate this column; instead, hovering the mouse cursor over
folded text will open the fold <A HREF="motion.html#as">as</A> if |<A HREF="#g:html_hover_unfold">g:html_hover_unfold</A>| were set.

<B>   :let g:html_no_foldcolumn = 1</B>
 

				*<A NAME="TOhtml-uncopyable-text"></A><B>TOhtml-uncopyable-text</B>* *<A NAME="g:html_prevent_copy"></A><B>g:html_prevent_copy</B>*
Default: empty string.
This option prevents certain regions of the generated HTML from being copied,
when you select all text in document rendered in a browser and copy <A HREF="motion.html#it">it</A>. Useful
for allowing users to copy-paste only the source text even if a fold column or
line numbers are shown in the generated content. Specify regions to be
affected in this way <A HREF="motion.html#as">as</A> follows:
	<A HREF="motion.html#f">f</A>:	fold column
	<A HREF="pattern.html#n">n</A>:	line numbers (also within fold text)
	<A HREF="eval.html#t:">t:</A>	fold text
	<A HREF="change.html#d">d</A>:	<A HREF="diff.html#diff">diff</A> filler

Example, to make the fold column and line numbers uncopyable:
<B>	:let g:html_prevent_copy = "fn"</B>
 
This feature is currently implemented by <A HREF="insert.html#inserting">inserting</A> read-only &lt;input&gt; elements
into the markup to contain the uncopyable areas. This does not work well in
all cases. When pasting to some applications which understand HTML, the
&lt;input&gt; elements also get pasted. But plain-text paste destinations should
always work.


							   *<A NAME="g:html_no_invalid"></A><B>g:html_no_invalid</B>*
Default: 0.
When 0, if |<A HREF="#g:html_prevent_copy">g:html_prevent_copy</A>| is non-empty, an invalid attribute is
intentionally inserted into the &lt;input&gt; element for the uncopyable areas. This
increases the number of applications you can paste to without also pasting the
&lt;input&gt; elements. Specifically, Microsoft Word will not paste the &lt;input&gt;
elements if they contain this invalid attribute.
When 1, no invalid markup is ever intentionally inserted, and the generated
page should validate. However, be careful pasting into Microsoft Word when
|<A HREF="#g:html_prevent_copy">g:html_prevent_copy</A>| is non-empty; <A HREF="motion.html#it">it</A> can be hard to get rid of the &lt;input&gt;
elements which get pasted.


							 *<A NAME="g:html_hover_unfold"></A><B>g:html_hover_unfold</B>*
Default: 0.
When 0, the only way to open a fold generated by <A HREF="#2html.vim">2html.vim</A> with
|<A HREF="#g:html_dynamic_folds">g:html_dynamic_folds</A>| set, is to click on the generated fold column.
When 1, use CSS 2.0 to allow the user to open a fold by moving the mouse
cursor over the displayed fold text. This is useful to allow users with
disabled javascript to <A HREF="starting.html#view">view</A> the folded text.

Note that old browsers (notably Internet Explorer 6) will not support this
feature.  Browser-specific markup for IE6 is included to fall back to the
normal CSS1 styling so that the <A HREF="fold.html#folds">folds</A> show up correctly for this browser, but
they will not be openable without a foldcolumn.

<B>   :let g:html_hover_unfold = 1</B>
 

							      *<A NAME="g:html_id_expr"></A><B>g:html_id_expr</B>*
Default: &quot;&quot;
Dynamic <A HREF="fold.html#folding">folding</A> and jumping to line IDs rely on unique IDs within the document
to work. If generated HTML is copied into a larger document, these IDs are no
longer guaranteed to be unique. Set <A HREF="#g:html_id_expr">g:html_id_expr</A> to an <A HREF="eval.html#expression">expression</A> Vim can
evaluate to get a unique string to append to each ID used in a given document,
so that the full IDs will be unique even when combined with other content in a
larger HTML document. Example, to append _ and the buffer number to each ID:

<B>	:let g:html_id_expr = '"_".bufnr("%")'</B>
 
To append a string &quot;_mystring&quot; to the end of each ID:

<B>	:let g:html_id_expr = '"_mystring"'</B>
 
Note, when converting a <A HREF="diff.html#diff">diff</A> <A HREF="starting.html#view">view</A> to HTML, the <A HREF="eval.html#expression">expression</A> will only be
evaluated for the first <A HREF="windows.html#window">window</A> in the <A HREF="diff.html#diff">diff</A>, and the result used for all the
<A HREF="windows.html#windows">windows</A>.


					  *<A NAME="TOhtml-wrap-text"></A><B>TOhtml-wrap-text</B>* *<A NAME="g:html_pre_wrap"></A><B>g:html_pre_wrap</B>*
Default: current <A HREF="options.html#'wrap'">'wrap'</A> setting.
When 0, if |<A HREF="#g:html_no_pre">g:html_no_pre</A>| is 0 or unset, the text in the generated HTML does
not wrap at the edge of the browser <A HREF="windows.html#window">window</A>.
When 1, if |<A HREF="#g:html_use_css">g:html_use_css</A>| is 1, the CSS 2.0 &quot;white-space:pre-wrap&quot; value is
used, causing the text to wrap at <A HREF="pattern.html#whitespace">whitespace</A> at the edge of the browser
<A HREF="windows.html#window">window</A>.
Explicitly enable text wrapping:
<B>   :let g:html_pre_wrap = 1</B>
Explicitly disable wrapping:
<B>   :let g:html_pre_wrap = 0</B>
Go back to default, determine wrapping from <A HREF="options.html#'wrap'">'wrap'</A> setting:
<B>   :unlet g:html_pre_wrap</B>
 

							       *<A NAME="g:html_no_pre"></A><B>g:html_no_pre</B>*
Default: 0.
When 0, buffer text in the generated HTML is surrounded by &lt;pre&gt;...&lt;/pre&gt;
<A HREF="tagsrch.html#tags">tags</A>. Series of <A HREF="pattern.html#whitespace">whitespace</A> is shown <A HREF="motion.html#as">as</A> in Vim without special markup, and <A HREF="intro.html#tab">tab</A>
characters can be included literally (see |<A HREF="#g:html_expand_tabs">g:html_expand_tabs</A>|).
When 1 (not recommended), the &lt;pre&gt; <A HREF="tagsrch.html#tags">tags</A> are omitted, and a plain &lt;div&gt; is
used instead. Whitespace is replaced by a series of &amp;nbsp; character
references, and &lt;br&gt; is used to end each line. This is another way to allow
text in the generated HTML is wrap (see |<A HREF="#g:html_pre_wrap">g:html_pre_wrap</A>|) which also works in
old browsers, but may cause noticeable differences between Vim's display and
the rendered page generated by <A HREF="#2html.vim">2html.vim</A>.

<B>   :let g:html_no_pre = 1</B>
 

							  *<A NAME="g:html_expand_tabs"></A><B>g:html_expand_tabs</B>*
Default: 1 if <A HREF="options.html#'tabstop'">'tabstop'</A> is 8, <A HREF="options.html#'expandtab'">'expandtab'</A> is 0, and no fold column or line
		numbers occur in the generated HTML;
	 0 otherwise.
When 0, <A HREF="motion.html#&lt;Tab&gt;">&lt;Tab&gt;</A> characters in the buffer text are replaced with an appropriate
number of space characters, or &amp;nbsp; references if |<A HREF="#g:html_no_pre">g:html_no_pre</A>| is 1.
When 1, if |<A HREF="#g:html_no_pre">g:html_no_pre</A>| is 0 or unset, <A HREF="motion.html#&lt;Tab&gt;">&lt;Tab&gt;</A> characters in the buffer text
are included as-is in the generated HTML. This is useful for when you want to
allow copy and paste from a browser without losing the actual <A HREF="pattern.html#whitespace">whitespace</A> in
the source document. Note that this can easily break text alignment and
indentation in the HTML, unless set by default.

Force |<A HREF="2html.html">2html.vim</A>| to keep <A HREF="motion.html#&lt;Tab&gt;">&lt;Tab&gt;</A> characters:
<B>   :let g:html_expand_tabs = 0</B>
 
Force tabs to be expanded:
<B>   :let g:html_expand_tabs = 1</B>
 

				    *<A NAME="TOhtml-encoding-detect"></A><B>TOhtml-encoding-detect</B>* *<A NAME="TOhtml-encoding"></A><B>TOhtml-encoding</B>*
It is highly recommended to set your desired encoding with
|<A HREF="#g:html_use_encoding">g:html_use_encoding</A>| for any content which will be placed on a web server.

If you <A HREF="diff.html#do">do</A> not specify an encoding, |<A HREF="2html.html">2html.vim</A>| uses the preferred IANA name
for the current value of <A HREF="options.html#'fileencoding'">'fileencoding'</A> if set, or <A HREF="options.html#'encoding'">'encoding'</A> if not.
<A HREF="options.html#'encoding'">'encoding'</A> is always used for certain <A HREF="options.html#'buftype'">'buftype'</A> values. <A HREF="options.html#'fileencoding'">'fileencoding'</A> will be
set to match the chosen document encoding.

Automatic detection works for the encodings mentioned specifically by name in
|<A HREF="mbyte.html#encoding-names">encoding-names</A>|, but TOhtml will only automatically use those encodings with
wide browser support. However, you can override this to support specific
encodings that may not be automatically detected by default (see <A HREF="options.html#options">options</A>
 below. See	<A HREF="http://www.iana.org/assignments/character-sets">http://www.iana.org/assignments/character-sets</A> for the IANA names.

Note, by default all <A HREF="mbyte.html#Unicode">Unicode</A> encodings are converted to <A HREF="mbyte.html#UTF-8">UTF-8</A> with no BOM in
the generated HTML, <A HREF="motion.html#as">as</A> recommended by W3C:

	<A HREF="http://www.w3.org/International/questions/qa-choosing-encodings">http://www.w3.org/International/questions/qa-choosing-encodings</A>
	<A HREF="http://www.w3.org/International/questions/qa-byte-order-mark">http://www.w3.org/International/questions/qa-byte-order-mark</A>


							 *<A NAME="g:html_use_encoding"></A><B>g:html_use_encoding</B>*
Default: none, uses IANA name for current <A HREF="options.html#'fileencoding'">'fileencoding'</A> <A HREF="motion.html#as">as</A> above.
To overrule all automatic <A HREF="mbyte.html#charset">charset</A> detection, set <A HREF="#g:html_use_encoding">g:html_use_encoding</A> to the
name of the <A HREF="mbyte.html#charset">charset</A> to be used. It is recommended to set this variable to
something widely supported, like <A HREF="mbyte.html#UTF-8">UTF-8</A>, for anything you will be hosting on a
webserver:
<B>   :let g:html_use_encoding = "UTF-8"</B>
You can also use this option to omit the line that specifies the <A HREF="mbyte.html#charset">charset</A>
entirely, by setting <A HREF="#g:html_use_encoding">g:html_use_encoding</A> to an empty string (NOT recommended):
<B>   :let g:html_use_encoding = ""</B>
To go back to the automatic mechanism, delete the |<A HREF="#g:html_use_encoding">g:html_use_encoding</A>|
variable:
<B>   :unlet g:html_use_encoding</B>
 

						    *<A NAME="g:html_encoding_override"></A><B>g:html_encoding_override</B>*
Default: none, autoload/tohtml.vim contains default conversions for encodings
		mentioned by name at |<A HREF="mbyte.html#encoding-names">encoding-names</A>|.
This option allows |<A HREF="2html.html">2html.vim</A>| to detect the correct <A HREF="options.html#'fileencoding'">'fileencoding'</A> when you
specify an encoding with |<A HREF="#g:html_use_encoding">g:html_use_encoding</A>| which is not in the default
list of conversions.

This is a dictionary of charset-encoding pairs that will replace existing
pairs automatically detected by TOhtml, or supplement with new pairs.

Detect the HTML <A HREF="mbyte.html#charset">charset</A> &quot;windows-1252&quot; <A HREF="motion.html#as">as</A> the encoding &quot;8bit-cp1252&quot;:
<B>   :let g:html_encoding_override = {'windows-1252': '8bit-cp1252'}</B>
 

						     *<A NAME="g:html_charset_override"></A><B>g:html_charset_override</B>*
Default: none, autoload/tohtml.vim contains default conversions for encodings
		mentioned by name at |<A HREF="mbyte.html#encoding-names">encoding-names</A>| and which have wide
		browser support.
This option allows |<A HREF="2html.html">2html.vim</A>| to detect the HTML <A HREF="mbyte.html#charset">charset</A> for any
<A HREF="options.html#'fileencoding'">'fileencoding'</A> or <A HREF="options.html#'encoding'">'encoding'</A> which is not detected automatically. You can also
use <A HREF="motion.html#it">it</A> to override specific existing encoding-charset pairs. For example,
TOhtml will by default use <A HREF="mbyte.html#UTF-8">UTF-8</A> for all Unicode/UCS encodings. To use UTF-16
and UTF-32 instead, use:
<B>   :let g:html_charset_override = {'ucs-4': 'UTF-32', 'utf-16': 'UTF-16'}</B>

Note that documents encoded in either UTF-32 or UTF-16 have known
compatibility problems with some major browsers.


			*<A NAME="convert-to-XML"></A><B>convert-to-XML</B>* *<A NAME="convert-to-XHTML"></A><B>convert-to-XHTML</B>* *<A NAME="g:html_use_xhtml"></A><B>g:html_use_xhtml</B>*
Default: 0.
When 0, generate standard HTML 4.01 (strict when possible).
When 1, generate XHTML 1.0 instead (XML compliant HTML).

<B>    :let g:html_use_xhtml = 1</B>
 


ABEL						*<A NAME="abel.vim"></A><B>abel.vim</B>* *<A NAME="ft-abel-syntax"></A><B>ft-abel-syntax</B>*

ABEL highlighting provides some user-defined <A HREF="options.html#options">options</A>.  To enable them, assign
any value to the respective variable.  Example:
<B>	:let abel_obsolete_ok=1</B>
To disable them use &quot;<A HREF="eval.html#:unlet">:unlet</A>&quot;.  Example:
<B>	:unlet abel_obsolete_ok</B>

<B><FONT COLOR="PURPLE">Variable			Highlight </FONT></B>
abel_obsolete_ok		obsolete keywords are statements, not <A HREF="message.html#errors">errors</A>
abel_cpp_comments_illegal	<A HREF="diff.html#do">do</A> not interpret '<A HREF="version7.html#//">//</A>' <A HREF="motion.html#as">as</A> inline comment leader


ADA

See |<A HREF="ft_ada.html#ft-ada-syntax">ft-ada-syntax</A>|



ANT						*<A NAME="ant.vim"></A><B>ant.vim</B>* *<A NAME="ft-ant-syntax"></A><B>ft-ant-syntax</B>*

The ant <A HREF="#syntax">syntax</A> file provides <A HREF="#syntax">syntax</A> highlighting for javascript and <A HREF="if_pyth.html#python">python</A>
by default.  <A HREF="autocmd.html#Syntax">Syntax</A> highlighting for other <A HREF="usr_41.html#script">script</A> languages can be installed
by the function AntSyntaxScript(), which takes the <A HREF="tagsrch.html#tag">tag</A> name <A HREF="motion.html#as">as</A> first argument
and the <A HREF="usr_41.html#script">script</A> <A HREF="#syntax">syntax</A> file name <A HREF="motion.html#as">as</A> second argument.  Example:

<B>	:call AntSyntaxScript('perl', 'perl.vim')</B>

will <A HREF="usr_90.html#install">install</A> <A HREF="#syntax">syntax</A> <A HREF="if_perl.html#perl">perl</A> highlighting for the following ant code

<B>	&lt;script language = 'perl'&gt;&lt;![CDATA[</B>
<B>	    # everything inside is highlighted as perl</B>
<B>	]]&gt;&lt;/script&gt;</B>

See |<A HREF="#mysyntaxfile-add">mysyntaxfile-add</A>| for installing <A HREF="usr_41.html#script">script</A> languages permanently.



APACHE						*<A NAME="apache.vim"></A><B>apache.vim</B>* *<A NAME="ft-apache-syntax"></A><B>ft-apache-syntax</B>*

The apache <A HREF="#syntax">syntax</A> file provides <A HREF="#syntax">syntax</A> highlighting depending on Apache HTTP
server version, by default for 1.3.x.  Set &quot;apache_version&quot; to Apache version
(as a string) to get highlighting for another version.	Example:

<B>	:let apache_version = "2.0"</B>
 


		*<A NAME="asm.vim"></A><B>asm.vim</B>* *<A NAME="asmh8300.vim"></A><B>asmh8300.vim</B>* *<A NAME="nasm.vim"></A><B>nasm.vim</B>* *<A NAME="masm.vim"></A><B>masm.vim</B>* *<A NAME="asm68k"></A><B>asm68k</B>*

ASSEMBLY	*<A NAME="ft-asm-syntax"></A><B>ft-asm-syntax</B>* *<A NAME="ft-asmh8300-syntax"></A><B>ft-asmh8300-syntax</B>* *<A NAME="ft-nasm-syntax"></A><B>ft-nasm-syntax</B>*

		*<A NAME="ft-masm-syntax"></A><B>ft-masm-syntax</B>* *<A NAME="ft-asm68k-syntax"></A><B>ft-asm68k-syntax</B>* *<A NAME="fasm.vim"></A><B>fasm.vim</B>*

Files matching &quot;*.i&quot; could be Progress or Assembly.  If the automatic detection
doesn't work for you, or you don't edit Progress at all, use this in your
<A HREF="starting.html#startup">startup</A> <A HREF="starting.html#vimrc">vimrc</A>:
<B>   :let filetype_i = "asm"</B>
<A HREF="insert.html#Replace">Replace</A> &quot;asm&quot; with the type of assembly you use.

There are many types of assembly languages that all use the same file name
extensions.  Therefore you will have to select the type yourself, or add a
line in the assembly file that Vim will recognize.  Currently these <A HREF="#syntax">syntax</A>
files are included:
	asm		GNU assembly (the default)
	<A HREF="#asm68k">asm68k</A>		Motorola 680x0 assembly
	asmh8300	Hitachi H-8300 version of GNU assembly
	ia64		Intel Itanium 64
 fasm Flat assembly	<A HREF="http://flatassembler.net">http://flatassembler.net</A>
	masm		Microsoft assembly (probably works for any 80x86)
	nasm		Netwide assembly
	tasm		Turbo Assembly (with opcodes 80x86 up to Pentium, and
			MMX)
	pic		PIC assembly (currently for PIC16F84)

The most flexible is to add a line in your assembly file containing:
<B>	asmsyntax=nasm</B>
<A HREF="insert.html#Replace">Replace</A> &quot;nasm&quot; with the name of the real assembly <A HREF="#syntax">syntax</A>.  This line must be
one of the first five lines in the file.  No non-white text must be
immediately before or after this text.  Note that specifying asmsyntax=foo is
equivalent to setting ft=foo in a |<A HREF="options.html#modeline">modeline</A>|, and that in <A HREF="change.html#case">case</A> of a conflict
between the two settings the one from the <A HREF="options.html#modeline">modeline</A> will take precedence (in
particular, if you have ft=asm in the <A HREF="options.html#modeline">modeline</A>, you will get the GNU <A HREF="#syntax">syntax</A>
highlighting regardless of what is specified <A HREF="motion.html#as">as</A> asmsyntax).

The <A HREF="#syntax">syntax</A> type can always be overruled for a specific buffer by setting the
b:asmsyntax variable:
<B>	:let b:asmsyntax = "nasm"</B>

If b:asmsyntax is not set, either automatically or by hand, then the value of
the global variable asmsyntax is used.	This can be seen <A HREF="motion.html#as">as</A> a default assembly
language:
<B>	:let asmsyntax = "nasm"</B>

As a last resort, if nothing is defined, the &quot;asm&quot; <A HREF="#syntax">syntax</A> is used.


<B><FONT COLOR="PURPLE">Netwide assembler (nasm.vim) optional highlighting </FONT></B>

To enable a feature:
<B>	:let   {variable}=1|set syntax=nasm</B>
To disable a feature:
<B>	:unlet {variable}  |set syntax=nasm</B>

<B><FONT COLOR="PURPLE">Variable		Highlight </FONT></B>
nasm_loose_syntax	unofficial parser allowed <A HREF="#syntax">syntax</A> not <A HREF="motion.html#as">as</A> Error
			  (parser dependent; not recommended)
nasm_ctx_outside_macro	contexts outside <A HREF="map.html#macro">macro</A> not <A HREF="motion.html#as">as</A> Error
nasm_no_warn		potentially risky <A HREF="#syntax">syntax</A> not <A HREF="motion.html#as">as</A> ToDo



ASPPERL and ASPVBS			*<A NAME="ft-aspperl-syntax"></A><B>ft-aspperl-syntax</B>* *<A NAME="ft-aspvbs-syntax"></A><B>ft-aspvbs-syntax</B>*

*.asp and *.asa files could be either <A HREF="if_perl.html#Perl">Perl</A> or <A HREF="visual.html#Visual">Visual</A> Basic <A HREF="usr_41.html#script">script</A>.  Since it's
hard to detect this you can set two global <A HREF="eval.html#variables">variables</A> to tell Vim what you are
using.	For <A HREF="if_perl.html#Perl">Perl</A> <A HREF="usr_41.html#script">script</A> use:
<B>	:let g:filetype_asa = "aspperl"</B>
<B>	:let g:filetype_asp = "aspperl"</B>
For <A HREF="visual.html#Visual">Visual</A> Basic use:
<B>	:let g:filetype_asa = "aspvbs"</B>
<B>	:let g:filetype_asp = "aspvbs"</B>



BAAN						    *<A NAME="baan.vim"></A><B>baan.vim</B>* *<A NAME="baan-syntax"></A><B>baan-syntax</B>*

The <A HREF="#baan.vim">baan.vim</A> gives <A HREF="#syntax">syntax</A> support for BaanC of release BaanIV upto SSA ERP LN
for both 3 GL and 4 GL programming. Large number of standard defines/constants
are supported.

Some special violation of coding standards will be signalled when one specify
in ones YXXY.vimrc|:
<B>	let baan_code_stds=1</B>


*<A NAME="baan-folding"></A><B>baan-folding</B>*

<A HREF="autocmd.html#Syntax">Syntax</A> <A HREF="fold.html#folding">folding</A> can be enabled at various levels through the <A HREF="eval.html#variables">variables</A>
mentioned below (Set those in your |<A HREF="starting.html#.vimrc">.vimrc</A>|). The more complex <A HREF="fold.html#folding">folding</A> on
source blocks and SQL can be CPU intensive.

To allow any <A HREF="fold.html#folding">folding</A> and enable <A HREF="fold.html#folding">folding</A> at function level use:
<B>	let baan_fold=1</B>
<A HREF="fold.html#Folding">Folding</A> can be enabled at source block level <A HREF="motion.html#as">as</A> if, while, for ,... The
indentation preceding the begin/end keywords has to match (spaces are not
considered equal to a <A HREF="intro.html#tab">tab</A>).
<B>	let baan_fold_block=1</B>
<A HREF="fold.html#Folding">Folding</A> can be enabled for embedded SQL blocks <A HREF="motion.html#as">as</A> SELECT, SELECTDO,
SELECTEMPTY, <A HREF="eval.html#...">...</A> The indentation preceding the begin/end keywords has to
match (spaces are not considered equal to a <A HREF="intro.html#tab">tab</A>).
<B>	let baan_fold_sql=1</B>
Note: Block <A HREF="fold.html#folding">folding</A> can result in many small <A HREF="fold.html#folds">folds</A>. It is suggested to |<A HREF="options.html#:set">:set</A>|
the <A HREF="options.html#options">options</A> <A HREF="options.html#'foldminlines'">'foldminlines'</A> and <A HREF="options.html#'foldnestmax'">'foldnestmax'</A> in |<A HREF="starting.html#.vimrc">.vimrc</A>| or use |<A HREF="options.html#:setlocal">:setlocal</A>| in
.../after/syntax/baan.vim (see |<A HREF="options.html#after-directory">after-directory</A>|). Eg:
<B>	set foldminlines=5</B>
<B>	set foldnestmax=6</B>



BASIC			*<A NAME="basic.vim"></A><B>basic.vim</B>* *<A NAME="vb.vim"></A><B>vb.vim</B>* *<A NAME="ft-basic-syntax"></A><B>ft-basic-syntax</B>* *<A NAME="ft-vb-syntax"></A><B>ft-vb-syntax</B>*

Both <A HREF="visual.html#Visual">Visual</A> Basic and &quot;normal&quot; basic use the extension &quot;.bas&quot;.	To detect
which one should be used, Vim checks for the string &quot;VB_Name&quot; in the first
five lines of the file.  If <A HREF="motion.html#it">it</A> is not found, <A HREF="filetype.html#filetype">filetype</A> will be &quot;basic&quot;,
otherwise &quot;vb&quot;.  Files with the &quot;.frm&quot; extension will always be seen <A HREF="motion.html#as">as</A> <A HREF="visual.html#Visual">Visual</A>
Basic.



C							*<A NAME="c.vim"></A><B>c.vim</B>* *<A NAME="ft-c-syntax"></A><B>ft-c-syntax</B>*

A few things in C highlighting are optional.  To enable them assign any value
to the respective variable.  Example:
<B>	:let c_comment_strings = 1</B>
To disable them use &quot;<A HREF="eval.html#:unlet">:unlet</A>&quot;.  Example:
<B>	:unlet c_comment_strings</B>

<B><FONT COLOR="PURPLE">Variable		Highlight </FONT></B>
c_gnu			GNU gcc specific items
c_comment_strings	strings and numbers inside a comment
c_space_errors		trailing white space and spaces before a <A HREF="motion.html#&lt;Tab&gt;">&lt;Tab&gt;</A>
c_no_trail_space_error	 <A HREF="eval.html#...">...</A> but no trailing spaces
c_no_tab_space_error	 <A HREF="eval.html#...">...</A> but no spaces before a <A HREF="motion.html#&lt;Tab&gt;">&lt;Tab&gt;</A>
c_no_bracket_error	don't highlight <A HREF="intro.html#{}">{}</A>; inside <A HREF="motion.html#[]">[]</A> <A HREF="motion.html#as">as</A> <A HREF="message.html#errors">errors</A>
c_no_curly_error	don't highlight <A HREF="intro.html#{}">{}</A>; inside <A HREF="motion.html#[]">[]</A> and () <A HREF="motion.html#as">as</A> <A HREF="message.html#errors">errors</A>;
				except { and } in first column
c_curly_error		highlight a missing }; this forces syncing from the
			start of the file, can be slow
c_no_ansi		don't <A HREF="diff.html#do">do</A> standard ANSI types and constants
c_ansi_typedefs		 <A HREF="eval.html#...">...</A> but <A HREF="diff.html#do">do</A> standard ANSI types
c_ansi_constants	 <A HREF="eval.html#...">...</A> but <A HREF="diff.html#do">do</A> standard ANSI constants
c_no_utf		don't highlight \u and \U in strings
c_syntax_for_h		for *.h files use C <A HREF="#syntax">syntax</A> instead of C++ and use objc
			<A HREF="#syntax">syntax</A> instead of objcpp
c_no_if0		don't highlight &quot;#if 0&quot; blocks <A HREF="motion.html#as">as</A> comments
c_no_cformat		don't highlight &#37;-formats in strings
c_no_c99		don't highlight C99 standard items
c_no_c11		don't highlight C11 standard items

When <A HREF="options.html#'foldmethod'">'foldmethod'</A> is set to &quot;<A HREF="#syntax">syntax</A>&quot; then /* */ comments and { } blocks will
become a fold.  If you don't want comments to become a fold use:
<B>	:let c_no_comment_fold = 1</B>
&quot;#if 0&quot; blocks are also folded, unless:
<B>	:let c_no_if0_fold = 1</B>

If you notice highlighting <A HREF="message.html#errors">errors</A> while <A HREF="scroll.html#scrolling">scrolling</A> backwards, which are fixed
when redrawing with <A HREF="various.html#CTRL-L">CTRL-L</A>, try setting the &quot;c_minlines&quot; internal variable
to a larger number:
<B>	:let c_minlines = 100</B>
This will make the <A HREF="#syntax">syntax</A> synchronization start 100 lines before the first
displayed line.  The default value is 50 (15 when c_no_if0 is set).  The
disadvantage of using a larger number is that redrawing can become slow.

When using the &quot;#if 0&quot; / &quot;#endif&quot; comment highlighting, notice that this only
works when the &quot;#if 0&quot; is within &quot;c_minlines&quot; from the top of the <A HREF="windows.html#window">window</A>.  If
you have a long &quot;#if 0&quot; construct <A HREF="motion.html#it">it</A> will not be highlighted correctly.

To match extra items in comments, use the cCommentGroup cluster.
Example:
<B>   :au Syntax c call MyCadd()</B>
<B>   :function MyCadd()</B>
<B>   :  syn keyword cMyItem contained Ni</B>
<B>   :  syn cluster cCommentGroup add=cMyItem</B>
<B>   :  hi link cMyItem Title</B>
<B>   :endfun</B>

ANSI constants will be highlighted with the &quot;cConstant&quot; group.	This includes
&quot;NULL&quot;, &quot;SIG_IGN&quot; and others.  But not &quot;TRUE&quot;, for example, because this is
not in the ANSI standard.  If you find this confusing, remove the cConstant
highlighting:
<B>	:hi link cConstant NONE</B>

If you see '<A HREF="motion.html#{">{</A>' and '<A HREF="motion.html#}">}</A>' highlighted <A HREF="motion.html#as">as</A> an error where they are OK, reset the
highlighting for cErrInParen and cErrInBracket.

If you want to use <A HREF="fold.html#folding">folding</A> in your C files, you can add these lines in a file
in the &quot;after&quot; directory in <A HREF="options.html#'runtimepath'">'runtimepath'</A>.  For <A HREF="os_unix.html#Unix">Unix</A> this would be
~/.vim/after/syntax/c.vim.
<B>    syn sync fromstart</B>
<B>    set foldmethod=syntax</B>


CH						*<A NAME="ch.vim"></A><B>ch.vim</B>* *<A NAME="ft-ch-syntax"></A><B>ft-ch-syntax</B>*

C/C++ interpreter.  Ch has similar <A HREF="#syntax">syntax</A> highlighting to C and builds upon
the C <A HREF="#syntax">syntax</A> file.  See |<A HREF="c.html">c.vim</A>| for all the settings that are available for C.

By setting a variable you can tell Vim to use Ch <A HREF="#syntax">syntax</A> for *.h files, instead
of C or C++:
<B>	:let ch_syntax_for_h = 1</B>



CHILL						*<A NAME="chill.vim"></A><B>chill.vim</B>* *<A NAME="ft-chill-syntax"></A><B>ft-chill-syntax</B>*

Chill <A HREF="#syntax">syntax</A> highlighting is similar to C.  See |<A HREF="c.html">c.vim</A>| for all the settings
that are available.  Additionally there is:

chill_space_errors	like c_space_errors
chill_comment_string	like c_comment_strings
chill_minlines		like c_minlines



CHANGELOG				*<A NAME="changelog.vim"></A><B>changelog.vim</B>* *<A NAME="ft-changelog-syntax"></A><B>ft-changelog-syntax</B>*

ChangeLog supports highlighting spaces at the start of a line.
If you <A HREF="diff.html#do">do</A> not like this, add following line to your <A HREF="starting.html#.vimrc">.vimrc</A>:
<B>	let g:changelog_spacing_errors = 0</B>
This works the next time you edit a changelog file.  You can also use
&quot;b:changelog_spacing_errors&quot; to set this per buffer (before loading the <A HREF="#syntax">syntax</A>
file).

You can change the highlighting used, e.g., to flag the spaces <A HREF="motion.html#as">as</A> an error:
<B>	:hi link ChangelogError Error</B>
Or to avoid the highlighting:
<B>	:hi link ChangelogError NONE</B>
This works immediately.



COBOL						*<A NAME="cobol.vim"></A><B>cobol.vim</B>* *<A NAME="ft-cobol-syntax"></A><B>ft-cobol-syntax</B>*

COBOL highlighting has different needs for legacy code than <A HREF="motion.html#it">it</A> does for fresh
<A HREF="develop.html#development">development</A>.  This is due to differences in what is being done (maintenance
versus <A HREF="develop.html#development">development</A>) and other factors.	To enable legacy code highlighting,
add this line to your <A HREF="starting.html#.vimrc">.vimrc</A>:
<B>	:let cobol_legacy_code = 1</B>
To disable <A HREF="motion.html#it">it</A> again, use this:
<B>	:unlet cobol_legacy_code</B>



COLD FUSION			*<A NAME="coldfusion.vim"></A><B>coldfusion.vim</B>* *<A NAME="ft-coldfusion-syntax"></A><B>ft-coldfusion-syntax</B>*

The ColdFusion has its own version of HTML comments.  To turn on ColdFusion
comment highlighting, add the following line to your <A HREF="starting.html#startup">startup</A> file:

<B>	:let html_wrong_comments = 1</B>

The ColdFusion <A HREF="#syntax">syntax</A> file is based on the HTML <A HREF="#syntax">syntax</A> file.



CPP						*<A NAME="cpp.vim"></A><B>cpp.vim</B>* *<A NAME="ft-cpp-syntax"></A><B>ft-cpp-syntax</B>*

Most of things are same <A HREF="motion.html#as">as</A> |<A HREF="#ft-c-syntax">ft-c-syntax</A>|.

<B><FONT COLOR="PURPLE">Variable		Highlight </FONT></B>
cpp_no_c11		don't highlight C++11 standard items



CSH						*<A NAME="csh.vim"></A><B>csh.vim</B>* *<A NAME="ft-csh-syntax"></A><B>ft-csh-syntax</B>*

This covers the shell named &quot;csh&quot;.  Note that on some systems tcsh is actually
used.

Detecting whether a file is csh or tcsh is notoriously hard.  Some systems
symlink /bin/csh to /bin/tcsh, making <A HREF="motion.html#it">it</A> almost impossible to distinguish
between csh and tcsh.  In <A HREF="change.html#case">case</A> VIM guesses wrong you can set the

&quot;filetype_csh&quot; variable.  For using csh:  *<A NAME="g:filetype_csh"></A><B>g:filetype_csh</B>*

<B>	:let g:filetype_csh = "csh"</B>

For using tcsh:

<B>	:let g:filetype_csh = "tcsh"</B>

Any <A HREF="usr_41.html#script">script</A> with a tcsh extension or a standard tcsh filename (.tcshrc,
tcsh.tcshrc, tcsh.login) will have <A HREF="filetype.html#filetype">filetype</A> tcsh.  All other tcsh/csh scripts
will be classified <A HREF="motion.html#as">as</A> tcsh, UNLESS the &quot;filetype_csh&quot; variable exists.  If the
&quot;filetype_csh&quot; variable exists, the <A HREF="filetype.html#filetype">filetype</A> will be set to the value of the
variable.



CYNLIB						*<A NAME="cynlib.vim"></A><B>cynlib.vim</B>* *<A NAME="ft-cynlib-syntax"></A><B>ft-cynlib-syntax</B>*

Cynlib files are C++ files that use the Cynlib class library to enable
hardware modelling and simulation using C++.  Typically Cynlib files have a .cc
or a .cpp extension, which makes <A HREF="motion.html#it">it</A> very difficult to distinguish them from a
normal C++ file.  Thus, to enable Cynlib highlighting for .cc files, add this
line to your <A HREF="starting.html#.vimrc">.vimrc</A> file:

<B>	:let cynlib_cyntax_for_cc=1</B>

Similarly for cpp files (this extension is only usually used in Windows)

<B>	:let cynlib_cyntax_for_cpp=1</B>

To disable these again, use this:

<B>	:unlet cynlib_cyntax_for_cc</B>
<B>	:unlet cynlib_cyntax_for_cpp</B>
 


CWEB						*<A NAME="cweb.vim"></A><B>cweb.vim</B>* *<A NAME="ft-cweb-syntax"></A><B>ft-cweb-syntax</B>*

Files matching &quot;*.w&quot; could be Progress or cweb.  If the automatic detection
doesn't work for you, or you don't edit Progress at all, use this in your
<A HREF="starting.html#startup">startup</A> <A HREF="starting.html#vimrc">vimrc</A>:
<B>   :let filetype_w = "cweb"</B>



DESKTOP					   *<A NAME="desktop.vim"></A><B>desktop.vim</B>* *<A NAME="ft-desktop-syntax"></A><B>ft-desktop-syntax</B>*

Primary goal of this <A HREF="#syntax">syntax</A> file is to highlight .desktop and .directory files
according to freedesktop.org standard:
	<A HREF="http://standards.freedesktop.org/desktop-entry-spec/latest/">http://standards.freedesktop.org/desktop-entry-spec/latest/</A>
But actually almost none implements this standard fully.  Thus <A HREF="motion.html#it">it</A> will
highlight all <A HREF="os_unix.html#Unix">Unix</A> ini files.  But you can force strict highlighting according
to standard by placing this in your <A HREF="starting.html#vimrc">vimrc</A> file:
<B>	:let enforce_freedesktop_standard = 1</B>



DIRCOLORS			       *<A NAME="dircolors.vim"></A><B>dircolors.vim</B>* *<A NAME="ft-dircolors-syntax"></A><B>ft-dircolors-syntax</B>*

The dircolors utility highlighting definition has one option.  It exists to
provide compatibility with the Slackware GNU/Linux distributions version of
the command.  It adds a few keywords that are generally ignored by most
versions.  On Slackware systems, however, the utility accepts the keywords and
uses them for processing.  To enable the Slackware keywords add the following
line to your <A HREF="starting.html#startup">startup</A> file:
<B>	let dircolors_is_slackware = 1</B>



DOCBOOK					*<A NAME="docbk.vim"></A><B>docbk.vim</B>* *<A NAME="ft-docbk-syntax"></A><B>ft-docbk-syntax</B>* *<A NAME="docbook"></A><B>docbook</B>*

DOCBOOK XML				*<A NAME="docbkxml.vim"></A><B>docbkxml.vim</B>* *<A NAME="ft-docbkxml-syntax"></A><B>ft-docbkxml-syntax</B>*

DOCBOOK SGML				*<A NAME="docbksgml.vim"></A><B>docbksgml.vim</B>* *<A NAME="ft-docbksgml-syntax"></A><B>ft-docbksgml-syntax</B>*

There are two types of DocBook files: SGML and XML.  To specify what type you
are using the &quot;b:docbk_type&quot; variable should be set.  Vim does this for you
automatically if <A HREF="motion.html#it">it</A> can recognize the type.  When Vim can't guess <A HREF="motion.html#it">it</A> the type
defaults to XML.
You can set the type manually:
<B>	:let docbk_type = "sgml"</B>
or:
<B>	:let docbk_type = "xml"</B>
You need to <A HREF="diff.html#do">do</A> this before loading the <A HREF="#syntax">syntax</A> file, which is complicated.
Simpler is setting the <A HREF="filetype.html#filetype">filetype</A> to &quot;docbkxml&quot; or &quot;docbksgml&quot;:
<B>	:set filetype=docbksgml</B>
or:
<B>	:set filetype=docbkxml</B>

You can specify the DocBook version:
<B>	:let docbk_ver = 3</B>
When not set 4 is used.



DOSBATCH				*<A NAME="dosbatch.vim"></A><B>dosbatch.vim</B>* *<A NAME="ft-dosbatch-syntax"></A><B>ft-dosbatch-syntax</B>*

There is one option with highlighting <A HREF="os_dos.html#DOS">DOS</A> batch files.	This covers new
extensions to the Command Interpreter introduced with Windows 2000 and
is controlled by the variable dosbatch_cmdextversion.  For Windows NT
this should have the value 1, and for Windows 2000 <A HREF="motion.html#it">it</A> should be 2.
<A HREF="visual.html#Select">Select</A> the version you want with the following line:

<B>   :let dosbatch_cmdextversion = 1</B>

If this variable is not defined <A HREF="motion.html#it">it</A> defaults to a value of 2 to support
Windows 2000.

A second option covers whether *.btm files should be detected <A HREF="motion.html#as">as</A> type
&quot;dosbatch&quot; (MS-DOS batch files) or type &quot;btm&quot; (4DOS batch files).  The latter
is used by default.  You may select the former with the following line:

<B>   :let g:dosbatch_syntax_for_btm = 1</B>

If this variable is undefined or zero, btm <A HREF="#syntax">syntax</A> is selected.



DOXYGEN						*<A NAME="doxygen.vim"></A><B>doxygen.vim</B>* *<A NAME="doxygen-syntax"></A><B>doxygen-syntax</B>*

Doxygen generates code documentation using a special documentation format
(similar to Javadoc).  This <A HREF="#syntax">syntax</A> <A HREF="usr_41.html#script">script</A> adds doxygen highlighting to <A HREF="change.html#c">c</A>, cpp,
idl and php files, and should also work with java.

There are a few of ways to turn on doxygen <A HREF="change.html#formatting">formatting</A>. It can be done
explicitly or in a <A HREF="options.html#modeline">modeline</A> by appending '.doxygen' to the <A HREF="#syntax">syntax</A> of the file.
Example:
<B>	:set syntax=c.doxygen</B>
or
<B>	// vim:syntax=c.doxygen</B>

It can also be done automatically for C, C++, C#, IDL and PHP files by setting
the global or buffer-local variable load_doxygen_syntax.  This is done by
adding the following to your <A HREF="starting.html#.vimrc">.vimrc</A>.
<B>	:let g:load_doxygen_syntax=1</B>

There are a couple of <A HREF="eval.html#variables">variables</A> that have an effect on <A HREF="#syntax">syntax</A> highlighting, and
are to <A HREF="diff.html#do">do</A> with non-standard highlighting <A HREF="options.html#options">options</A>.

<B><FONT COLOR="PURPLE">Variable			Default	Effect </FONT></B>
g:doxygen_enhanced_color
g:doxygen_enhanced_colour	0	Use non-standard highlighting for
					doxygen comments.

doxygen_my_rendering		0	Disable rendering of HTML <A HREF="#bold">bold</A>, <A HREF="#italic">italic</A>
					and html_my_rendering <A HREF="#underline">underline</A>.

doxygen_javadoc_autobrief	1	Set to 0 to disable javadoc autobrief
					colour highlighting.

doxygen_end_punctuation		'[.]'	Set to <A HREF="pattern.html#regexp">regexp</A> match for the ending
					punctuation of brief

There are also some hilight groups worth mentioning <A HREF="motion.html#as">as</A> they can be useful in
configuration.

<B><FONT COLOR="PURPLE">Highlight			Effect </FONT></B>
doxygenErrorComment		The colour of an end-comment when missing
				punctuation in a code, verbatim or dot section
doxygenLinkError		The colour of an end-comment when missing the
				\endlink from a \link section.



DTD						*<A NAME="dtd.vim"></A><B>dtd.vim</B>* *<A NAME="ft-dtd-syntax"></A><B>ft-dtd-syntax</B>*

The DTD <A HREF="#syntax">syntax</A> highlighting is <A HREF="change.html#case">case</A> sensitive by default.  To disable
case-sensitive highlighting, add the following line to your <A HREF="starting.html#startup">startup</A> file:

<B>	:let dtd_ignore_case=1</B>

The DTD <A HREF="#syntax">syntax</A> file will highlight unknown <A HREF="tagsrch.html#tags">tags</A> <A HREF="motion.html#as">as</A> <A HREF="message.html#errors">errors</A>.  If
this is annoying, <A HREF="motion.html#it">it</A> can be turned off by setting:

<B>	:let dtd_no_tag_errors=1</B>

before sourcing the <A HREF="#dtd.vim">dtd.vim</A> <A HREF="#syntax">syntax</A> file.
Parameter entity names are highlighted in the definition using the
'Type' highlighting group and 'Comment' for punctuation and '<A HREF="motion.html#&#37;">&#37;</A>'.
Parameter entity instances are highlighted using the 'Constant'
highlighting group and the 'Type' highlighting group for the
delimiters <A HREF="motion.html#&#37;">&#37;</A> and ;.  This can be turned off by setting:

<B>	:let dtd_no_param_entities=1</B>

The DTD <A HREF="#syntax">syntax</A> file is also included by <A HREF="#xml.vim">xml.vim</A> to highlight included dtd's.



EIFFEL					*<A NAME="eiffel.vim"></A><B>eiffel.vim</B>* *<A NAME="ft-eiffel-syntax"></A><B>ft-eiffel-syntax</B>*

While Eiffel is not case-sensitive, its style guidelines are, and the
<A HREF="#syntax">syntax</A> highlighting file encourages their use.  This also allows to
highlight class names differently.  If you want to disable case-sensitive
highlighting, add the following line to your <A HREF="starting.html#startup">startup</A> file:

<B>	:let eiffel_ignore_case=1</B>

Case still matters for class names and TODO marks in comments.

Conversely, for even stricter checks, add one of the following lines:

<B>	:let eiffel_strict=1</B>
<B>	:let eiffel_pedantic=1</B>

Setting eiffel_strict will only catch improper capitalization for the
five predefined words &quot;Current&quot;, &quot;Void&quot;, &quot;Result&quot;, &quot;Precursor&quot;, and
&quot;NONE&quot;, to warn against their accidental use <A HREF="motion.html#as">as</A> feature or class names.

Setting eiffel_pedantic will enforce adherence to the Eiffel style
guidelines fairly rigorously (like arbitrary mixes of upper- and
<A HREF="change.html#lowercase">lowercase</A> letters <A HREF="motion.html#as">as</A> well <A HREF="motion.html#as">as</A> outdated ways to capitalize keywords).

If you want to use the lower-case version of &quot;Current&quot;, &quot;Void&quot;,
&quot;Result&quot;, and &quot;Precursor&quot;, you can use

<B>	:let eiffel_lower_case_predef=1</B>

instead of completely turning case-sensitive highlighting off.

Support for ISE's proposed new creation <A HREF="#syntax">syntax</A> that is already
experimentally handled by some compilers can be enabled by:

<B>	:let eiffel_ise=1</B>

Finally, some vendors support hexadecimal constants.  To handle them, add

<B>	:let eiffel_hex_constants=1</B>

to your <A HREF="starting.html#startup">startup</A> file.



ERLANG						*<A NAME="erlang.vim"></A><B>erlang.vim</B>* *<A NAME="ft-erlang-syntax"></A><B>ft-erlang-syntax</B>*

Erlang is a functional programming language developed by Ericsson.  Files with
the following extensions are recognized <A HREF="motion.html#as">as</A> Erlang files: erl, hrl, yaws.

The BIFs (built-in <A HREF="eval.html#functions">functions</A>) are highlighted by default. To disable this,
put the following line in your <A HREF="starting.html#vimrc">vimrc</A>:

<B>      :let g:erlang_highlight_bifs = 0</B>

To enable highlighting some special atoms, put this in your <A HREF="starting.html#vimrc">vimrc</A>:

<B>      :let g:erlang_highlight_special_atoms = 1</B>



FLEXWIKI				*<A NAME="flexwiki.vim"></A><B>flexwiki.vim</B>* *<A NAME="ft-flexwiki-syntax"></A><B>ft-flexwiki-syntax</B>*

 FlexWiki is an ASP.NET-based wiki package available at	<A HREF="http://www.flexwiki.com">http://www.flexwiki.com</A>
NOTE: this site currently doesn't work, on Wikipedia is mentioned that
<A HREF="develop.html#development">development</A> stopped in 2009.

<A HREF="autocmd.html#Syntax">Syntax</A> highlighting is available for the most common elements of FlexWiki
<A HREF="#syntax">syntax</A>. The associated <A HREF="usr_41.html#ftplugin">ftplugin</A> <A HREF="usr_41.html#script">script</A> sets some buffer-local <A HREF="options.html#options">options</A> to make
editing FlexWiki pages more convenient. FlexWiki considers a newline <A HREF="motion.html#as">as</A> the
start of a new <A HREF="motion.html#paragraph">paragraph</A>, so the <A HREF="usr_41.html#ftplugin">ftplugin</A> sets 'tw'=0 (unlimited line length),
<A HREF="options.html#'wrap'">'wrap'</A> (wrap long lines instead of using horizontal scrolling), <A HREF="options.html#'linebreak'">'linebreak'</A>
(to wrap at a character in <A HREF="options.html#'breakat'">'breakat'</A> instead of at the last char on screen),
and so on. It also includes some keymaps that are disabled by default.

If you want to enable the keymaps that make &quot;<A HREF="motion.html#j">j</A>&quot; and &quot;<A HREF="motion.html#k">k</A>&quot; and the cursor keys
move up and down by display lines, add this to your <A HREF="starting.html#.vimrc">.vimrc</A>:
<B>	:let flexwiki_maps = 1</B>



FORM						*<A NAME="form.vim"></A><B>form.vim</B>* *<A NAME="ft-form-syntax"></A><B>ft-form-syntax</B>*

The <A HREF="#coloring">coloring</A> scheme for <A HREF="#syntax">syntax</A> elements in the FORM file uses the default
modes Conditional, <A HREF="eval.html#Number">Number</A>, Statement, Comment, PreProc, Type, and String,
following the language specifications in 'Symbolic Manipulation with FORM' by
J.A.M. Vermaseren, CAN, Netherlands, 1991.

If you want include your own changes to the default colors, you have to
redefine the following <A HREF="#syntax">syntax</A> groups:

    - formConditional
    - formNumber
    - formStatement
    - formHeaderStatement
    - formComment
    - formPreProc
    - formDirective
    - formType
    - formString

Note that the <A HREF="#form.vim">form.vim</A> <A HREF="#syntax">syntax</A> file implements FORM preprocessor commands and
directives per default in the same <A HREF="#syntax">syntax</A> group.

A predefined enhanced color mode for FORM is available to distinguish between
header statements and statements in the body of a FORM program.  To activate
this mode define the following variable in your <A HREF="starting.html#vimrc">vimrc</A> file

<B>	:let form_enhanced_color=1</B>

The enhanced mode also takes advantage of additional color features for a dark
<A HREF="starting.html#gvim">gvim</A> display.  Here, statements are colored LightYellow instead of Yellow, and
conditionals are LightBlue for better distinction.



FORTRAN					*<A NAME="fortran.vim"></A><B>fortran.vim</B>* *<A NAME="ft-fortran-syntax"></A><B>ft-fortran-syntax</B>*

<B><FONT COLOR="PURPLE">Default highlighting and dialect </FONT></B>
Highlighting appropriate for Fortran 2008 is used by default.  This choice
should be appropriate for most users most of the time because Fortran 2008 is
almost a superset of previous versions (Fortran 2003, 95, 90, and 77).

<B><FONT COLOR="PURPLE">Fortran source code form </FONT></B>
Fortran code can be in either fixed or free source form.  Note that the
<A HREF="#syntax">syntax</A> highlighting will not be correct if the form is incorrectly set.

When you create a new fortran file, the <A HREF="#syntax">syntax</A> <A HREF="usr_41.html#script">script</A> assumes fixed source
form.  If you always use free source form, then
<B>    :let fortran_free_source=1</B>
in your <A HREF="starting.html#.vimrc">.vimrc</A> prior to the <A HREF="#:syntax">:syntax</A> on command.  If you always use fixed source
form, then
<B>    :let fortran_fixed_source=1</B>
in your <A HREF="starting.html#.vimrc">.vimrc</A> prior to the <A HREF="#:syntax">:syntax</A> on command.

If the form of the source code depends upon the file extension, then <A HREF="motion.html#it">it</A> is
most convenient to set fortran_free_source in a <A HREF="usr_41.html#ftplugin">ftplugin</A> file.  For more
information on ftplugin files, see |<A HREF="usr_41.html#ftplugin">ftplugin</A>|.  For example, if all your
fortran files with an .f90 extension are written in free source form and the
rest in fixed source form, add the following code to your <A HREF="usr_41.html#ftplugin">ftplugin</A> file
<B>    let s:extfname = expand("%:e")</B>
<B>    if s:extfname ==? "f90"</B>
<B>	let fortran_free_source=1</B>
<B>	unlet! fortran_fixed_source</B>
<B>    else</B>
<B>	let fortran_fixed_source=1</B>
<B>	unlet! fortran_free_source</B>
<B>    endif</B>
Note that this will work only if the &quot;<A HREF="filetype.html#filetype">filetype</A> <A HREF="usr_05.html#plugin">plugin</A> indent on&quot; command
precedes the &quot;<A HREF="#syntax">syntax</A> on&quot; command in your <A HREF="starting.html#.vimrc">.vimrc</A> file.

When you edit an existing fortran file, the <A HREF="#syntax">syntax</A> <A HREF="usr_41.html#script">script</A> will assume free
source form if the fortran_free_source variable has been set, and assumes
fixed source form if the fortran_fixed_source variable has been set.  If
neither of these <A HREF="eval.html#variables">variables</A> have been set, the <A HREF="#syntax">syntax</A> <A HREF="usr_41.html#script">script</A> attempts to
determine which source form has been used by examining the first five columns
of the first 250 lines of your file.  If no <A HREF="sign.html#signs">signs</A> of free source form are
detected, then the file is assumed to be in fixed source form.  The algorithm
should work in the vast majority of cases.  In some cases, such <A HREF="motion.html#as">as</A> a file that
begins with 250 or more full-line comments, the <A HREF="usr_41.html#script">script</A> may incorrectly decide
that the fortran code is in fixed form.  If that happens, just add a
non-comment statement beginning anywhere in the first five columns of the
first twenty five lines, save (:w) and then <A HREF="editing.html#reload">reload</A> (:e!) the file.

<B><FONT COLOR="PURPLE">Tabs in fortran files </FONT></B>
Tabs are not recognized by the Fortran standards.  Tabs are not a good idea in
fixed format fortran source code which requires fixed column boundaries.
Therefore, tabs are marked <A HREF="motion.html#as">as</A> <A HREF="message.html#errors">errors</A>.  Nevertheless, some programmers like
using tabs.  If your fortran files contain tabs, then you should set the
variable fortran_have_tabs in your <A HREF="starting.html#.vimrc">.vimrc</A> with a command such <A HREF="motion.html#as">as</A>
<B>    :let fortran_have_tabs=1</B>
placed prior to the <A HREF="#:syntax">:syntax</A> on command.  Unfortunately, the use of tabs will
mean that the <A HREF="#syntax">syntax</A> file will not be able to detect incorrect margins.

<B><FONT COLOR="PURPLE">Syntax folding of fortran files </FONT></B>
If you wish to use foldmethod=syntax, then you must first set the variable
fortran_fold with a command such <A HREF="motion.html#as">as</A>
<B>    :let fortran_fold=1</B>
to instruct the <A HREF="#syntax">syntax</A> <A HREF="usr_41.html#script">script</A> to define fold regions for program units, that
is main programs starting with a program statement, subroutines, function
subprograms, block data subprograms, interface blocks, and modules.  If you
also set the variable fortran_fold_conditionals with a command such <A HREF="motion.html#as">as</A>
<B>    :let fortran_fold_conditionals=1</B>
then fold regions will also be defined for <A HREF="diff.html#do">do</A> loops, if blocks, and select
<A HREF="change.html#case">case</A> constructs.  If you also set the variable
fortran_fold_multilinecomments with a command such <A HREF="motion.html#as">as</A>
<B>    :let fortran_fold_multilinecomments=1</B>
then fold regions will also be defined for three or more consecutive comment
lines.  Note that defining fold regions can be slow for large files.

If fortran_fold, and possibly fortran_fold_conditionals and/or
fortran_fold_multilinecomments, have been set, then vim will fold your file if
you set foldmethod=syntax.  Comments or blank lines placed between two program
units are not folded because they are seen <A HREF="motion.html#as">as</A> not belonging to any program
unit.

<B><FONT COLOR="PURPLE">More precise fortran syntax </FONT></B>
If you set the variable fortran_more_precise with a command such <A HREF="motion.html#as">as</A>
<B>    :let fortran_more_precise=1</B>
then the <A HREF="#syntax">syntax</A> <A HREF="#coloring">coloring</A> will be more precise but slower.  In particular,
statement labels used in <A HREF="diff.html#do">do</A>, goto and arithmetic if statements will be
recognized, <A HREF="motion.html#as">as</A> will construct names at the end of a <A HREF="diff.html#do">do</A>, if, select or forall
construct.

<B><FONT COLOR="PURPLE">Non-default fortran dialects </FONT></B>
The <A HREF="#syntax">syntax</A> <A HREF="usr_41.html#script">script</A> supports two Fortran dialects: f08 and <A HREF="motion.html#F">F</A>. You will probably
find the default highlighting (f08) satisfactory.  A few legacy constructs
deleted or declared obsolescent in the 2008 standard are highlighted <A HREF="motion.html#as">as</A> <A HREF="todo.html#todo">todo</A>
items.

If you use <A HREF="motion.html#F">F</A>, the advantage of setting the dialect appropriately is that
other legacy features excluded from <A HREF="motion.html#F">F</A> will be highlighted <A HREF="motion.html#as">as</A> <A HREF="todo.html#todo">todo</A> items and
that free source form will be assumed.

The dialect can be selected in various ways.  If all your fortran files use
the same dialect, set the global variable fortran_dialect in your <A HREF="starting.html#.vimrc">.vimrc</A> prior
to your <A HREF="#syntax">syntax</A> on statement.  The case-sensitive, permissible values of
fortran_dialect are &quot;f08&quot; or &quot;<A HREF="motion.html#F">F</A>&quot;.  Invalid values of fortran_dialect are
ignored.

If the dialect depends upon the file extension, then <A HREF="motion.html#it">it</A> is most convenient to
set a buffer-local variable in a <A HREF="usr_41.html#ftplugin">ftplugin</A> file.  For more information on
ftplugin files, see |<A HREF="usr_41.html#ftplugin">ftplugin</A>|.  For example, if all your fortran files with
an .f90 extension are written in the <A HREF="motion.html#F">F</A> subset, your <A HREF="usr_41.html#ftplugin">ftplugin</A> file should
contain the code
<B>    let s:extfname = expand("%:e")</B>
<B>    if s:extfname ==? "f90"</B>
<B>	let b:fortran_dialect="F"</B>
<B>    else</B>
<B>	unlet! b:fortran_dialect</B>
<B>    endif</B>
Note that this will work only if the &quot;<A HREF="filetype.html#filetype">filetype</A> <A HREF="usr_05.html#plugin">plugin</A> indent on&quot; command
precedes the &quot;<A HREF="#syntax">syntax</A> on&quot; command in your <A HREF="starting.html#.vimrc">.vimrc</A> file.

Finer <A HREF="intro.html#control">control</A> is necessary if the file extension does not uniquely identify
the dialect.  You can override the default dialect, on a file-by-file basis,
by including a comment with the directive &quot;fortran_dialect=xx&quot; (where xx=F or
f08) in one of the first three lines in your file.  For example, your older .f
files may be legacy code but your newer ones may be <A HREF="motion.html#F">F</A> codes, and you would
identify the latter by including in the first three lines of those files a
Fortran comment of the form
<B>  ! fortran_dialect=F</B>

For previous versions of the <A HREF="#syntax">syntax</A>, you may have set fortran_dialect to the
now-obsolete values &quot;f77&quot;, &quot;f90&quot;, &quot;f95&quot;, or &quot;elf&quot;. Such settings will be
silently handled <A HREF="motion.html#as">as</A> &quot;f08&quot;. Users of &quot;elf&quot; may wish to experiment with &quot;<A HREF="motion.html#F">F</A>&quot;
instead.

The syntax/fortran.vim <A HREF="usr_41.html#script">script</A> contains embedded comments that tell you how to
comment and/or uncomment some lines to (a) activate recognition of some
non-standard, vendor-supplied intrinsics and (b) to prevent features deleted
or declared obsolescent in the 2008 standard from being highlighted <A HREF="motion.html#as">as</A> <A HREF="todo.html#todo">todo</A>
items.

<B><FONT COLOR="PURPLE">Limitations </FONT></B>
Parenthesis checking does not catch too few closing parentheses.  Hollerith
strings are not recognized.  Some keywords may be highlighted incorrectly
because Fortran90 has no reserved words.

For further information related to fortran, see |<A HREF="indent.html#ft-fortran-indent">ft-fortran-indent</A>| and
|<A HREF="filetype.html#ft-fortran-plugin">ft-fortran-plugin</A>|.



FVWM CONFIGURATION FILES			*<A NAME="fvwm.vim"></A><B>fvwm.vim</B>* *<A NAME="ft-fvwm-syntax"></A><B>ft-fvwm-syntax</B>*

In order for Vim to recognize Fvwm configuration files that <A HREF="diff.html#do">do</A> not match

the patterns *<A NAME="fvwmrc"></A><B>fvwmrc</B>* or *<A NAME="fvwm2rc"></A><B>fvwm2rc</B>* , you must put additional patterns
appropriate to your system in your myfiletypes.vim file.  For these
patterns, you must set the variable &quot;b:fvwm_version&quot; to the major version
number of Fvwm, and the <A HREF="options.html#'filetype'">'filetype'</A> option to fvwm.

For example, to make Vim identify all files in /etc/X11/fvwm2/
<A HREF="motion.html#as">as</A> Fvwm2 configuration files, add the following:

<B>  :au! BufNewFile,BufRead /etc/X11/fvwm2/*  let b:fvwm_version = 2 |</B>
<B>					 \ set filetype=fvwm</B>

If you'd like Vim to highlight all valid color names, tell <A HREF="motion.html#it">it</A> where to
find the color database (rgb.txt) on your system.  Do this by setting
&quot;rgb_file&quot; to its location.  Assuming your color database is located
in /usr/X11/lib/X11/, you should add the line

<B>	:let rgb_file = "/usr/X11/lib/X11/rgb.txt"</B>

to your <A HREF="starting.html#.vimrc">.vimrc</A> file.



GSP						*<A NAME="gsp.vim"></A><B>gsp.vim</B>* *<A NAME="ft-gsp-syntax"></A><B>ft-gsp-syntax</B>*

The default <A HREF="#coloring">coloring</A> style for GSP pages is defined by |<A HREF="html.html">html.vim</A>|, and
the <A HREF="#coloring">coloring</A> for java code (within java <A HREF="tagsrch.html#tags">tags</A> or inline between backticks)
is defined by |<A HREF="java.html">java.vim</A>|.  The following HTML groups defined in |<A HREF="html.html">html.vim</A>|
are redefined to incorporate and highlight inline java code:

    htmlString
    htmlValue
    htmlEndTag
    htmlTag
    htmlTagN

Highlighting should look fine most of the places where you'd see inline
java code, but in some special cases <A HREF="motion.html#it">it</A> may not.  To add another HTML
group where you will have inline java code where <A HREF="motion.html#it">it</A> does not highlight
correctly, just copy the line you want from |<A HREF="html.html">html.vim</A>| and add gspJava
to the contains clause.

The backticks for inline java are highlighted according to the htmlError
group to make them easier to see.



GROFF						*<A NAME="groff.vim"></A><B>groff.vim</B>* *<A NAME="ft-groff-syntax"></A><B>ft-groff-syntax</B>*

The groff <A HREF="#syntax">syntax</A> file is a wrapper for |<A HREF="nroff.html">nroff.vim</A>|, see the notes
under that heading for examples of use and configuration.  The purpose
of this wrapper is to set up groff <A HREF="#syntax">syntax</A> extensions by setting the
<A HREF="filetype.html#filetype">filetype</A> from a |<A HREF="options.html#modeline">modeline</A>| or in a personal <A HREF="filetype.html#filetype">filetype</A> <A HREF="intro.html#definitions">definitions</A> file
(see |<A HREF="filetype.html">filetype.txt</A>|).



HASKELL			     *<A NAME="haskell.vim"></A><B>haskell.vim</B>* *<A NAME="lhaskell.vim"></A><B>lhaskell.vim</B>* *<A NAME="ft-haskell-syntax"></A><B>ft-haskell-syntax</B>*

The Haskell <A HREF="#syntax">syntax</A> files support plain Haskell code <A HREF="motion.html#as">as</A> well <A HREF="motion.html#as">as</A> literate
Haskell code, the latter in both Bird style and TeX style.  The Haskell
<A HREF="#syntax">syntax</A> highlighting will also highlight C preprocessor directives.

If you want to highlight delimiter characters (useful if you have a
light-coloured background), add to your <A HREF="starting.html#.vimrc">.vimrc</A>:
<B>	:let hs_highlight_delimiters = 1</B>
To treat True and False <A HREF="motion.html#as">as</A> keywords <A HREF="motion.html#as">as</A> opposed to ordinary identifiers,
add:
<B>	:let hs_highlight_boolean = 1</B>
To also treat the names of primitive types <A HREF="motion.html#as">as</A> keywords:
<B>	:let hs_highlight_types = 1</B>
And to treat the names of even more relatively common types <A HREF="motion.html#as">as</A> keywords:
<B>	:let hs_highlight_more_types = 1</B>
If you want to highlight the names of debugging <A HREF="eval.html#functions">functions</A>, put in
your <A HREF="starting.html#.vimrc">.vimrc</A>:
<B>	:let hs_highlight_debug = 1</B>

The Haskell <A HREF="#syntax">syntax</A> highlighting also highlights C preprocessor
directives, and flags lines that start with # but are not valid
directives <A HREF="motion.html#as">as</A> erroneous.  This interferes with Haskell's <A HREF="#syntax">syntax</A> for
operators, <A HREF="motion.html#as">as</A> they may start with #.  If you want to highlight those
<A HREF="motion.html#as">as</A> operators <A HREF="motion.html#as">as</A> opposed to <A HREF="message.html#errors">errors</A>, put in your <A HREF="starting.html#.vimrc">.vimrc</A>:
<B>	:let hs_allow_hash_operator = 1</B>

The <A HREF="#syntax">syntax</A> highlighting for literate Haskell code will try to
automatically guess whether your literate Haskell code contains
TeX markup or not, and correspondingly highlight TeX constructs
or nothing at all.  You can override this globally by putting
in your <A HREF="starting.html#.vimrc">.vimrc</A>
<B>	:let lhs_markup = none</B>
for no highlighting at all, or
<B>	:let lhs_markup = tex</B>
to force the highlighting to always try to highlight TeX markup.
For more flexibility, you may also use buffer local versions of
this variable, so e.g.
<B>	:let b:lhs_markup = tex</B>
will force TeX highlighting for a particular buffer.  It has to be
set before turning <A HREF="#syntax">syntax</A> highlighting on for the buffer or
loading a file.



HTML						*<A NAME="html.vim"></A><B>html.vim</B>* *<A NAME="ft-html-syntax"></A><B>ft-html-syntax</B>*

The <A HREF="#coloring">coloring</A> scheme for <A HREF="tagsrch.html#tags">tags</A> in the HTML file works <A HREF="motion.html#as">as</A> follows.

The  <A HREF="intro.html#&lt;&gt;">&lt;&gt;</A> of opening <A HREF="tagsrch.html#tags">tags</A> are colored differently than the &lt;/&gt; of a closing <A HREF="tagsrch.html#tag">tag</A>.
This is on purpose! For opening <A HREF="tagsrch.html#tags">tags</A> the 'Function' color is used, while for
closing <A HREF="tagsrch.html#tags">tags</A> the 'Type' color is used (See syntax.vim to check how those are
defined for you)

Known <A HREF="tagsrch.html#tag">tag</A> names are colored the same way <A HREF="motion.html#as">as</A> statements in C.  Unknown <A HREF="tagsrch.html#tag">tag</A>
names are colored with the same color <A HREF="motion.html#as">as</A> the <A HREF="intro.html#&lt;&gt;">&lt;&gt;</A> or &lt;/&gt; respectively which
makes <A HREF="motion.html#it">it</A> <A HREF="starting.html#easy">easy</A> to spot <A HREF="message.html#errors">errors</A>

Note that the same is true for argument (or attribute) names.  Known attribute
names are colored differently than unknown ones.

Some HTML <A HREF="tagsrch.html#tags">tags</A> are used to change the rendering of text.  The following <A HREF="tagsrch.html#tags">tags</A>
are recognized by the <A HREF="#html.vim">html.vim</A> <A HREF="#syntax">syntax</A> <A HREF="#coloring">coloring</A> file and change the way normal
text is shown: &lt;B&gt; &lt;I&gt; &lt;U&gt; &lt;EM&gt; &lt;STRONG&gt; (&lt;EM&gt; is used <A HREF="motion.html#as">as</A> an alias for &lt;I&gt;,
while &lt;STRONG&gt; <A HREF="motion.html#as">as</A> an alias for &lt;B&gt;), &lt;H1&gt; - &lt;H6&gt;, &lt;HEAD&gt;, &lt;TITLE&gt; and &lt;A&gt;, but
only if used <A HREF="motion.html#as">as</A> a link (that is, <A HREF="motion.html#it">it</A> must include a href <A HREF="motion.html#as">as</A> in
&lt;A href=&quot;somefile.html&quot;&gt;).

If you want to change how such text is rendered, you must redefine the
following <A HREF="#syntax">syntax</A> groups:

    - htmlBold
    - htmlBoldUnderline
    - htmlBoldUnderlineItalic
    - htmlUnderline
    - htmlUnderlineItalic
    - htmlItalic
    - htmlTitle for titles
    - htmlH1 - htmlH6 for headings

To make this redefinition work you must redefine them all with the exception
of the last two (htmlTitle and htmlH[1-6], which are optional) and define the
following variable in your <A HREF="starting.html#vimrc">vimrc</A> (this is due to the order in which the files
are read during <A HREF="starting.html#initialization">initialization</A>)
<B>	:let html_my_rendering=1</B>

If you'd like to see an example <A HREF="intro.html#download">download</A> mysyntax.vim at
	<A HREF="http://www.fleiner.com/vim/download.html">http://www.fleiner.com/vim/download.html</A>

You can also disable this rendering by adding the following line to your
<A HREF="starting.html#vimrc">vimrc</A> file:
<B>	:let html_no_rendering=1</B>

HTML comments are rather special (see an HTML reference document for the
details), and the <A HREF="#syntax">syntax</A> <A HREF="#coloring">coloring</A> scheme will highlight all <A HREF="message.html#errors">errors</A>.
However, if you prefer to use the wrong style (starts with &lt;!-- and
ends with --!&gt;) you can define
<B>	:let html_wrong_comments=1</B>

JavaScript and <A HREF="visual.html#Visual">Visual</A> Basic embedded inside HTML documents are highlighted <A HREF="motion.html#as">as</A>
'Special' with statements, comments, strings and so on colored <A HREF="motion.html#as">as</A> in standard
programming languages.  Note that only JavaScript and <A HREF="visual.html#Visual">Visual</A> Basic are currently
supported, no other scripting language has been added yet.

Embedded and inlined cascading style sheets (CSS) are highlighted too.

There are several html preprocessor languages out there.  <A HREF="#html.vim">html.vim</A> has been
written such that <A HREF="motion.html#it">it</A> should be trivial to include <A HREF="motion.html#it">it</A>.  To <A HREF="diff.html#do">do</A> so add the
following two lines to the <A HREF="#syntax">syntax</A> <A HREF="#coloring">coloring</A> file for that language
(the example comes from the asp.vim file):

    runtime! syntax/html.vim
    syn cluster htmlPreproc add=asp

Now you just need to make sure that you add all regions that contain
the preprocessor language to the cluster htmlPreproc.



HTML/OS (by Aestiva)				*<A NAME="htmlos.vim"></A><B>htmlos.vim</B>* *<A NAME="ft-htmlos-syntax"></A><B>ft-htmlos-syntax</B>*

The <A HREF="#coloring">coloring</A> scheme for HTML/OS works <A HREF="motion.html#as">as</A> follows:

Functions and variable names are the same color by default, because VIM
doesn't specify different colors for Functions and Identifiers.  To change
this (which is recommended if you want function names to be recognizable in a
different color) you need to add the following line to either your ~/.vimrc:
<B>  :hi Function term=underline cterm=bold ctermfg=LightGray</B>

Of course, the ctermfg can be a different color if you choose.

Another issues that HTML/OS runs into is that there is no special <A HREF="filetype.html#filetype">filetype</A> to
signify that <A HREF="motion.html#it">it</A> is a file with HTML/OS coding.	You can change this by opening
a file and turning on HTML/OS <A HREF="#syntax">syntax</A> by doing the following:
<B>  :set syntax=htmlos</B>

Lastly, <A HREF="motion.html#it">it</A> should be noted that the opening and closing characters to begin a
block of HTML/OS code can either be <A HREF="change.html#&lt;&lt;">&lt;&lt;</A> or <A HREF="motion.html#[[">[[</A> and <A HREF="change.html#&gt;&gt;">&gt;&gt;</A> or <A HREF="motion.html#]]">]]</A>, respectively.



IA64				*<A NAME="ia64.vim"></A><B>ia64.vim</B>* *<A NAME="intel-itanium"></A><B>intel-itanium</B>* *<A NAME="ft-ia64-syntax"></A><B>ft-ia64-syntax</B>*

Highlighting for the Intel Itanium 64 assembly language.  See |<A HREF="asm.html">asm.vim</A>| for
how to recognize this <A HREF="filetype.html#filetype">filetype</A>.

To have *.inc files be recognized <A HREF="motion.html#as">as</A> IA64, add this to your <A HREF="starting.html#.vimrc">.vimrc</A> file:
<B>	:let g:filetype_inc = "ia64"</B>



INFORM						*<A NAME="inform.vim"></A><B>inform.vim</B>* *<A NAME="ft-inform-syntax"></A><B>ft-inform-syntax</B>*

Inform highlighting includes symbols provided by the Inform Library, <A HREF="motion.html#as">as</A>
most programs make extensive use of <A HREF="motion.html#it">it</A>.  If <A HREF="diff.html#do">do</A> not wish Library symbols
to be highlighted add this to your vim <A HREF="starting.html#startup">startup</A>:
<B>	:let inform_highlight_simple=1</B>

By default <A HREF="motion.html#it">it</A> is assumed that Inform programs are Z-machine targeted,
and highlights Z-machine assembly language symbols appropriately.  If
you intend your program to be targeted to a Glulx/Glk environment you
need to add this to your <A HREF="starting.html#startup">startup</A> sequence:
<B>	:let inform_highlight_glulx=1</B>

This will highlight Glulx opcodes instead, and also adds glk() to the
set of highlighted system <A HREF="eval.html#functions">functions</A>.

The Inform compiler will flag certain obsolete keywords <A HREF="motion.html#as">as</A> <A HREF="message.html#errors">errors</A> when
<A HREF="motion.html#it">it</A> encounters them.  These keywords are normally highlighted <A HREF="motion.html#as">as</A> <A HREF="message.html#errors">errors</A>
by Vim.  To prevent such error highlighting, you must add this to your
<A HREF="starting.html#startup">startup</A> sequence:
<B>	:let inform_suppress_obsolete=1</B>

By default, the language features highlighted conform to Compiler
version 6.30 and Library version 6.11.  If you are using an older
Inform <A HREF="develop.html#development">development</A> environment, you may with to add this to your
<A HREF="starting.html#startup">startup</A> sequence:
<B>	:let inform_highlight_old=1</B>


IDL							*<A NAME="idl.vim"></A><B>idl.vim</B>* *<A NAME="idl-syntax"></A><B>idl-syntax</B>*

IDL (Interface Definition Language) files are used to define RPC calls.  In
Microsoft land, this is also used for defining COM interfaces and calls.

IDL's structure is simple enough to permit a full grammar based approach to
rather than using a few heuristics.  The result is large and somewhat
repetitive but seems to work.

There are some Microsoft extensions to idl files that are here.  Some of them
are disabled by defining idl_no_ms_extensions.

The more complex of the extensions are disabled by defining idl_no_extensions.

<B><FONT COLOR="PURPLE">Variable			Effect </FONT></B>

idl_no_ms_extensions		Disable some of the Microsoft specific
				extensions
idl_no_extensions		Disable complex extensions
idlsyntax_showerror		Show IDL <A HREF="message.html#errors">errors</A> (can be rather intrusive, but
				quite helpful)
idlsyntax_showerror_soft	Use softer colours by default for <A HREF="message.html#errors">errors</A>



JAVA						*<A NAME="java.vim"></A><B>java.vim</B>* *<A NAME="ft-java-syntax"></A><B>ft-java-syntax</B>*

The <A HREF="#java.vim">java.vim</A> <A HREF="#syntax">syntax</A> highlighting file offers several <A HREF="options.html#options">options</A>:

In Java 1.0.2 <A HREF="motion.html#it">it</A> was never possible to have braces inside parens, so this was
flagged <A HREF="motion.html#as">as</A> an error.  Since Java 1.1 this is possible (with anonymous
classes), and therefore is no longer marked <A HREF="motion.html#as">as</A> an error.  If you prefer the old
way, put the following line into your vim <A HREF="starting.html#startup">startup</A> file:
<B>	:let java_mark_braces_in_parens_as_errors=1</B>

All identifiers in java.lang.* are always visible in all classes.  To
highlight them use:
<B>	:let java_highlight_java_lang_ids=1</B>

You can also highlight identifiers of most standard Java packages if you
 download the javaid.vim script at	<A HREF="http://www.fleiner.com/vim/download.html">http://www.fleiner.com/vim/download.html</A>.
If you prefer to only highlight identifiers of a certain package, say java.io
use the following:
<B>	:let java_highlight_java_io=1</B>
Check the javaid.vim file for a list of all the packages that are supported.

Function names are not highlighted, <A HREF="motion.html#as">as</A> the way to find <A HREF="eval.html#functions">functions</A> depends on
how you write Java code.  The <A HREF="#syntax">syntax</A> file knows two possible ways to highlight
<A HREF="eval.html#functions">functions</A>:

If you write function declarations that are always indented by either
a <A HREF="intro.html#tab">tab</A>, 8 spaces or 2 spaces you may want to set
<B>	:let java_highlight_functions="indent"</B>
However, if you follow the Java guidelines about how <A HREF="eval.html#functions">functions</A> and classes are
supposed to be named (with respect to upper and lowercase), use
<B>	:let java_highlight_functions="style"</B>
If both <A HREF="options.html#options">options</A> <A HREF="diff.html#do">do</A> not work for you, but you would still want function
declarations to be highlighted create your own <A HREF="intro.html#definitions">definitions</A> by <A HREF="change.html#changing">changing</A> the
<A HREF="intro.html#definitions">definitions</A> in <A HREF="#java.vim">java.vim</A> or by creating your own <A HREF="#java.vim">java.vim</A> which includes the
original one and then adds the code to highlight <A HREF="eval.html#functions">functions</A>.

In Java 1.1 the <A HREF="eval.html#functions">functions</A> System.out.println() and System.err.println() should
only be used for debugging.  Therefore <A HREF="motion.html#it">it</A> is possible to highlight debugging
statements differently.  To <A HREF="diff.html#do">do</A> this you must add the following definition in
your <A HREF="starting.html#startup">startup</A> file:
<B>	:let java_highlight_debug=1</B>
The result will be that those statements are highlighted <A HREF="motion.html#as">as</A> 'Special'
characters.  If you prefer to have them highlighted differently you must define
new highlightings for the following groups.:
    Debug, DebugSpecial, DebugString, DebugBoolean, DebugType
which are used for the statement itself, special characters used in debug
strings, strings, <A HREF="options.html#boolean">boolean</A> constants and types (this, super) respectively.  I
have opted to chose another background for those statements.

Javadoc is a program that takes special comments out of Java program files and
creates HTML pages.  The standard configuration will highlight this HTML code
similarly to HTML files (see |<A HREF="html.html">html.vim</A>|).  You can even add Javascript
and CSS inside this code (see below).  There are four differences however:
  1. The title (all characters up to the first '<A HREF="repeat.html#.">.</A>' which is followed by
     some white space or up to the first '<A HREF="repeat.html#@">@</A>') is colored differently (to change
     the color change the group CommentTitle).
  2. The text is colored <A HREF="motion.html#as">as</A> 'Comment'.
  3. HTML comments are colored <A HREF="motion.html#as">as</A> 'Special'
  4. The special Javadoc <A HREF="tagsrch.html#tags">tags</A> (@see, @param, <A HREF="eval.html#...">...</A>) are highlighted <A HREF="motion.html#as">as</A> specials
     and the argument (for @see, @param, @exception) <A HREF="motion.html#as">as</A> Function.
To turn this feature off add the following line to your <A HREF="starting.html#startup">startup</A> file:
<B>	:let java_ignore_javadoc=1</B>

If you use the special Javadoc comment highlighting described above you
can also turn on special highlighting for Javascript, visual basic
scripts and embedded CSS (stylesheets).  This makes only sense if you
actually have Javadoc comments that include either Javascript or embedded
CSS.  The <A HREF="options.html#options">options</A> to use are
<B>	:let java_javascript=1</B>
<B>	:let java_css=1</B>
<B>	:let java_vb=1</B>

In order to highlight nested parens with different colors define colors
for javaParen, javaParen1 and javaParen2, for example with
<B>	:hi link javaParen Comment</B>
or
<B>	:hi javaParen ctermfg=blue guifg=#0000ff</B>

If you notice highlighting <A HREF="message.html#errors">errors</A> while <A HREF="scroll.html#scrolling">scrolling</A> backwards, which are fixed
when redrawing with <A HREF="various.html#CTRL-L">CTRL-L</A>, try setting the &quot;java_minlines&quot; internal variable
to a larger number:
<B>	:let java_minlines = 50</B>
This will make the <A HREF="#syntax">syntax</A> synchronization start 50 lines before the first
displayed line.  The default value is 10.  The disadvantage of using a larger
number is that redrawing can become slow.



LACE						*<A NAME="lace.vim"></A><B>lace.vim</B>* *<A NAME="ft-lace-syntax"></A><B>ft-lace-syntax</B>*

Lace (Language for Assembly of Classes in Eiffel) is <A HREF="change.html#case">case</A> insensitive, but the
style guide lines are not.  If you prefer <A HREF="change.html#case">case</A> insensitive highlighting, just
define the vim variable 'lace_case_insensitive' in your <A HREF="starting.html#startup">startup</A> file:
<B>	:let lace_case_insensitive=1</B>



LEX						*<A NAME="lex.vim"></A><B>lex.vim</B>* *<A NAME="ft-lex-syntax"></A><B>ft-lex-syntax</B>*

Lex uses brute-force synchronizing <A HREF="motion.html#as">as</A> the &quot;^&#37;&#37;$&quot; section delimiter
gives no clue <A HREF="motion.html#as">as</A> to what section follows.  Consequently, the value for
<B>	:syn sync minlines=300</B>
may be changed by the user if s/he is experiencing synchronization
difficulties (such <A HREF="motion.html#as">as</A> may happen with large lex files).



LIFELINES				*<A NAME="lifelines.vim"></A><B>lifelines.vim</B>* *<A NAME="ft-lifelines-syntax"></A><B>ft-lifelines-syntax</B>*

To highlight deprecated <A HREF="eval.html#functions">functions</A> <A HREF="motion.html#as">as</A> <A HREF="message.html#errors">errors</A>, add in your <A HREF="starting.html#.vimrc">.vimrc</A>:

<B>	:let g:lifelines_deprecated = 1</B>
 


LISP						*<A NAME="lisp.vim"></A><B>lisp.vim</B>* *<A NAME="ft-lisp-syntax"></A><B>ft-lisp-syntax</B>*

The lisp <A HREF="#syntax">syntax</A> highlighting provides two <A HREF="options.html#options">options</A>:

<B>	g:lisp_instring : if it exists, then "(...)" strings are highlighted</B>
<B>			  as if the contents of the string were lisp.</B>
<B>			  Useful for AutoLisp.</B>
<B>	g:lisp_rainbow  : if it exists and is nonzero, then differing levels</B>
<B>			  of parenthesization will receive different</B>
<B>			  highlighting.</B>
 
The g:lisp_rainbow option provides 10 levels of individual colorization for
the parentheses and backquoted parentheses.  Because of the quantity of
colorization levels, unlike non-rainbow highlighting, the rainbow mode
specifies its highlighting using ctermfg and guifg, thereby bypassing the
usual colorscheme <A HREF="intro.html#control">control</A> using standard highlighting groups.  The actual
highlighting used depends on the dark/bright setting  (see |<A HREF="options.html#'bg'">'bg'</A>|).



LITE						*<A NAME="lite.vim"></A><B>lite.vim</B>* *<A NAME="ft-lite-syntax"></A><B>ft-lite-syntax</B>*

There are two <A HREF="options.html#options">options</A> for the lite <A HREF="#syntax">syntax</A> highlighting.

If you like SQL <A HREF="#syntax">syntax</A> highlighting inside Strings, use this:

<B>	:let lite_sql_query = 1</B>

For syncing, minlines defaults to 100.	If you prefer another value, you can
set &quot;lite_minlines&quot; to the value you desire.  Example:

<B>	:let lite_minlines = 200</B>



LPC						*<A NAME="lpc.vim"></A><B>lpc.vim</B>* *<A NAME="ft-lpc-syntax"></A><B>ft-lpc-syntax</B>*

LPC stands for a simple, memory-efficient language: Lars Pensj| C.  The
file name of LPC is usually *.c.  Recognizing these files <A HREF="motion.html#as">as</A> LPC would bother
users <A HREF="editing.html#writing">writing</A> only C programs.	If you want to use LPC <A HREF="#syntax">syntax</A> in Vim, you
should set a variable in your <A HREF="starting.html#.vimrc">.vimrc</A> file:

<B>	:let lpc_syntax_for_c = 1</B>

If <A HREF="motion.html#it">it</A> doesn't work properly for some particular C or LPC files, use a
<A HREF="options.html#modeline">modeline</A>.  For a LPC file:

	<A HREF="version7.html#//">//</A> vim:set ft=lpc:

For a C file that is recognized <A HREF="motion.html#as">as</A> LPC:

	<A HREF="version7.html#//">//</A> vim:set ft=c:

If you don't want to set the variable, use the <A HREF="options.html#modeline">modeline</A> in EVERY LPC file.

There are several implementations for LPC, we intend to support most widely
used ones.  Here the default LPC <A HREF="#syntax">syntax</A> is for MudOS series, for MudOS v22
and before, you should turn off the sensible modifiers, and this will also
asserts the new efuns after v22 to be invalid, don't set this variable when
you are using the latest version of MudOS:

<B>	:let lpc_pre_v22 = 1</B>

For LpMud 3.2 series of LPC:

<B>	:let lpc_compat_32 = 1</B>

For LPC4 series of LPC:

<B>	:let lpc_use_lpc4_syntax = 1</B>

For uLPC series of LPC:
uLPC has been developed to Pike, so you should use Pike <A HREF="#syntax">syntax</A>
instead, and the name of your source file should be *.pike



LUA						*<A NAME="lua.vim"></A><B>lua.vim</B>* *<A NAME="ft-lua-syntax"></A><B>ft-lua-syntax</B>*

The <A HREF="if_lua.html#Lua">Lua</A> <A HREF="#syntax">syntax</A> file can be used for versions 4.0, 5.0, 5.1 and 5.2 (5.2 is
the default). You can select one of these versions using the global <A HREF="eval.html#variables">variables</A>
lua_version and lua_subversion. For example, to activate <A HREF="if_lua.html#Lua">Lua</A>
5.1 <A HREF="#syntax">syntax</A> highlighting, set the <A HREF="eval.html#variables">variables</A> like this:

	<A HREF="eval.html#:let">:let</A> lua_version = 5
	<A HREF="eval.html#:let">:let</A> lua_subversion = 1



MAIL						*<A NAME="mail.vim"></A><B>mail.vim</B>* *<A NAME="ft-mail.vim"></A><B>ft-mail.vim</B>*

Vim highlights all the standard elements of an email (headers, signatures,
quoted text and URLs / email addresses).  In keeping with standard conventions,
signatures begin in a line containing only &quot;<A HREF="starting.html#--">--</A>&quot; followed optionally by
whitespaces and end with a newline.

Vim treats lines beginning with '<A HREF="index.html#]">]</A>', '<A HREF="motion.html#}">}</A>', '&#124;', '<A HREF="change.html#&gt;">&gt;</A>' or a <A HREF="motion.html#word">word</A> followed by '<A HREF="change.html#&gt;">&gt;</A>'
<A HREF="motion.html#as">as</A> quoted text.  However Vim highlights headers and signatures in quoted text
only if the text is quoted with '<A HREF="change.html#&gt;">&gt;</A>' (optionally followed by one space).

By default <A HREF="#mail.vim">mail.vim</A> synchronises <A HREF="#syntax">syntax</A> to 100 lines before the first
displayed line.  If you have a slow machine, and generally deal with emails
with short headers, you can change this to a smaller value:

<B>    :let mail_minlines = 30</B>



MAKE						*<A NAME="make.vim"></A><B>make.vim</B>* *<A NAME="ft-make-syntax"></A><B>ft-make-syntax</B>*

In makefiles, commands are usually highlighted to make <A HREF="motion.html#it">it</A> <A HREF="starting.html#easy">easy</A> for you to spot
<A HREF="message.html#errors">errors</A>.  However, this may be too much <A HREF="#coloring">coloring</A> for you.  You can turn this
feature off by using:

<B>	:let make_no_commands = 1</B>



MAPLE						*<A NAME="maple.vim"></A><B>maple.vim</B>* *<A NAME="ft-maple-syntax"></A><B>ft-maple-syntax</B>*

Maple <A HREF="visual.html#V">V</A>, by Waterloo Maple Inc, supports symbolic algebra.  The language
supports many packages of <A HREF="eval.html#functions">functions</A> which are selectively loaded by the user.
The standard set of packages' <A HREF="eval.html#functions">functions</A> <A HREF="motion.html#as">as</A> supplied in Maple <A HREF="visual.html#V">V</A> release 4 may be
highlighted at the user's discretion.  Users may place in their <A HREF="starting.html#.vimrc">.vimrc</A> file:

<B>	:let mvpkg_all= 1</B>

to get all package <A HREF="eval.html#functions">functions</A> highlighted, or users may select any subset by
choosing a variable/package from the table below and setting that variable to
1, also in their <A HREF="starting.html#.vimrc">.vimrc</A> file (prior to sourcing
$VIMRUNTIME/syntax/syntax.vim).

	Table of Maple <A HREF="visual.html#V">V</A> Package Function Selectors
<B>  mv_DEtools	 mv_genfunc	mv_networks	mv_process</B>
<B>  mv_Galois	 mv_geometry	mv_numapprox	mv_simplex</B>
<B>  mv_GaussInt	 mv_grobner	mv_numtheory	mv_stats</B>
<B>  mv_LREtools	 mv_group	mv_orthopoly	mv_student</B>
<B>  mv_combinat	 mv_inttrans	mv_padic	mv_sumtools</B>
<B>  mv_combstruct mv_liesymm	mv_plots	mv_tensor</B>
<B>  mv_difforms	 mv_linalg	mv_plottools	mv_totorder</B>
<B>  mv_finance	 mv_logic	mv_powseries</B>



MATHEMATICA		*<A NAME="mma.vim"></A><B>mma.vim</B>* *<A NAME="ft-mma-syntax"></A><B>ft-mma-syntax</B>* *<A NAME="ft-mathematica-syntax"></A><B>ft-mathematica-syntax</B>*

Empty *.m files will automatically be presumed to be Matlab files unless you
have the following in your <A HREF="starting.html#.vimrc">.vimrc</A>:

<B>	let filetype_m = "mma"</B>



MOO						*<A NAME="moo.vim"></A><B>moo.vim</B>* *<A NAME="ft-moo-syntax"></A><B>ft-moo-syntax</B>*

If you use C-style comments inside expressions and find <A HREF="motion.html#it">it</A> mangles your
highlighting, you may want to use extended (slow!) matches for C-style
comments:

<B>	:let moo_extended_cstyle_comments = 1</B>

To disable highlighting of pronoun substitution patterns inside strings:

<B>	:let moo_no_pronoun_sub = 1</B>

To disable highlighting of the regular <A HREF="eval.html#expression">expression</A> <A HREF="motion.html#operator">operator</A> '&#37;|', and matching
'&#37;(' and '&#37;)' inside strings:

<B>	:let moo_no_regexp = 1</B>

Unmatched double <A HREF="quotes.html#quotes">quotes</A> can be recognized and highlighted <A HREF="motion.html#as">as</A> <A HREF="message.html#errors">errors</A>:

<B>	:let moo_unmatched_quotes = 1</B>

To highlight builtin properties (.name, .location, .programmer etc.):

<B>	:let moo_builtin_properties = 1</B>

Unknown builtin <A HREF="eval.html#functions">functions</A> can be recognized and highlighted <A HREF="motion.html#as">as</A> <A HREF="message.html#errors">errors</A>.  If you
use this option, add your own extensions to the mooKnownBuiltinFunction group.
To enable this option:

<B>	:let moo_unknown_builtin_functions = 1</B>

An example of adding sprintf() to the list of known builtin <A HREF="eval.html#functions">functions</A>:

<B>	:syn keyword mooKnownBuiltinFunction sprintf contained</B>



MSQL						*<A NAME="msql.vim"></A><B>msql.vim</B>* *<A NAME="ft-msql-syntax"></A><B>ft-msql-syntax</B>*

There are two <A HREF="options.html#options">options</A> for the msql <A HREF="#syntax">syntax</A> highlighting.

If you like SQL <A HREF="#syntax">syntax</A> highlighting inside Strings, use this:

<B>	:let msql_sql_query = 1</B>

For syncing, minlines defaults to 100.	If you prefer another value, you can
set &quot;msql_minlines&quot; to the value you desire.  Example:

<B>	:let msql_minlines = 200</B>



NCF						*<A NAME="ncf.vim"></A><B>ncf.vim</B>* *<A NAME="ft-ncf-syntax"></A><B>ft-ncf-syntax</B>*

There is one option for NCF <A HREF="#syntax">syntax</A> highlighting.

If you want to have unrecognized (by <A HREF="#ncf.vim">ncf.vim</A>) statements highlighted <A HREF="motion.html#as">as</A>
<A HREF="message.html#errors">errors</A>, use this:

<B>	:let ncf_highlight_unknowns = 1</B>

If you don't want to highlight these <A HREF="message.html#errors">errors</A>, leave <A HREF="motion.html#it">it</A> unset.



NROFF						*<A NAME="nroff.vim"></A><B>nroff.vim</B>* *<A NAME="ft-nroff-syntax"></A><B>ft-nroff-syntax</B>*

The nroff <A HREF="#syntax">syntax</A> file works with AT&amp;T n/troff out of the box.  You need to
activate the GNU groff extra features included in the <A HREF="#syntax">syntax</A> file before you
can use them.

For example, Linux and BSD distributions use groff <A HREF="motion.html#as">as</A> their default text
processing package.  In order to activate the extra <A HREF="#syntax">syntax</A> highlighting
features for groff, add the following option to your start-up files:

<B>  :let b:nroff_is_groff = 1</B>

Groff is different from the old AT&amp;T n/troff that you may still find in
Solaris.  Groff <A HREF="map.html#macro">macro</A> and request names can be longer than 2 characters and
there are extensions to the language primitives.  For example, in AT&amp;T troff
you access the year <A HREF="motion.html#as">as</A> a 2-digit number with the request \(yr.  In groff you
can use the same request, recognized for compatibility, or you can use groff's
native <A HREF="#syntax">syntax</A>, \[yr].  Furthermore, you can use a 4-digit year directly:
\[year].  Macro requests can be longer than 2 characters, for example, GNU mm
accepts the requests &quot;.VERBON&quot; and &quot;.VERBOFF&quot; for creating verbatim
environments.

In order to obtain the best formatted output g/troff can give you, you should
follow a few simple rules about spacing and punctuation.

1. Do not leave empty spaces at the end of lines.

2. Leave one space and one space only after an end-of-sentence period,
   exclamation <A HREF="motion.html#mark">mark</A>, etc.

3. For reasons stated below, <A HREF="motion.html#it">it</A> is best to follow all period marks with a
   carriage return.

The reason behind these unusual <A HREF="tips.html#tips">tips</A> is that g/n/troff have a line breaking
algorithm that can be easily upset if you don't follow the rules given above.

Unlike TeX, troff fills text line-by-line, not paragraph-by-paragraph and,
furthermore, <A HREF="motion.html#it">it</A> does not have a concept of glue or stretch, all horizontal and
vertical space input will be output <A HREF="motion.html#as">as</A> is.

Therefore, you should be careful about not using more space between sentences
than you intend to have in your final document.  For this reason, the common
practice is to insert a carriage return immediately after all punctuation
marks.  If you want to have &quot;even&quot; text in your final processed output, you
need to maintain regular spacing in the input text.  To <A HREF="motion.html#mark">mark</A> both trailing
spaces and two or more spaces after a punctuation <A HREF="motion.html#as">as</A> an error, use:

<B>  :let nroff_space_errors = 1</B>

Another technique to detect extra spacing and other <A HREF="message.html#errors">errors</A> that will interfere
with the correct typesetting of your file, is to define an eye-catching
highlighting definition for the <A HREF="#syntax">syntax</A> groups &quot;nroffDefinition&quot; and
&quot;nroffDefSpecial&quot; in your configuration files.  For example:

<B>  hi def nroffDefinition term=italic cterm=italic gui=reverse</B>
<B>  hi def nroffDefSpecial term=italic,bold cterm=italic,bold</B>
<B>			 \ gui=reverse,bold</B>

If you want to navigate preprocessor entries in your source file <A HREF="motion.html#as">as</A> easily <A HREF="motion.html#as">as</A>
with section markers, you can activate the following option in your <A HREF="starting.html#.vimrc">.vimrc</A>
file:

<B>	let b:preprocs_as_sections = 1</B>

As well, the <A HREF="#syntax">syntax</A> file adds an extra <A HREF="motion.html#paragraph">paragraph</A> marker for the extended
<A HREF="motion.html#paragraph">paragraph</A> <A HREF="map.html#macro">macro</A> (.XP) in the ms package.

Finally, there is a |<A HREF="groff.html">groff.vim</A>| <A HREF="#syntax">syntax</A> file that can be used for enabling
groff <A HREF="#syntax">syntax</A> highlighting either on a file basis or globally by default.



OCAML						*<A NAME="ocaml.vim"></A><B>ocaml.vim</B>* *<A NAME="ft-ocaml-syntax"></A><B>ft-ocaml-syntax</B>*

The OCaml <A HREF="#syntax">syntax</A> file handles files having the following prefixes: .ml,
.mli, .mll and .mly.  By setting the following variable

<B>	:let ocaml_revised = 1</B>

you can switch from standard OCaml-syntax to revised <A HREF="#syntax">syntax</A> <A HREF="motion.html#as">as</A> supported
by the camlp4 preprocessor.  Setting the variable

<B>	:let ocaml_noend_error = 1</B>

prevents highlighting of &quot;end&quot; <A HREF="motion.html#as">as</A> error, which is useful when sources
contain very long structures that Vim does not synchronize anymore.



PAPP						*<A NAME="papp.vim"></A><B>papp.vim</B>* *<A NAME="ft-papp-syntax"></A><B>ft-papp-syntax</B>*

The PApp <A HREF="#syntax">syntax</A> file handles .papp files and, to a lesser extend, .pxml
and .pxsl files which are all a mixture of perl/xml/html/other using xml
<A HREF="motion.html#as">as</A> the top-level file format.  By default everything inside phtml or pxml
sections is treated <A HREF="motion.html#as">as</A> a string with embedded preprocessor commands.  If
you set the variable:

<B>	:let papp_include_html=1</B>

in your <A HREF="starting.html#startup">startup</A> file <A HREF="motion.html#it">it</A> will try to syntax-hilight html code inside phtml
sections, but this is relatively slow and much too colourful to be able to
edit sensibly. ;)

The newest version of the <A HREF="#papp.vim">papp.vim</A> <A HREF="#syntax">syntax</A> file can usually be found at
	<A HREF="http://papp.plan9.de">http://papp.plan9.de</A>.



PASCAL						*<A NAME="pascal.vim"></A><B>pascal.vim</B>* *<A NAME="ft-pascal-syntax"></A><B>ft-pascal-syntax</B>*

Files matching &quot;*.p&quot; could be Progress or Pascal.  If the automatic detection
doesn't work for you, or you don't edit Progress at all, use this in your
<A HREF="starting.html#startup">startup</A> <A HREF="starting.html#vimrc">vimrc</A>:

<B>   :let filetype_p = "pascal"</B>

The Pascal <A HREF="#syntax">syntax</A> file has been extended to take into account some extensions
provided by Turbo Pascal, Free Pascal Compiler and GNU Pascal Compiler.
Delphi keywords are also supported.  By default, Turbo Pascal 7.0 features are
enabled.  If you prefer to stick with the standard Pascal keywords, add the
following line to your <A HREF="starting.html#startup">startup</A> file:

<B>   :let pascal_traditional=1</B>

To switch on Delphi specific constructions (such <A HREF="motion.html#as">as</A> one-line comments,
keywords, etc):

<B>   :let pascal_delphi=1</B>


The option pascal_symbol_operator controls whether symbol operators such <A HREF="motion.html#as">as</A> +,
*, .., etc. are displayed using the Operator color or not.  To colorize symbol
operators, add the following line to your <A HREF="starting.html#startup">startup</A> file:

<B>   :let pascal_symbol_operator=1</B>

Some <A HREF="eval.html#functions">functions</A> are highlighted by default.  To switch <A HREF="motion.html#it">it</A> off:

<B>   :let pascal_no_functions=1</B>

Furthermore, there are specific <A HREF="eval.html#variables">variables</A> for some compilers.  Besides
pascal_delphi, there are pascal_gpc and pascal_fpc.  Default extensions try to
match Turbo Pascal.

<B>   :let pascal_gpc=1</B>

or

<B>   :let pascal_fpc=1</B>

To ensure that strings are defined on a single line, you can define the
pascal_one_line_string variable.

<B>   :let pascal_one_line_string=1</B>

If you dislike <A HREF="motion.html#&lt;Tab&gt;">&lt;Tab&gt;</A> chars, you can set the pascal_no_tabs variable.  Tabs
will be highlighted <A HREF="motion.html#as">as</A> Error.

<B>   :let pascal_no_tabs=1</B>




PERL						*<A NAME="perl.vim"></A><B>perl.vim</B>* *<A NAME="ft-perl-syntax"></A><B>ft-perl-syntax</B>*

There are a number of possible <A HREF="options.html#options">options</A> to the <A HREF="if_perl.html#perl">perl</A> <A HREF="#syntax">syntax</A> highlighting.

Inline POD highlighting is now turned on by default.  If you don't wish
to have the added complexity of highlighting POD embedded within <A HREF="if_perl.html#Perl">Perl</A>
files, you may set the 'perl_include_pod' option to 0:

<B>	:let perl_include_pod = 0</B>

The reduce the complexity of parsing (and increase performance) you can switch
off two elements in the parsing of variable names and contents.

To handle package references in variable and function names not differently
from the rest of the name (like 'PkgName::' in '$PkgName::VarName'):

<B>	:let perl_no_scope_in_variables = 1</B>

(In Vim 6.x <A HREF="motion.html#it">it</A> was the other way around: &quot;perl_want_scope_in_variables&quot;
enabled <A HREF="motion.html#it">it</A>.)

If you <A HREF="diff.html#do">do</A> not want complex things like '@{${&quot;foo&quot;}}' to be parsed:

<B>	:let perl_no_extended_vars = 1</B>

(In Vim 6.x <A HREF="motion.html#it">it</A> was the other way around: &quot;perl_extended_vars&quot; enabled <A HREF="motion.html#it">it</A>.)

The <A HREF="#coloring">coloring</A> strings can be changed.  By default strings and qq friends will be
highlighted like the first line.  If you set the variable
perl_string_as_statement, <A HREF="motion.html#it">it</A> will be highlighted <A HREF="motion.html#as">as</A> in the second line.

   &quot;hello world!&quot;; qq|hello world|;
   ^^^^^^^^^^^^^^NN^^^^^^^^^^^^^^^N	  (unlet perl_string_as_statement)
   S^^^^^^^^^^^^SNNSSS^^^^^^^^^^^SN	  (let perl_string_as_statement)

(^ = perlString, <A HREF="change.html#S">S</A> = perlStatement, N = None at all)

The syncing has 3 <A HREF="options.html#options">options</A>.  The first two switch off some triggering of
synchronization and should only be needed in <A HREF="change.html#case">case</A> <A HREF="motion.html#it">it</A> fails to work properly.
If while <A HREF="scroll.html#scrolling">scrolling</A> all of a sudden the whole screen changes color completely
then you should try and switch off one of those.  Let me know if you can figure
out the line that causes the mistake.

One triggers on &quot;^\s*sub\s*&quot; and the other on &quot;^[$@&#37;]&quot; more or <A HREF="various.html#less">less</A>.

<B>	:let perl_no_sync_on_sub</B>
<B>	:let perl_no_sync_on_global_var</B>

Below you can set the maximum distance VIM should look for starting points for
its attempts in <A HREF="#syntax">syntax</A> highlighting.

<B>	:let perl_sync_dist = 100</B>

If you want to use <A HREF="fold.html#folding">folding</A> with <A HREF="if_perl.html#perl">perl</A>, set perl_fold:

<B>	:let perl_fold = 1</B>

If you want to fold blocks in if statements, etc. <A HREF="motion.html#as">as</A> well set the following:

<B>	:let perl_fold_blocks = 1</B>

Subroutines are folded by default if 'perl_fold' is set.  If you <A HREF="diff.html#do">do</A> not want
this, you can set 'perl_nofold_subs':

<B>	:let perl_nofold_subs = 1</B>

Anonymous subroutines are not folded by default; you may enable their <A HREF="fold.html#folding">folding</A>
via 'perl_fold_anonymous_subs':

<B>	:let perl_fold_anonymous_subs = 1</B>

Packages are also folded by default if 'perl_fold' is set.  To disable this
behavior, set 'perl_nofold_packages':

<B>	:let perl_nofold_packages = 1</B>


PHP3 and PHP4		*<A NAME="php.vim"></A><B>php.vim</B>* *<A NAME="php3.vim"></A><B>php3.vim</B>* *<A NAME="ft-php-syntax"></A><B>ft-php-syntax</B>* *<A NAME="ft-php3-syntax"></A><B>ft-php3-syntax</B>*

[note: previously this was called &quot;php3&quot;, but since <A HREF="motion.html#it">it</A> now also supports php4
<A HREF="motion.html#it">it</A> has been renamed to &quot;php&quot;]

There are the following <A HREF="options.html#options">options</A> for the php <A HREF="#syntax">syntax</A> highlighting.

If you like SQL <A HREF="#syntax">syntax</A> highlighting inside Strings:

<B>  let php_sql_query = 1</B>

For highlighting the Baselib methods:

<B>  let php_baselib = 1</B>

Enable HTML <A HREF="#syntax">syntax</A> highlighting inside strings:

<B>  let php_htmlInStrings = 1</B>

Using the old colorstyle:

<B>  let php_oldStyle = 1</B>

Enable highlighting ASP-style short <A HREF="tagsrch.html#tags">tags</A>:

<B>  let php_asp_tags = 1</B>

Disable short <A HREF="tagsrch.html#tags">tags</A>:

<B>  let php_noShortTags = 1</B>

For highlighting parent error ] or ):

<B>  let php_parent_error_close = 1</B>

For skipping a php end <A HREF="tagsrch.html#tag">tag</A>, if there exists an open ( or [ without a closing
one:

<B>  let php_parent_error_open = 1</B>

Enable <A HREF="fold.html#folding">folding</A> for classes and <A HREF="eval.html#functions">functions</A>:

<B>  let php_folding = 1</B>

Selecting syncing method:

<B>  let php_sync_method = x</B>

<A HREF="change.html#x">x</A> = -1 to sync by search (default),
<A HREF="change.html#x">x</A> <A HREF="change.html#&gt;">&gt;</A> 0 to sync at least <A HREF="change.html#x">x</A> lines backwards,
<A HREF="change.html#x">x</A> = 0 to sync from start.



PLAINTEX				*<A NAME="plaintex.vim"></A><B>plaintex.vim</B>* *<A NAME="ft-plaintex-syntax"></A><B>ft-plaintex-syntax</B>*

TeX is a typesetting language, and plaintex is the file type for the &quot;plain&quot;
variant of TeX.  If you never want your *.tex files recognized <A HREF="motion.html#as">as</A> plain TeX,
see |<A HREF="filetype.html#ft-tex-plugin">ft-tex-plugin</A>|.

This <A HREF="#syntax">syntax</A> file has the option

<B>	let g:plaintex_delimiters = 1</B>

if you want to highlight brackets &quot;<A HREF="motion.html#[]">[]</A>&quot; and braces &quot;<A HREF="intro.html#{}">{}</A>&quot;.



PPWIZARD					*<A NAME="ppwiz.vim"></A><B>ppwiz.vim</B>* *<A NAME="ft-ppwiz-syntax"></A><B>ft-ppwiz-syntax</B>*

PPWizard is a preprocessor for HTML and <A HREF="os_os2.html#OS/2">OS/2</A> INF files

This <A HREF="#syntax">syntax</A> file has the <A HREF="options.html#options">options</A>:

- ppwiz_highlight_defs : determines highlighting mode for PPWizard's
  <A HREF="intro.html#definitions">definitions</A>.  Possible values are

  ppwiz_highlight_defs = 1 : PPWizard #define statements retain the
    colors of their contents (e.g. PPWizard macros and <A HREF="eval.html#variables">variables</A>)

  ppwiz_highlight_defs = 2 : preprocessor #define and #evaluate
    statements are shown in a single color with the exception of line
    continuation symbols

  The default setting for ppwiz_highlight_defs is 1.

- ppwiz_with_html : If the value is 1 (the default), highlight literal
  HTML code; if 0, treat HTML code like ordinary text.



PHTML						*<A NAME="phtml.vim"></A><B>phtml.vim</B>* *<A NAME="ft-phtml-syntax"></A><B>ft-phtml-syntax</B>*

There are two <A HREF="options.html#options">options</A> for the phtml <A HREF="#syntax">syntax</A> highlighting.

If you like SQL <A HREF="#syntax">syntax</A> highlighting inside Strings, use this:

<B>	:let phtml_sql_query = 1</B>

For syncing, minlines defaults to 100.	If you prefer another value, you can
set &quot;phtml_minlines&quot; to the value you desire.  Example:

<B>	:let phtml_minlines = 200</B>



POSTSCRIPT				*<A NAME="postscr.vim"></A><B>postscr.vim</B>* *<A NAME="ft-postscr-syntax"></A><B>ft-postscr-syntax</B>*

There are several <A HREF="options.html#options">options</A> when <A HREF="motion.html#it">it</A> comes to highlighting PostScript.

First which version of the PostScript language to highlight.  There are
currently three defined language versions, or levels.  Level 1 is the original
and base version, and includes all extensions prior to the release of level 2.
Level 2 is the most common version around, and includes its own set of
extensions prior to the release of level 3.  Level 3 is currently the highest
level supported.  You select which level of the PostScript language you want
highlighted by defining the postscr_level variable <A HREF="motion.html#as">as</A> follows:

<B>	:let postscr_level=2</B>

If this variable is not defined <A HREF="motion.html#it">it</A> defaults to 2 (level 2) since this is
the most prevalent version currently.

Note, not all PS interpreters will support all language features for a
particular language level.  In particular the &#37;!PS-Adobe-3.0 at the start of
PS files does NOT mean the PostScript present is level 3 PostScript!

If you are working with Display PostScript, you can include highlighting of
Display PS language features by defining the postscr_display variable <A HREF="motion.html#as">as</A>
follows:

<B>	:let postscr_display=1</B>

If you are working with Ghostscript, you can include highlighting of
Ghostscript specific language features by defining the variable
postscr_ghostscript <A HREF="motion.html#as">as</A> follows:

<B>	:let postscr_ghostscript=1</B>

PostScript is a large language, with many predefined elements.	While <A HREF="motion.html#it">it</A>
useful to have all these elements highlighted, on slower machines this can
cause Vim to slow down.  In an attempt to be machine friendly font names and
character encodings are not highlighted by default.  Unless you are working
explicitly with either of these this should be ok.  If you want them to be
highlighted you should set one or both of the following <A HREF="eval.html#variables">variables</A>:

<B>	:let postscr_fonts=1</B>
<B>	:let postscr_encodings=1</B>

There is a stylistic option to the highlighting of and, or, and not.  In
PostScript the function of these operators depends on the types of their
operands - if the operands are booleans then they are the logical operators,
if they are integers then they are binary operators.  As binary and logical
operators can be highlighted differently they have to be highlighted one way
or the other.  By default they are treated <A HREF="motion.html#as">as</A> logical operators.  They can be
highlighted <A HREF="motion.html#as">as</A> binary operators by defining the variable
postscr_andornot_binary <A HREF="motion.html#as">as</A> follows:

<B>	:let postscr_andornot_binary=1</B>
 


			*<A NAME="ptcap.vim"></A><B>ptcap.vim</B>* *<A NAME="ft-printcap-syntax"></A><B>ft-printcap-syntax</B>*

PRINTCAP + TERMCAP	*<A NAME="ft-ptcap-syntax"></A><B>ft-ptcap-syntax</B>* *<A NAME="ft-termcap-syntax"></A><B>ft-termcap-syntax</B>*

This <A HREF="#syntax">syntax</A> file applies to the printcap and <A HREF="term.html#termcap">termcap</A> databases.

In order for Vim to recognize printcap/termcap files that <A HREF="diff.html#do">do</A> not match
the patterns *printcap*, or *termcap*, you must put additional patterns
appropriate to your system in your |<A HREF="#myfiletypefile">myfiletypefile</A>| file.  For these
patterns, you must set the variable &quot;b:ptcap_type&quot; to either &quot;print&quot; or
&quot;term&quot;, and then the <A HREF="options.html#'filetype'">'filetype'</A> option to ptcap.

For example, to make Vim identify all files in /etc/termcaps/ <A HREF="motion.html#as">as</A> <A HREF="term.html#termcap">termcap</A>
files, add the following:

<B>   :au BufNewFile,BufRead /etc/termcaps/* let b:ptcap_type = "term" |</B>
<B>				       \ set filetype=ptcap</B>

If you notice highlighting <A HREF="message.html#errors">errors</A> while <A HREF="scroll.html#scrolling">scrolling</A> backwards, which
are fixed when redrawing with <A HREF="various.html#CTRL-L">CTRL-L</A>, try setting the &quot;ptcap_minlines&quot;
internal variable to a larger number:

<B>   :let ptcap_minlines = 50</B>

(The default is 20 lines.)



PROGRESS				*<A NAME="progress.vim"></A><B>progress.vim</B>* *<A NAME="ft-progress-syntax"></A><B>ft-progress-syntax</B>*

Files matching &quot;*.w&quot; could be Progress or cweb.  If the automatic detection
doesn't work for you, or you don't edit cweb at all, use this in your
<A HREF="starting.html#startup">startup</A> <A HREF="starting.html#vimrc">vimrc</A>:
<B>   :let filetype_w = "progress"</B>
The same happens for &quot;*.i&quot;, which could be assembly, and &quot;*.p&quot;, which could be
Pascal.  Use this if you don't use assembly and Pascal:
<B>   :let filetype_i = "progress"</B>
<B>   :let filetype_p = "progress"</B>



PYTHON						*<A NAME="python.vim"></A><B>python.vim</B>* *<A NAME="ft-python-syntax"></A><B>ft-python-syntax</B>*

There are six <A HREF="options.html#options">options</A> to <A HREF="intro.html#control">control</A> <A HREF="if_pyth.html#Python">Python</A> <A HREF="#syntax">syntax</A> highlighting.

For highlighted numbers:
<B>	:let python_no_number_highlight = 1</B>

For highlighted builtin <A HREF="eval.html#functions">functions</A>:
<B>	:let python_no_builtin_highlight = 1</B>

For highlighted standard exceptions:
<B>	:let python_no_exception_highlight = 1</B>

For highlighted doctests and code inside:
<B>	:let python_no_doctest_highlight = 1</B>
or
<B>	:let python_no_doctest_code_highlight = 1</B>
(first option implies second one).

For highlighted trailing <A HREF="pattern.html#whitespace">whitespace</A> and mix of spaces and tabs:
<B>	:let python_space_error_highlight = 1</B>

If you want all possible <A HREF="if_pyth.html#Python">Python</A> highlighting (the same <A HREF="motion.html#as">as</A> setting the
preceding last option and unsetting all other ones):
<B>	:let python_highlight_all = 1</B>

Note: only existence of these <A HREF="options.html#options">options</A> matter, not their value. You can replace
      1 above with anything.



QUAKE						*<A NAME="quake.vim"></A><B>quake.vim</B>* *<A NAME="ft-quake-syntax"></A><B>ft-quake-syntax</B>*

The Quake <A HREF="#syntax">syntax</A> definition should work for most any FPS (First Person
Shooter) based on one of the Quake engines.  However, the command names vary
a bit between the three games (Quake, Quake 2, and Quake 3 Arena) so the
<A HREF="#syntax">syntax</A> definition checks for the existence of three global <A HREF="eval.html#variables">variables</A> to allow
users to specify what commands are legal in their files.  The three <A HREF="eval.html#variables">variables</A>
can be set for the following effects:

set to highlight commands only available in Quake:
<B>	:let quake_is_quake1 = 1</B>

set to highlight commands only available in Quake 2:
<B>	:let quake_is_quake2 = 1</B>

set to highlight commands only available in Quake 3 Arena:
<B>	:let quake_is_quake3 = 1</B>

Any combination of these three <A HREF="eval.html#variables">variables</A> is legal, but might highlight more
commands than are actually available to you by the game.



READLINE				*<A NAME="readline.vim"></A><B>readline.vim</B>* *<A NAME="ft-readline-syntax"></A><B>ft-readline-syntax</B>*

The readline library is primarily used by the BASH shell, which adds quite a
few commands and <A HREF="options.html#options">options</A> to the ones already available.  To highlight these
items <A HREF="motion.html#as">as</A> well you can add the following to your |<A HREF="starting.html#vimrc">vimrc</A>| or just type <A HREF="motion.html#it">it</A> in the
command line before loading a file with the readline <A HREF="#syntax">syntax</A>:
<B>	let readline_has_bash = 1</B>

This will add highlighting for the commands that BASH (version 2.05a and
later, and part earlier) adds.



RESTRUCTURED TEXT			*<A NAME="rst.vim"></A><B>rst.vim</B>* *<A NAME="ft-rst-syntax"></A><B>ft-rst-syntax</B>*

You may set what <A HREF="#syntax">syntax</A> <A HREF="intro.html#definitions">definitions</A> should be used for code blocks via
	let rst_syntax_code_list = ['vim', <A HREF="options.html#'lisp'">'lisp'</A>, ...]



REXX						*<A NAME="rexx.vim"></A><B>rexx.vim</B>* *<A NAME="ft-rexx-syntax"></A><B>ft-rexx-syntax</B>*

If you notice highlighting <A HREF="message.html#errors">errors</A> while <A HREF="scroll.html#scrolling">scrolling</A> backwards, which are fixed
when redrawing with <A HREF="various.html#CTRL-L">CTRL-L</A>, try setting the &quot;rexx_minlines&quot; internal variable
to a larger number:
<B>	:let rexx_minlines = 50</B>
This will make the <A HREF="#syntax">syntax</A> synchronization start 50 lines before the first
displayed line.  The default value is 10.  The disadvantage of using a larger
number is that redrawing can become slow.

Vim tries to guess what type a &quot;.r&quot; file is.  If <A HREF="motion.html#it">it</A> can't be detected (from
comment lines), the default is &quot;<A HREF="change.html#r">r</A>&quot;.  To make the default rexx add this line to

your <A HREF="starting.html#.vimrc">.vimrc</A>:  *<A NAME="g:filetype_r"></A><B>g:filetype_r</B>*

<B>	:let g:filetype_r = "r"</B>



RUBY						*<A NAME="ruby.vim"></A><B>ruby.vim</B>* *<A NAME="ft-ruby-syntax"></A><B>ft-ruby-syntax</B>*

There are a number of <A HREF="options.html#options">options</A> to the <A HREF="if_ruby.html#Ruby">Ruby</A> <A HREF="#syntax">syntax</A> highlighting.

By default, the &quot;end&quot; keyword is colorized according to the opening statement
of the block <A HREF="motion.html#it">it</A> closes.  While useful, this feature can be expensive; if you
experience slow redrawing (or you are on a terminal with poor color support)
you may want to turn <A HREF="motion.html#it">it</A> off by defining the &quot;ruby_no_expensive&quot; variable:

<B>	:let ruby_no_expensive = 1</B>
 
In this <A HREF="change.html#case">case</A> the same color will be used for all <A HREF="intro.html#control">control</A> keywords.

If you <A HREF="diff.html#do">do</A> want this feature enabled, but notice highlighting <A HREF="message.html#errors">errors</A> while
<A HREF="scroll.html#scrolling">scrolling</A> backwards, which are fixed when redrawing with <A HREF="various.html#CTRL-L">CTRL-L</A>, try setting
the &quot;ruby_minlines&quot; variable to a value larger than 50:

<B>	:let ruby_minlines = 100</B>
 
Ideally, this value should be a number of lines large enough to embrace your
largest class or module.

Highlighting of special identifiers can be disabled by removing the
rubyIdentifier highlighting:

<B>	:hi link rubyIdentifier NONE</B>
 
This will prevent highlighting of special identifiers like &quot;ConstantName&quot;,
&quot;$global_var&quot;, &quot;@@class_var&quot;, &quot;@instance_var&quot;, &quot;| block_param |&quot;, and
&quot;:symbol&quot;.

Significant methods of Kernel, Module and Object are highlighted by default.
This can be disabled by defining &quot;ruby_no_special_methods&quot;:

<B>	:let ruby_no_special_methods = 1</B>
 
This will prevent highlighting of important methods such <A HREF="motion.html#as">as</A> &quot;require&quot;, &quot;attr&quot;,
&quot;private&quot;, &quot;raise&quot; and &quot;proc&quot;.

<A HREF="if_ruby.html#Ruby">Ruby</A> operators can be highlighted. This is enabled by defining
&quot;ruby_operators&quot;:

<B>	:let ruby_operators = 1</B>
 
Whitespace <A HREF="message.html#errors">errors</A> can be highlighted by defining &quot;ruby_space_errors&quot;:

<B>	:let ruby_space_errors = 1</B>
 
This will highlight trailing <A HREF="pattern.html#whitespace">whitespace</A> and tabs preceded by a space character
<A HREF="motion.html#as">as</A> <A HREF="message.html#errors">errors</A>.  This can be refined by defining &quot;ruby_no_trail_space_error&quot; and
&quot;ruby_no_tab_space_error&quot; which will ignore trailing <A HREF="pattern.html#whitespace">whitespace</A> and tabs after
spaces respectively.

<A HREF="fold.html#Folding">Folding</A> can be enabled by defining &quot;ruby_fold&quot;:

<B>	:let ruby_fold = 1</B>
 
This will set the <A HREF="options.html#'foldmethod'">'foldmethod'</A> option to &quot;<A HREF="#syntax">syntax</A>&quot; and allow <A HREF="fold.html#folding">folding</A> of
classes, modules, methods, code blocks, heredocs and comments.

<A HREF="fold.html#Folding">Folding</A> of multiline comments can be disabled by defining
&quot;ruby_no_comment_fold&quot;:

<B>	:let ruby_no_comment_fold = 1</B>
 


SCHEME						*<A NAME="scheme.vim"></A><B>scheme.vim</B>* *<A NAME="ft-scheme-syntax"></A><B>ft-scheme-syntax</B>*

By default only R5RS keywords are highlighted and properly indented.

MzScheme-specific stuff will be used if b:is_mzscheme or g:is_mzscheme
<A HREF="eval.html#variables">variables</A> are defined.

Also <A HREF="#scheme.vim">scheme.vim</A> supports keywords of the Chicken Scheme-&gt;C compiler.  Define
b:is_chicken or g:is_chicken, if you need them.



SDL						*<A NAME="sdl.vim"></A><B>sdl.vim</B>* *<A NAME="ft-sdl-syntax"></A><B>ft-sdl-syntax</B>*

The SDL highlighting probably misses a few keywords, but SDL has so many
of them it's almost impossibly to cope.

The new standard, SDL-2000, specifies that all identifiers are
case-sensitive (which was not so before), and that all keywords can be
used either completely <A HREF="change.html#lowercase">lowercase</A> or completely <A HREF="change.html#uppercase">uppercase</A>.  To have the
highlighting reflect this, you can set the following variable:
<B>	:let sdl_2000=1</B>

This also sets many new keywords.  If you want to disable the old
keywords, which is probably a good idea, use:
<B>	:let SDL_no_96=1</B>


The indentation is probably also incomplete, but right now I am very
satisfied with <A HREF="motion.html#it">it</A> for my own projects.



SED						*<A NAME="sed.vim"></A><B>sed.vim</B>* *<A NAME="ft-sed-syntax"></A><B>ft-sed-syntax</B>*

To make tabs stand out from regular blanks (accomplished by using Todo
highlighting on the tabs), define &quot;highlight_sedtabs&quot; by putting

<B>	:let highlight_sedtabs = 1</B>

in the <A HREF="starting.html#vimrc">vimrc</A> file.  (This special highlighting only applies for tabs
inside search patterns, replacement texts, addresses or text included
by an Append/Change/Insert command.)  If you enable this option, <A HREF="motion.html#it">it</A> is
also a good idea to set the <A HREF="intro.html#tab">tab</A> width to one character; by doing that,
you can easily <A HREF="intro.html#count">count</A> the number of tabs in a string.

Bugs:

  The transform command (y) is treated exactly like the substitute
  command.  This means that, <A HREF="motion.html#as">as</A> far <A HREF="motion.html#as">as</A> this <A HREF="#syntax">syntax</A> file is concerned,
  transform accepts the same flags <A HREF="motion.html#as">as</A> substitute, which is wrong.
  (Transform accepts no flags.)  I tolerate this bug because the
  involved commands need very complex treatment (95 patterns, one for
  each plausible <A HREF="pattern.html#pattern">pattern</A> delimiter).



SGML						*<A NAME="sgml.vim"></A><B>sgml.vim</B>* *<A NAME="ft-sgml-syntax"></A><B>ft-sgml-syntax</B>*

The <A HREF="#coloring">coloring</A> scheme for <A HREF="tagsrch.html#tags">tags</A> in the SGML file works <A HREF="motion.html#as">as</A> follows.

The <A HREF="intro.html#&lt;&gt;">&lt;&gt;</A> of opening <A HREF="tagsrch.html#tags">tags</A> are colored differently than the &lt;/&gt; of a closing <A HREF="tagsrch.html#tag">tag</A>.
This is on purpose! For opening <A HREF="tagsrch.html#tags">tags</A> the 'Function' color is used, while for
closing <A HREF="tagsrch.html#tags">tags</A> the 'Type' color is used (See syntax.vim to check how those are
defined for you)

Known <A HREF="tagsrch.html#tag">tag</A> names are colored the same way <A HREF="motion.html#as">as</A> statements in C.  Unknown <A HREF="tagsrch.html#tag">tag</A>
names are not colored which makes <A HREF="motion.html#it">it</A> <A HREF="starting.html#easy">easy</A> to spot <A HREF="message.html#errors">errors</A>.

Note that the same is true for argument (or attribute) names.  Known attribute
names are colored differently than unknown ones.

Some SGML <A HREF="tagsrch.html#tags">tags</A> are used to change the rendering of text.  The following <A HREF="tagsrch.html#tags">tags</A>
are recognized by the <A HREF="#sgml.vim">sgml.vim</A> <A HREF="#syntax">syntax</A> <A HREF="#coloring">coloring</A> file and change the way normal
text is shown: &lt;varname&gt; &lt;emphasis&gt; &lt;command&gt; &lt;function&gt; &lt;literal&gt;
&lt;replaceable&gt; &lt;ulink&gt; and &lt;link&gt;.

If you want to change how such text is rendered, you must redefine the
following <A HREF="#syntax">syntax</A> groups:

    - sgmlBold
    - sgmlBoldItalic
    - sgmlUnderline
    - sgmlItalic
    - sgmlLink for links

To make this redefinition work you must redefine them all and define the
following variable in your <A HREF="starting.html#vimrc">vimrc</A> (this is due to the order in which the files
are read during <A HREF="starting.html#initialization">initialization</A>)
<B>   let sgml_my_rendering=1</B>

You can also disable this rendering by adding the following line to your
<A HREF="starting.html#vimrc">vimrc</A> file:
<B>   let sgml_no_rendering=1</B>

(Adapted from the html.vim help text by Claudio Fleiner <A HREF="mailto:claudio@fleiner.com">&lt;claudio@fleiner.com&gt;</A>) 



SH		*<A NAME="sh.vim"></A><B>sh.vim</B>* *<A NAME="ft-sh-syntax"></A><B>ft-sh-syntax</B>* *<A NAME="ft-bash-syntax"></A><B>ft-bash-syntax</B>* *<A NAME="ft-ksh-syntax"></A><B>ft-ksh-syntax</B>*

This covers the &quot;normal&quot; <A HREF="os_unix.html#Unix">Unix</A> (Bourne) sh, bash and the Korn shell.

Vim attempts to determine which shell type is in use by specifying that
various filenames are of specific types:

<B>    ksh : .kshrc* *.ksh</B>
<B>    bash: .bashrc* bashrc bash.bashrc .bash_profile* *.bash</B>
 
If none of these cases pertain, then the first line of the file is examined
(ex. /bin/sh  /bin/ksh	/bin/bash).  If the first line specifies a shelltype,
then that shelltype is used.  However some files (ex. .profile) are known to
be shell files but the type is not apparent.  Furthermore, on many systems
sh is symbolically linked to &quot;bash&quot; (Linux, Windows+cygwin) or &quot;ksh&quot; (Posix).

One may specify a global default by instantiating one of the following three
<A HREF="eval.html#variables">variables</A> in your &lt;.vimrc&gt;:

    ksh:
<B>	let g:is_kornshell = 1</B>
    <A HREF="vi_diff.html#posix">posix</A>: (using this is the same <A HREF="motion.html#as">as</A> setting is_kornshell to 1)
<B>	let g:is_posix     = 1</B>
    bash:
<B>	let g:is_bash	   = 1</B>
    sh: (default) Bourne shell
<B>	let g:is_sh	   = 1</B>

If there's no &quot;#! ...&quot; line, and the user hasn't availed himself/herself of a
default <A HREF="#sh.vim">sh.vim</A> <A HREF="#syntax">syntax</A> setting <A HREF="motion.html#as">as</A> just shown, then syntax/sh.vim will assume
the Bourne shell <A HREF="#syntax">syntax</A>.  No need to <A HREF="change.html#quote">quote</A> RFCs or market penetration
statistics in error reports, please <A HREF="starting.html#--">--</A> just select the default version of the
sh your system uses in your &lt;.vimrc&gt;.

The syntax/sh.vim file provides several levels of syntax-based <A HREF="fold.html#folding">folding</A>:

<B>	let g:sh_fold_enabled= 0     (default, no syntax folding)</B>
<B>	let g:sh_fold_enabled= 1     (enable function folding)</B>
<B>	let g:sh_fold_enabled= 2     (enable heredoc folding)</B>
<B>	let g:sh_fold_enabled= 4     (enable if/do/for folding)</B>

then various <A HREF="#syntax">syntax</A> items (HereDocuments and function bodies) become
syntax-foldable (see |<A HREF="#:syn-fold">:syn-fold</A>|).  You also may add these together
to get multiple types of <A HREF="fold.html#folding">folding</A>:

<B>	let g:sh_fold_enabled= 3     (enables function and heredoc folding)</B>

If you notice highlighting <A HREF="message.html#errors">errors</A> while <A HREF="scroll.html#scrolling">scrolling</A> backwards which are fixed
when one redraws with <A HREF="various.html#CTRL-L">CTRL-L</A>, try setting the &quot;sh_minlines&quot; internal variable
to a larger number.  Example:

<B>	let sh_minlines = 500</B>

This will make <A HREF="#syntax">syntax</A> synchronization start 500 lines before the first
displayed line.  The default value is 200.  The disadvantage of using a larger
number is that redrawing can become slow.

If you don't have much to synchronize on, displaying can be very slow.	To
reduce this, the &quot;sh_maxlines&quot; internal variable can be set.  Example:

<B>	let sh_maxlines = 100</B>
 
The default is to use the <A HREF="if_cscop.html#twice">twice</A> sh_minlines.  Set <A HREF="motion.html#it">it</A> to a smaller number to
speed up displaying.  The disadvantage is that highlight <A HREF="message.html#errors">errors</A> may appear.


						*<A NAME="g:sh_isk"></A><B>g:sh_isk</B>* *<A NAME="g:sh_noisk"></A><B>g:sh_noisk</B>*
The shell languages appear to let &quot;<A HREF="repeat.html#.">.</A>&quot; be part of words, commands, etc;
consequently <A HREF="motion.html#it">it</A> should be in the isk for <A HREF="#sh.vim">sh.vim</A>.  As of v116 of syntax/sh.vim,
syntax/sh.vim will append the &quot;<A HREF="repeat.html#.">.</A>&quot; to |<A HREF="options.html#'iskeyword'">'iskeyword'</A>| by default; you may <A HREF="intro.html#control">control</A>
this behavior with:
<B>	let g:sh_isk  = '..whatever characters you want as part of iskeyword'</B>
<B>	let g:sh_noisk= 1  " otherwise, if this exists, the isk will NOT chg</B>
 

						*<A NAME="sh-embed"></A><B>sh-embed</B>*  *<A NAME="sh-awk"></A><B>sh-awk</B>*
<B><FONT COLOR="PURPLE"> Sh: EMBEDDING LANGUAGES</FONT></B>

You may wish to embed languages into sh.  I'll give an example courtesy of
Lorance Stinson on how to <A HREF="diff.html#do">do</A> this with awk <A HREF="motion.html#as">as</A> an example. Put the following
file into $HOME/.vim/after/syntax/sh/awkembed.vim:

<B>    " AWK Embedding: {{{1</B>
<B>    " ==============</B>
<B>    " Shamelessly ripped from aspperl.vim by Aaron Hope.</B>
<B>    if exists("b:current_syntax")</B>
<B>      unlet b:current_syntax</B>
<B>    endif</B>
<B>    syn include @AWKScript syntax/awk.vim</B>
<B>    syn region AWKScriptCode matchgroup=AWKCommand start=+[=\\]\@&lt;!'+ skip=+\\'+ end=+'+ contains=@AWKScript contained</B>
<B>    syn region AWKScriptEmbedded matchgroup=AWKCommand start=+\&lt;awk\&gt;+ skip=+\\$+ end=+[=\\]\@&lt;!'+me=e-1 contains=@shIdList,@shExprList2 nextgroup=AWKScriptCode</B>
<B>    syn cluster shCommandSubList add=AWKScriptEmbedded</B>
<B>    hi def link AWKCommand Type</B>
 
This code will then let the awk code in the single <A HREF="quotes.html#quotes">quotes</A>:
<B>	awk '...awk code here...'</B>
be highlighted using the awk highlighting <A HREF="#syntax">syntax</A>.  Clearly this may be
extended to other languages.



SPEEDUP						*<A NAME="spup.vim"></A><B>spup.vim</B>* *<A NAME="ft-spup-syntax"></A><B>ft-spup-syntax</B>*
(AspenTech plant simulator)

The Speedup <A HREF="#syntax">syntax</A> file has some <A HREF="options.html#options">options</A>:

- strict_subsections : If this variable is defined, only keywords for
  sections and subsections will be highlighted <A HREF="motion.html#as">as</A> statements but not
  other keywords (like WITHIN in the OPERATION section).

- highlight_types : Definition of this variable causes stream types
  like temperature or pressure to be highlighted <A HREF="motion.html#as">as</A> Type, not <A HREF="motion.html#as">as</A> a
  plain Identifier.  Included are the types that are usually found in
  the DECLARE section; if you defined own types, you have to include
  them in the <A HREF="#syntax">syntax</A> file.

- oneline_comments : this value ranges from 1 to 3 and determines the
  highlighting of # style comments.

  oneline_comments = 1 : allow normal Speedup code after an even
  number of #s.

  oneline_comments = 2 : show code starting with the second # <A HREF="motion.html#as">as</A>
  error.  This is the default setting.

  oneline_comments = 3 : show the whole line <A HREF="motion.html#as">as</A> error if <A HREF="motion.html#it">it</A> contains
  more than one #.

Since especially OPERATION sections tend to become very large due to
PRESETting <A HREF="eval.html#variables">variables</A>, syncing may be critical.  If your computer is
fast enough, you can increase minlines and/or maxlines near the end of
the <A HREF="#syntax">syntax</A> file.



SQL						*<A NAME="sql.vim"></A><B>sql.vim</B>* *<A NAME="ft-sql-syntax"></A><B>ft-sql-syntax</B>*

				*<A NAME="sqlinformix.vim"></A><B>sqlinformix.vim</B>* *<A NAME="ft-sqlinformix-syntax"></A><B>ft-sqlinformix-syntax</B>*

				*<A NAME="sqlanywhere.vim"></A><B>sqlanywhere.vim</B>* *<A NAME="ft-sqlanywhere-syntax"></A><B>ft-sqlanywhere-syntax</B>*

While there is an ANSI standard for SQL, most database engines add their own
custom extensions.  Vim currently supports the Oracle and Informix dialects of
SQL.  Vim assumes &quot;*.sql&quot; files are Oracle SQL by default.

Vim currently has SQL support for a variety of different vendors via <A HREF="#syntax">syntax</A>
scripts.  You can change Vim's default from Oracle to any of the current SQL
supported types.  You can also easily alter the SQL dialect being used on a
buffer by buffer basis.

For more detailed instructions see |<A HREF="ft_sql.html">ft_sql.txt</A>|.



TCSH						*<A NAME="tcsh.vim"></A><B>tcsh.vim</B>* *<A NAME="ft-tcsh-syntax"></A><B>ft-tcsh-syntax</B>*

This covers the shell named &quot;tcsh&quot;.  It is a superset of csh.  See |<A HREF="csh.html">csh.vim</A>|
for how the <A HREF="filetype.html#filetype">filetype</A> is detected.

Tcsh does not allow \&quot; in strings unless the &quot;backslash_quote&quot; shell variable
is set.  If you want VIM to assume that no <A HREF="intro.html#backslash">backslash</A> <A HREF="change.html#quote">quote</A> constructs exist add
this line to your <A HREF="starting.html#.vimrc">.vimrc</A>:

<B>	:let tcsh_backslash_quote = 0</B>

If you notice highlighting <A HREF="message.html#errors">errors</A> while <A HREF="scroll.html#scrolling">scrolling</A> backwards, which are fixed
when redrawing with <A HREF="various.html#CTRL-L">CTRL-L</A>, try setting the &quot;tcsh_minlines&quot; internal variable
to a larger number:

<B>	:let tcsh_minlines = 1000</B>

This will make the <A HREF="#syntax">syntax</A> synchronization start 1000 lines before the first
displayed line.  If you set &quot;tcsh_minlines&quot; to &quot;fromstart&quot;, then
synchronization is done from the start of the file. The default value for
tcsh_minlines is 100.  The disadvantage of using a larger number is that
redrawing can become slow.



TEX				*<A NAME="tex.vim"></A><B>tex.vim</B>* *<A NAME="ft-tex-syntax"></A><B>ft-tex-syntax</B>* *<A NAME="latex-syntax"></A><B>latex-syntax</B>*

<B><FONT COLOR="PURPLE">			Tex Contents</FONT></B>
	Tex: Want <A HREF="autocmd.html#Syntax">Syntax</A> <A HREF="fold.html#Folding">Folding</A>?			|<A HREF="#tex-folding">tex-folding</A>|
	Tex: No Spell Checking Wanted			|<A HREF="#g:tex_nospell">g:tex_nospell</A>|
	Tex: Don't Want Spell Checking In Comments?	|<A HREF="#tex-nospell">tex-nospell</A>|
	Tex: Want Spell Checking in Verbatim Zones?	|<A HREF="#tex-verb">tex-verb</A>|
	Tex: Run-on Comments or MathZones		|<A HREF="#tex-runon">tex-runon</A>|
	Tex: Slow <A HREF="autocmd.html#Syntax">Syntax</A> Highlighting?			|<A HREF="#tex-slow">tex-slow</A>|
	Tex: Want To Highlight More Commands?		|<A HREF="#tex-morecommands">tex-morecommands</A>|
	Tex: Excessive Error Highlighting?		|<A HREF="#tex-error">tex-error</A>|
	Tex: Need a new Math Group?			|<A HREF="#tex-math">tex-math</A>|
	Tex: Starting a New Style?			|<A HREF="#tex-style">tex-style</A>|
	Tex: Taking Advantage of Conceal Mode		|<A HREF="#tex-conceal">tex-conceal</A>|
	Tex: Selective Conceal Mode			|<A HREF="#g:tex_conceal">g:tex_conceal</A>|
	Tex: Controlling iskeyword			|<A HREF="#g:tex_isk">g:tex_isk</A>|


				*<A NAME="tex-folding"></A><B>tex-folding</B>* *<A NAME="g:tex_fold_enabled"></A><B>g:tex_fold_enabled</B>*
<B><FONT COLOR="PURPLE"> Tex: Want Syntax Folding? </FONT></B>

As of version 28 of &lt;syntax/tex.vim&gt;, syntax-based <A HREF="fold.html#folding">folding</A> of parts, chapters,
sections, subsections, etc are supported.  Put
<B>	let g:tex_fold_enabled=1</B>
in your &lt;.vimrc&gt;, and <A HREF="options.html#:set">:set</A> <A HREF="options.html#'fdm'">fdm</A>=syntax.  I suggest doing the latter via a
<A HREF="options.html#modeline">modeline</A> at the end of your LaTeX file:
<B>	% vim: fdm=syntax</B>
If your system becomes too slow, then you might wish to look into
<B>	https://vimhelp.appspot.com/vim_faq.txt.html#faq-29.7</B>
 

						*<A NAME="g:tex_nospell"></A><B>g:tex_nospell</B>*
<B><FONT COLOR="PURPLE"> Tex: No Spell Checking Wanted</FONT></B>

If you don't want <A HREF="spell.html#spell">spell</A> checking anywhere in your LaTeX document, put
<B>	let g:tex_nospell=1</B>
into your <A HREF="starting.html#.vimrc">.vimrc</A>.  If you merely wish to suppress <A HREF="spell.html#spell">spell</A> checking inside
comments only, see |<A HREF="#g:tex_comment_nospell">g:tex_comment_nospell</A>|.


				*<A NAME="tex-nospell"></A><B>tex-nospell</B>* *<A NAME="g:tex_comment_nospell"></A><B>g:tex_comment_nospell</B>*
<B><FONT COLOR="PURPLE"> Tex: Don't Want Spell Checking In Comments? </FONT></B>

Some folks like to include things like source code in comments and so would
prefer that <A HREF="spell.html#spell">spell</A> checking be disabled in comments in LaTeX files.  To <A HREF="diff.html#do">do</A>
this, put the following in your &lt;.vimrc&gt;:
<B>      let g:tex_comment_nospell= 1</B>
If you want to suppress <A HREF="spell.html#spell">spell</A> checking everywhere inside your LaTeX document,
see |<A HREF="#g:tex_nospell">g:tex_nospell</A>|.


				*<A NAME="tex-verb"></A><B>tex-verb</B>* *<A NAME="g:tex_verbspell"></A><B>g:tex_verbspell</B>*
<B><FONT COLOR="PURPLE"> Tex: Want Spell Checking in Verbatim Zones?</FONT></B>

Often verbatim regions are used for things like source code; seldom does
one want source code spell-checked.  However, for those of you who <A HREF="diff.html#do">do</A>
want your verbatim zones spell-checked, put the following in your &lt;.vimrc&gt;:
<B>	let g:tex_verbspell= 1</B>
 

					*<A NAME="tex-runon"></A><B>tex-runon</B>* *<A NAME="tex-stopzone"></A><B>tex-stopzone</B>*
<B><FONT COLOR="PURPLE"> Tex: Run-on Comments or MathZones </FONT></B>

The &lt;syntax/tex.vim&gt; highlighting supports TeX, LaTeX, and some AmsTeX.  The
highlighting supports three primary zones/regions: normal, texZone, and
texMathZone.  Although considerable effort has been made to have these zones
terminate properly, zones delineated by $..$ and $$..$$ cannot be synchronized
<A HREF="motion.html#as">as</A> there's no difference between start and end patterns.  Consequently, a
special &quot;TeX comment&quot; has been provided
<B>	%stopzone</B>
which will forcibly terminate the highlighting of either a texZone or a
texMathZone.


					*<A NAME="tex-slow"></A><B>tex-slow</B>* *<A NAME="tex-sync"></A><B>tex-sync</B>*
<B><FONT COLOR="PURPLE"> Tex: Slow Syntax Highlighting? </FONT></B>

If you have a slow computer, you may wish to reduce the values for
<B>	:syn sync maxlines=200</B>
<B>	:syn sync minlines=50</B>
(especially the latter).  If your computer is fast, you may wish to
increase them.	This primarily affects synchronizing (i.e. just what group,
if any, is the text at the top of the screen supposed to be in?).

Another cause of slow highlighting is due to syntax-driven <A HREF="fold.html#folding">folding</A>; see
|<A HREF="#tex-folding">tex-folding</A>| for a way around this.


					*<A NAME="g:tex_fast"></A><B>g:tex_fast</B>*

Finally, if <A HREF="#syntax">syntax</A> highlighting is still too slow, you may set

<B>	:let g:tex_fast= ""</B>

in your <A HREF="starting.html#.vimrc">.vimrc</A>.  Used this way, the <A HREF="#g:tex_fast">g:tex_fast</A> variable causes the <A HREF="#syntax">syntax</A>
highlighting <A HREF="usr_41.html#script">script</A> to avoid defining any regions and associated
synchronization.  The result will be much faster <A HREF="#syntax">syntax</A> highlighting; the
price: you will no longer have <A HREF="motion.html#as">as</A> much highlighting or any syntax-based
<A HREF="fold.html#folding">folding</A>, and you will be missing syntax-based error checking.

You may decide that some <A HREF="#syntax">syntax</A> is acceptable; you may use the following table
selectively to enable just some <A HREF="#syntax">syntax</A> highlighting:

<B>    b : allow bold and italic syntax</B>
<B>    c : allow texComment syntax</B>
<B>    m : allow texMatcher syntax (ie. {...} and [...])</B>
<B>    M : allow texMath syntax</B>
<B>    p : allow parts, chapter, section, etc syntax</B>
<B>    r : allow texRefZone syntax (nocite, bibliography, label, pageref, eqref)</B>
<B>    s : allow superscript/subscript regions</B>
<B>    S : allow texStyle syntax</B>
<B>    v : allow verbatim syntax</B>
<B>    V : allow texNewEnv and texNewCmd syntax</B>
 
As an example, let g:tex_fast= &quot;<A HREF="motion.html#M">M</A>&quot; will allow math-associated highlighting
but suppress all the other region-based <A HREF="#syntax">syntax</A> highlighting.


					*<A NAME="tex-morecommands"></A><B>tex-morecommands</B>* *<A NAME="tex-package"></A><B>tex-package</B>*
<B><FONT COLOR="PURPLE"> Tex: Want To Highlight More Commands? </FONT></B>

LaTeX is a programmable language, and so there are thousands of packages full
of specialized LaTeX commands, <A HREF="#syntax">syntax</A>, and fonts.  If you're using such a
package you'll often wish that the distributed syntax/tex.vim would support
<A HREF="motion.html#it">it</A>.  However, clearly this is impractical.  So please consider using the
techniques in |<A HREF="#mysyntaxfile-add">mysyntaxfile-add</A>| to extend or modify the highlighting provided
by syntax/tex.vim.  Please consider uploading any extensions that you write,
which typically would go in $HOME/after/syntax/tex/[pkgname].vim, to
	<A HREF="http://vim.sf.net/">http://vim.sf.net/</A>.


					*<A NAME="tex-error"></A><B>tex-error</B>* *<A NAME="g:tex_no_error"></A><B>g:tex_no_error</B>*
<B><FONT COLOR="PURPLE"> Tex: Excessive Error Highlighting? </FONT></B>

The &lt;tex.vim&gt; supports lexical error checking of various sorts.  Thus,
although the error checking is ofttimes very useful, <A HREF="motion.html#it">it</A> can indicate
<A HREF="message.html#errors">errors</A> where none actually are.  If this proves to be a problem for you,
you may put in your &lt;.vimrc&gt; the following statement:
<B>	let g:tex_no_error=1</B>
and all error checking by &lt;syntax/tex.vim&gt; will be suppressed.


								*<A NAME="tex-math"></A><B>tex-math</B>*
<B><FONT COLOR="PURPLE"> Tex: Need a new Math Group? </FONT></B>

If you want to include a new math group in your LaTeX, the following
code shows you an example <A HREF="motion.html#as">as</A> to how you might <A HREF="diff.html#do">do</A> so:
<B>	call TexNewMathZone(sfx,mathzone,starform)</B>
You'll want to provide the new math group with a unique suffix
(currently, A-L and V-Z are taken by &lt;syntax/tex.vim&gt; itself).
As an example, consider how eqnarray is set up by &lt;syntax/tex.vim&gt;:
<B>	call TexNewMathZone("D","eqnarray",1)</B>
You'll need to change &quot;mathzone&quot; to the name of your new math group,
and then to the call to <A HREF="motion.html#it">it</A> in .vim/after/syntax/tex.vim.
The &quot;starform&quot; variable, if true, implies that your new math group
has a starred form (ie. eqnarray*).


					*<A NAME="tex-style"></A><B>tex-style</B>* *<A NAME="b:tex_stylish"></A><B>b:tex_stylish</B>*
<B><FONT COLOR="PURPLE"> Tex: Starting a New Style? </FONT></B>

One may use &quot;\makeatletter&quot; in *.tex files, thereby making the use of &quot;<A HREF="repeat.html#@">@</A>&quot; in
commands available.  However, since the *.tex file doesn't have one of the
following suffices: sty cls clo dtx ltx, the <A HREF="#syntax">syntax</A> highlighting will flag
such use of @ <A HREF="motion.html#as">as</A> an error.  To solve this:

<B>	:let b:tex_stylish = 1</B>
<B>	:set ft=tex</B>

Putting &quot;let g:tex_stylish=1&quot; into your &lt;.vimrc&gt; will make &lt;syntax/tex.vim&gt;
always accept such use of @.


					*<A NAME="tex-cchar"></A><B>tex-cchar</B>* *<A NAME="tex-cole"></A><B>tex-cole</B>* *<A NAME="tex-conceal"></A><B>tex-conceal</B>*
<B><FONT COLOR="PURPLE"> Tex: Taking Advantage of Conceal Mode</FONT></B>

If you have |<A HREF="options.html#'conceallevel'">'conceallevel'</A>| set to 2 and if your encoding is <A HREF="mbyte.html#utf-8">utf-8</A>, then a
number of character sequences can be translated into appropriate <A HREF="mbyte.html#utf-8">utf-8</A> glyphs,
including various accented characters, Greek characters in MathZones, and
superscripts and subscripts in MathZones.  Not all characters can be made into
superscripts or subscripts; the constraint is due to what <A HREF="mbyte.html#utf-8">utf-8</A> supports.
In fact, only a few characters are supported <A HREF="motion.html#as">as</A> subscripts.

One way to use this is to have vertically split <A HREF="windows.html#windows">windows</A> (see |<A HREF="windows.html#CTRL-W_v">CTRL-W_v</A>|); one
with |<A HREF="options.html#'conceallevel'">'conceallevel'</A>| at 0 and the other at 2; and both using |<A HREF="options.html#'scrollbind'">'scrollbind'</A>|.


					*<A NAME="g:tex_conceal"></A><B>g:tex_conceal</B>*
<B><FONT COLOR="PURPLE"> Tex: Selective Conceal Mode</FONT></B>

You may selectively use <A HREF="#conceal">conceal</A> mode by setting <A HREF="#g:tex_conceal">g:tex_conceal</A> in your
&lt;.vimrc&gt;.  By default, <A HREF="#g:tex_conceal">g:tex_conceal</A> is set to &quot;admgs&quot; to enable concealment
for the following sets of characters:

<B>	a = accents/ligatures</B>
<B>	b = bold and italic</B>
<B>	d = delimiters</B>
<B>	m = math symbols</B>
<B>	g = Greek</B>
<B>	s = superscripts/subscripts</B>
 
By leaving one or more of these out, the associated conceal-character
substitution will not be made.


						*<A NAME="g:tex_isk"></A><B>g:tex_isk</B>* *<A NAME="g:tex_stylish"></A><B>g:tex_stylish</B>*
<B><FONT COLOR="PURPLE"> Tex: Controlling iskeyword</FONT></B>

Normally, LaTeX keywords support 0-9, a-z, A-z, and 192-255 only. Latex
keywords don't support the underscore - except when in *.sty files.  The
<A HREF="#syntax">syntax</A> highlighting <A HREF="usr_41.html#script">script</A> handles this with the following logic:

	&#42; If <A HREF="#g:tex_stylish">g:tex_stylish</A> exists and is 1
		then the file will be treated <A HREF="motion.html#as">as</A> a &quot;sty&quot; file, so the &quot;<A HREF="motion.html#_">_</A>&quot;
		will be allowed <A HREF="motion.html#as">as</A> part of keywords
		(irregardless of <A HREF="#g:tex_isk">g:tex_isk</A>)
	&#42; Else if the file's suffix is sty, cls, clo, dtx, or ltx,
		then the file will be treated <A HREF="motion.html#as">as</A> a &quot;sty&quot; file, so the &quot;<A HREF="motion.html#_">_</A>&quot;
		will be allowed <A HREF="motion.html#as">as</A> part of keywords
		(irregardless of <A HREF="#g:tex_isk">g:tex_isk</A>)

	&#42; If <A HREF="#g:tex_isk">g:tex_isk</A> exists, then <A HREF="motion.html#it">it</A> will be used for the local <A HREF="options.html#'iskeyword'">'iskeyword'</A>
	&#42; Else the local <A HREF="options.html#'iskeyword'">'iskeyword'</A> will be set to 48-57,a-z,A-Z,192-255



TF						*<A NAME="tf.vim"></A><B>tf.vim</B>* *<A NAME="ft-tf-syntax"></A><B>ft-tf-syntax</B>*

There is one option for the tf <A HREF="#syntax">syntax</A> highlighting.

For syncing, minlines defaults to 100.	If you prefer another value, you can
set &quot;tf_minlines&quot; to the value you desire.  Example:

<B>	:let tf_minlines = your choice</B>
 

VIM			*<A NAME="vim.vim"></A><B>vim.vim</B>*		*<A NAME="ft-vim-syntax"></A><B>ft-vim-syntax</B>*

			*<A NAME="g:vimsyn_minlines"></A><B>g:vimsyn_minlines</B>*	*<A NAME="g:vimsyn_maxlines"></A><B>g:vimsyn_maxlines</B>*
There is a trade-off between more accurate <A HREF="#syntax">syntax</A> highlighting versus screen
updating speed.  To improve accuracy, you may wish to increase the
<A HREF="#g:vimsyn_minlines">g:vimsyn_minlines</A> variable.  The <A HREF="#g:vimsyn_maxlines">g:vimsyn_maxlines</A> variable may be used to
improve screen updating rates (see |<A HREF="#:syn-sync">:syn-sync</A>| for more on this).

<B>	g:vimsyn_minlines : used to set synchronization minlines</B>
<B>	g:vimsyn_maxlines : used to set synchronization maxlines</B>
 
	(g:vim_minlines and g:vim_maxlines are deprecated variants of
	these two <A HREF="options.html#options">options</A>)


						*<A NAME="g:vimsyn_embed"></A><B>g:vimsyn_embed</B>*
The <A HREF="#g:vimsyn_embed">g:vimsyn_embed</A> option allows users to select what, if any, types of
embedded <A HREF="usr_41.html#script">script</A> highlighting they wish to have.

<B>   g:vimsyn_embed == 0   : don't embed any scripts</B>
<B>   g:vimsyn_embed =~ 'm' : embed mzscheme (but only if vim supports it)</B>
<B>   g:vimsyn_embed =~ 'p' : embed perl     (but only if vim supports it)</B>
<B>   g:vimsyn_embed =~ 'P' : embed python   (but only if vim supports it)</B>
<B>   g:vimsyn_embed =~ 'r' : embed ruby     (but only if vim supports it)</B>
<B>   g:vimsyn_embed =~ 't' : embed tcl      (but only if vim supports it)</B>
 
By default, <A HREF="#g:vimsyn_embed">g:vimsyn_embed</A> is &quot;mpPr&quot;; ie. syntax/vim.vim will support
highlighting <A HREF="if_mzsch.html#mzscheme">mzscheme</A>, <A HREF="if_perl.html#perl">perl</A>, <A HREF="if_pyth.html#python">python</A>, and <A HREF="if_ruby.html#ruby">ruby</A> by default.  Vim's has(&quot;tcl&quot;)
test appears to hang vim when <A HREF="if_tcl.html#tcl">tcl</A> is not truly available.  Thus, by default,
<A HREF="if_tcl.html#tcl">tcl</A> is not supported for embedding (but those of you who like <A HREF="if_tcl.html#tcl">tcl</A> embedded in
their vim <A HREF="#syntax">syntax</A> highlighting can simply include <A HREF="motion.html#it">it</A> in the g:vimembedscript
option).

						*<A NAME="g:vimsyn_folding"></A><B>g:vimsyn_folding</B>*

Some <A HREF="fold.html#folding">folding</A> is now supported with syntax/vim.vim:

<B>   g:vimsyn_folding == 0 or doesn't exist: no syntax-based folding</B>
<B>   g:vimsyn_folding =~ 'a' : augroups</B>
<B>   g:vimsyn_folding =~ 'f' : fold functions</B>
<B>   g:vimsyn_folding =~ 'm' : fold mzscheme script</B>
<B>   g:vimsyn_folding =~ 'p' : fold perl     script</B>
<B>   g:vimsyn_folding =~ 'P' : fold python   script</B>
<B>   g:vimsyn_folding =~ 'r' : fold ruby     script</B>
<B>   g:vimsyn_folding =~ 't' : fold tcl      script</B>
 

							*<A NAME="g:vimsyn_noerror"></A><B>g:vimsyn_noerror</B>*
Not all error highlighting that syntax/vim.vim does may be correct; VimL is a
difficult language to highlight correctly.  A way to suppress error
highlighting is to put the following line in your YXXYvimrc|:

<B>	let g:vimsyn_noerror = 1</B>
 



XF86CONFIG				*<A NAME="xf86conf.vim"></A><B>xf86conf.vim</B>* *<A NAME="ft-xf86conf-syntax"></A><B>ft-xf86conf-syntax</B>*

The <A HREF="#syntax">syntax</A> of XF86Config file differs in XFree86 v3.x and v4.x.  Both
variants are supported.  Automatic detection is used, but is far from perfect.
You may need to specify the version manually.  Set the variable
xf86conf_xfree86_version to 3 or 4 according to your XFree86 version in
your <A HREF="starting.html#.vimrc">.vimrc</A>.  Example:
<B>	:let xf86conf_xfree86_version=3</B>
When using a mix of versions, set the b:xf86conf_xfree86_version variable.

Note that spaces and underscores in option names are not supported.  Use
&quot;SyncOnGreen&quot; instead of &quot;__s yn con gr_e_e_n&quot; if you want the option name
highlighted.



XML						*<A NAME="xml.vim"></A><B>xml.vim</B>* *<A NAME="ft-xml-syntax"></A><B>ft-xml-syntax</B>*

Xml namespaces are highlighted by default.  This can be inhibited by
setting a global variable:

<B>	:let g:xml_namespace_transparent=1</B>
 

							*<A NAME="xml-folding"></A><B>xml-folding</B>*
The xml <A HREF="#syntax">syntax</A> file provides <A HREF="#syntax">syntax</A> |<A HREF="fold.html#folding">folding</A>| (see |<A HREF="#:syn-fold">:syn-fold</A>|) between
start and end <A HREF="tagsrch.html#tags">tags</A>.  This can be turned on by

<B>	:let g:xml_syntax_folding = 1</B>
<B>	:set foldmethod=syntax</B>

Note: <A HREF="#syntax">syntax</A> <A HREF="fold.html#folding">folding</A> might slow down <A HREF="#syntax">syntax</A> highlighting significantly,
especially for large files.



X Pixmaps (XPM)					*<A NAME="xpm.vim"></A><B>xpm.vim</B>* *<A NAME="ft-xpm-syntax"></A><B>ft-xpm-syntax</B>*

<A HREF="#xpm.vim">xpm.vim</A> creates its <A HREF="#syntax">syntax</A> items dynamically based upon the contents of the
XPM file.  Thus if you make changes e.g. in the color specification strings,
you have to source <A HREF="motion.html#it">it</A> again e.g. with &quot;<A HREF="options.html#:set">:set</A> <A HREF="options.html#'syn'">syn</A>=xpm&quot;.

To copy a pixel with one of the colors, <A HREF="change.html#yank">yank</A> a &quot;pixel&quot; with &quot;yl&quot; and insert <A HREF="motion.html#it">it</A>
somewhere else with &quot;<A HREF="change.html#P">P</A>&quot;.

Do you want to draw with the mouse?  Try the following:
<B>   :function! GetPixel()</B>
<B>   :   let c = getline(".")[col(".") - 1]</B>
<B>   :   echo c</B>
<B>   :   exe "noremap &lt;LeftMouse&gt; &lt;LeftMouse&gt;r".c</B>
<B>   :   exe "noremap &lt;LeftDrag&gt;	&lt;LeftMouse&gt;r".c</B>
<B>   :endfunction</B>
<B>   :noremap &lt;RightMouse&gt; &lt;LeftMouse&gt;:call GetPixel()&lt;CR&gt;</B>
<B>   :set guicursor=n:hor20	   " to see the color beneath the cursor</B>
This turns the right button into a pipette and the left button into a pen.
It will work with XPM files that have one character per pixel only and you
must not click outside of the pixel strings, but feel free to improve <A HREF="motion.html#it">it</A>.

It will look much better with a font in a quadratic cell size, e.g. for X:
<B>	:set guifont=-*-clean-medium-r-*-*-8-*-*-*-*-80-*</B>

==============================================================================

5. Defining a <A HREF="#syntax">syntax</A>					*<A NAME=":syn-define"></A><B>:syn-define</B>* *<A NAME="E410"></A><B>E410</B>*

Vim understands three types of <A HREF="#syntax">syntax</A> items:

1. Keyword
   It can only contain keyword characters, according to the <A HREF="options.html#'iskeyword'">'iskeyword'</A>
   option.  It cannot contain other <A HREF="#syntax">syntax</A> items.  It will only match with a
   complete <A HREF="motion.html#word">word</A> (there are no keyword characters before or after the match).
   The keyword &quot;if&quot; would match in &quot;if(a=b)&quot;, but not in &quot;ifdef x&quot;, because
   &quot;<A HREF="motion.html#(">(</A>&quot; is not a keyword character and &quot;<A HREF="change.html#d">d</A>&quot; is.

2. Match
   This is a match with a single <A HREF="pattern.html#regexp">regexp</A> <A HREF="pattern.html#pattern">pattern</A>.

3. Region
   This starts at a match of the &quot;start&quot; <A HREF="pattern.html#regexp">regexp</A> <A HREF="pattern.html#pattern">pattern</A> and ends with a match
   with the &quot;end&quot; <A HREF="pattern.html#regexp">regexp</A> <A HREF="pattern.html#pattern">pattern</A>.  Any other text can appear in between.  A
   &quot;skip&quot; <A HREF="pattern.html#regexp">regexp</A> <A HREF="pattern.html#pattern">pattern</A> can be used to avoid matching the &quot;end&quot; <A HREF="pattern.html#pattern">pattern</A>.

Several <A HREF="#syntax">syntax</A> ITEMs can be put into one <A HREF="#syntax">syntax</A> GROUP.	For a <A HREF="#syntax">syntax</A> group
you can give highlighting attributes.  For example, you could have an item
to define a &quot;/* .. */&quot; comment and another one that defines a &quot;<A HREF="version7.html#//">//</A> ..&quot; comment,
and put them both in the &quot;Comment&quot; group.  You can then specify that a
&quot;Comment&quot; will be in <A HREF="#bold">bold</A> font and have a blue color.  You are free to make
one highlight group for one <A HREF="#syntax">syntax</A> item, or put all items into one group.
This depends on how you want to specify your highlighting attributes.  Putting
each item in its own group results in having to specify the highlighting
for a lot of groups.

Note that a <A HREF="#syntax">syntax</A> group and a highlight group are similar.  For a highlight
group you will have given highlight attributes.  These attributes will be used
for the <A HREF="#syntax">syntax</A> group with the same name.

In <A HREF="change.html#case">case</A> more than one item matches at the same position, the one that was
defined LAST wins.  Thus you can override previously defined <A HREF="#syntax">syntax</A> items by
using an item that matches the same text.  But a keyword always goes before a
match or region.  And a keyword with matching <A HREF="change.html#case">case</A> always goes before a
keyword with ignoring <A HREF="change.html#case">case</A>.



PRIORITY						*<A NAME=":syn-priority"></A><B>:syn-priority</B>*

When several <A HREF="#syntax">syntax</A> items may match, these rules are used:

1. When multiple Match or Region items start in the same position, the item
   defined last has priority.
2. A Keyword has priority over Match and Region items.
3. An item that starts in an earlier position has priority over items that
   start in later positions.



DEFINING CASE						*<A NAME=":syn-case"></A><B>:syn-case</B>* *<A NAME="E390"></A><B>E390</B>*

:sy[ntax] <A HREF="change.html#case">case</A> [match &#124; ignore]
	This defines if the following &quot;<A HREF="#:syntax">:syntax</A>&quot; commands will work with
	matching <A HREF="change.html#case">case</A>, when using &quot;match&quot;, or with ignoring <A HREF="change.html#case">case</A>, when using
	&quot;ignore&quot;.  Note that any items before this are not affected, and all
	items until the next &quot;<A HREF="#:syntax">:syntax</A> case&quot; command are affected.



SPELL CHECKING						*<A NAME=":syn-spell"></A><B>:syn-spell</B>*

:sy[ntax] <A HREF="spell.html#spell">spell</A> [toplevel &#124; notoplevel &#124; default]
	This defines where <A HREF="spell.html#spell">spell</A> checking is to be done for text that is not
	in a <A HREF="#syntax">syntax</A> item:

	toplevel:	Text is <A HREF="spell.html#spell">spell</A> checked.
	notoplevel:	Text is not <A HREF="spell.html#spell">spell</A> checked.
	default:	When there is a @Spell cluster no <A HREF="spell.html#spell">spell</A> checking.

	For text in <A HREF="#syntax">syntax</A> items use the @Spell and @NoSpell clusters
	|<A HREF="spell.html#spell-syntax">spell-syntax</A>|.  When there is no @Spell and no @NoSpell cluster then
	<A HREF="spell.html#spell">spell</A> checking is done for &quot;default&quot; and &quot;toplevel&quot;.

	To activate <A HREF="spell.html#spell">spell</A> checking the <A HREF="options.html#'spell'">'spell'</A> option must be set.



DEFINING KEYWORDS					*<A NAME=":syn-keyword"></A><B>:syn-keyword</B>*

:sy[ntax] keyword <A HREF="#{group-name}">{group-name}</A> [{options}] {keyword} .. [{options}]

	This defines a number of keywords.

	<A HREF="#{group-name}">{group-name}</A>	Is a <A HREF="#syntax">syntax</A> group name such <A HREF="motion.html#as">as</A> &quot;Comment&quot;.
	[{options}]	See |<A HREF="#:syn-arguments">:syn-arguments</A>| below.
	{keyword} ..	Is a list of keywords which are part of this group.

	Example:
<B>  :syntax keyword   Type   int long char</B>
 
	The {options} can be given anywhere in the line.  They will apply to
	all keywords given, also for <A HREF="options.html#options">options</A> that come after a keyword.
	These examples <A HREF="diff.html#do">do</A> exactly the same:
<B>  :syntax keyword   Type   contained int long char</B>
<B>  :syntax keyword   Type   int long contained char</B>
<B>  :syntax keyword   Type   int long char contained</B>

 								*<A NAME="E789"></A><B>E789</B>*
	When you have a keyword with an optional tail, like <A HREF="intro.html#Ex">Ex</A> commands in
	Vim, you can put the optional characters inside <A HREF="motion.html#[]">[]</A>, to define all the
	variations at once:
<B>  :syntax keyword   vimCommand	 ab[breviate] n[ext]</B>
 
	Don't forget that a keyword can only be recognized if all the
	characters are included in the <A HREF="options.html#'iskeyword'">'iskeyword'</A> option.  If one character
	isn't, the keyword will never be recognized.
	Multi-byte characters can also be used.  These <A HREF="diff.html#do">do</A> not have to be in
	<A HREF="options.html#'iskeyword'">'iskeyword'</A>.

	A keyword always has higher priority than a match or region, the
	keyword is used if more than one item matches.	Keywords <A HREF="diff.html#do">do</A> not nest
	and a keyword can't contain anything else.

	Note that when you have a keyword that is the same <A HREF="motion.html#as">as</A> an option (even
	one that isn't allowed here), you can not use <A HREF="motion.html#it">it</A>.  Use a match
	instead.

	The maximum length of a keyword is 80 characters.

	The same keyword can be defined multiple times, when its containment
	differs.  For example, you can define the keyword once not contained
	and use one highlight group, and once contained, and use a different
	highlight group.  Example:
<B>  :syn keyword vimCommand tag</B>
<B>  :syn keyword vimSetting contained tag</B>
 	When finding &quot;<A HREF="tagsrch.html#tag">tag</A>&quot; outside of any <A HREF="#syntax">syntax</A> item, the &quot;vimCommand&quot;
	highlight group is used.  When finding &quot;<A HREF="tagsrch.html#tag">tag</A>&quot; in a <A HREF="#syntax">syntax</A> item that
	contains &quot;vimSetting&quot;, the &quot;vimSetting&quot; group is used.



DEFINING MATCHES					*<A NAME=":syn-match"></A><B>:syn-match</B>*

:sy[ntax] match <A HREF="#{group-name}">{group-name}</A> [{options}] [excludenl] {pattern} [{options}]

	This defines one match.

	<A HREF="#{group-name}">{group-name}</A>		A <A HREF="#syntax">syntax</A> group name such <A HREF="motion.html#as">as</A> &quot;Comment&quot;.
	[{options}]		See |<A HREF="#:syn-arguments">:syn-arguments</A>| below.
	[excludenl]		Don't make a <A HREF="pattern.html#pattern">pattern</A> with the end-of-line &quot;<A HREF="motion.html#$">$</A>&quot;
				extend a containing match or region.  Must be
				given before the <A HREF="pattern.html#pattern">pattern</A>. |<A HREF="#:syn-excludenl">:syn-excludenl</A>|
	{pattern}		The search <A HREF="pattern.html#pattern">pattern</A> that defines the match.
				See |<A HREF="#:syn-pattern">:syn-pattern</A>| below.
				Note that the <A HREF="pattern.html#pattern">pattern</A> may match more than one
				line, which makes the match depend on where
				Vim starts searching for the <A HREF="pattern.html#pattern">pattern</A>.  You
				need to make sure syncing takes care of this.

	Example (match a character constant):
<B>  :syntax match Character /'.'/hs=s+1,he=e-1</B>
 


DEFINING REGIONS	*<A NAME=":syn-region"></A><B>:syn-region</B>* *<A NAME=":syn-start"></A><B>:syn-start</B>* *<A NAME=":syn-skip"></A><B>:syn-skip</B>* *<A NAME=":syn-end"></A><B>:syn-end</B>*

							*<A NAME="E398"></A><B>E398</B>* *<A NAME="E399"></A><B>E399</B>*
:sy[ntax] region <A HREF="#{group-name}">{group-name}</A> [{options}]
		[matchgroup={group-name}]
		[keepend]
		[extend]
		[excludenl]
		start={start_pattern} ..
		[skip={skip_pattern}]
		end={end_pattern} ..
		[{options}]

	This defines one region.  It may span several lines.

	<A HREF="#{group-name}">{group-name}</A>		A <A HREF="#syntax">syntax</A> group name such <A HREF="motion.html#as">as</A> &quot;Comment&quot;.
	[{options}]		See |<A HREF="#:syn-arguments">:syn-arguments</A>| below.
	[matchgroup={group-name}]  The <A HREF="#syntax">syntax</A> group to use for the following
				start or end <A HREF="pattern.html#pattern">pattern</A> matches only.  Not used
				for the text in between the matched start and
				end patterns.  Use NONE to reset to not using
				a different group for the start or end match.
				See |<A HREF="#:syn-matchgroup">:syn-matchgroup</A>|.
	keepend			Don't allow contained matches to go past a
				match with the end <A HREF="pattern.html#pattern">pattern</A>.  See
				|<A HREF="#:syn-keepend">:syn-keepend</A>|.
	extend			Override a &quot;keepend&quot; for an item this region
				is contained in.  See |<A HREF="#:syn-extend">:syn-extend</A>|.
	excludenl		Don't make a <A HREF="pattern.html#pattern">pattern</A> with the end-of-line &quot;<A HREF="motion.html#$">$</A>&quot;
				extend a containing match or item.  Only
				useful for end patterns.  Must be given before
				the patterns <A HREF="motion.html#it">it</A> applies to. |<A HREF="#:syn-excludenl">:syn-excludenl</A>|
	start={start_pattern}	The search <A HREF="pattern.html#pattern">pattern</A> that defines the start of
				the region.  See |<A HREF="#:syn-pattern">:syn-pattern</A>| below.
	skip={skip_pattern}	The search <A HREF="pattern.html#pattern">pattern</A> that defines text inside
				the region where not to look for the end
				pattern.  See |<A HREF="#:syn-pattern">:syn-pattern</A>| below.
	end={end_pattern}	The search <A HREF="pattern.html#pattern">pattern</A> that defines the end of
				the region.  See |<A HREF="#:syn-pattern">:syn-pattern</A>| below.

	Example:
<B>  :syntax region String   start=+"+  skip=+\\"+  end=+"+</B>
 
	The start/skip/end patterns and the <A HREF="options.html#options">options</A> can be given in any order.
	There can be zero or one skip <A HREF="pattern.html#pattern">pattern</A>.	There must be one or more
	start and end patterns.  This means that you can omit the skip
	<A HREF="pattern.html#pattern">pattern</A>, but you must give at least one start and one end <A HREF="pattern.html#pattern">pattern</A>.  It
	is allowed to have white space before and after the equal sign
	(although <A HREF="motion.html#it">it</A> mostly looks better without white space).

	When more than one start <A HREF="pattern.html#pattern">pattern</A> is given, a match with one of these
	is sufficient.	This means there is an OR relation between the start
	patterns.  The last one that matches is used.  The same is true for
	the end patterns.

	The search for the end <A HREF="pattern.html#pattern">pattern</A> starts right after the start <A HREF="pattern.html#pattern">pattern</A>.
	Offsets are not used for this.	This implies that the match for the
	end <A HREF="pattern.html#pattern">pattern</A> will never overlap with the start <A HREF="pattern.html#pattern">pattern</A>.

	The skip and end <A HREF="pattern.html#pattern">pattern</A> can match across line breaks, but since the
	search for the <A HREF="pattern.html#pattern">pattern</A> can start in any line <A HREF="motion.html#it">it</A> often does not <A HREF="diff.html#do">do</A> what
	you want.  The skip <A HREF="pattern.html#pattern">pattern</A> doesn't avoid a match of an end <A HREF="pattern.html#pattern">pattern</A> in
	the next line.	Use single-line patterns to avoid trouble.

	Note: The decision to start a region is only based on a matching start
	<A HREF="pattern.html#pattern">pattern</A>.  There is no check for a matching end <A HREF="pattern.html#pattern">pattern</A>.  This does NOT
	work:
<B>		:syn region First  start="("  end=":"</B>
<B>		:syn region Second start="("  end=";"</B>
 	The Second always matches before the First (last defined <A HREF="pattern.html#pattern">pattern</A> has
	higher priority).  The Second region then continues until the next
	'<A HREF="motion.html#;">;</A>', no matter if there is a '<A HREF="cmdline.html#:">:</A>' before <A HREF="motion.html#it">it</A>.  Using a match does work:
<B>		:syn match First  "(\_.\{-}:"</B>
<B>		:syn match Second "(\_.\{-};"</B>
 	This <A HREF="pattern.html#pattern">pattern</A> matches any character or line break with &quot;\_.&quot; and
	repeats that with &quot;\{-}&quot; (repeat <A HREF="motion.html#as">as</A> few <A HREF="motion.html#as">as</A> possible).


							*<A NAME=":syn-keepend"></A><B>:syn-keepend</B>*
	By default, a contained match can obscure a match for the end <A HREF="pattern.html#pattern">pattern</A>.
	This is useful for nesting.  For example, a region that starts with
	&quot;<A HREF="motion.html#{">{</A>&quot; and ends with &quot;<A HREF="motion.html#}">}</A>&quot;, can contain another region.  An encountered &quot;<A HREF="motion.html#}">}</A>&quot;
	will then end the contained region, but not the outer region:
	    {		starts outer &quot;<A HREF="intro.html#{}">{}</A>&quot; region
		{	starts contained &quot;<A HREF="intro.html#{}">{}</A>&quot; region
		}	ends contained &quot;<A HREF="intro.html#{}">{}</A>&quot; region
	    }		ends outer &quot;<A HREF="intro.html#{}">{}</A> region
	If you don't want this, the &quot;keepend&quot; argument will make the matching
	of an end <A HREF="pattern.html#pattern">pattern</A> of the outer region also end any contained item.
	This makes <A HREF="motion.html#it">it</A> impossible to nest the same region, but allows for
	contained items to highlight parts of the end <A HREF="pattern.html#pattern">pattern</A>, without causing
	that to skip the match with the end <A HREF="pattern.html#pattern">pattern</A>.  Example:
<B>  :syn match  vimComment +"[^"]\+$+</B>
<B>  :syn region vimCommand start="set" end="$" contains=vimComment keepend</B>
 	The &quot;keepend&quot; makes the vimCommand always end at the end of the line,
	even though the contained vimComment includes a match with the <A HREF="intro.html#&lt;EOL&gt;">&lt;EOL&gt;</A>.

	When &quot;keepend&quot; is not used, a match with an end <A HREF="pattern.html#pattern">pattern</A> is retried
	after each contained match.  When &quot;keepend&quot; is included, the first
	encountered match with an end <A HREF="pattern.html#pattern">pattern</A> is used, truncating any
	contained matches.

							*<A NAME=":syn-extend"></A><B>:syn-extend</B>*
	The &quot;keepend&quot; behavior can be changed by using the &quot;extend&quot; argument.
	When an item with &quot;extend&quot; is contained in an item that uses
	&quot;keepend&quot;, the &quot;keepend&quot; is ignored and the containing region will be
	extended.
	This can be used to have some contained items extend a region while
	others don't.  Example:

<B>   :syn region htmlRef start=+&lt;a&gt;+ end=+&lt;/a&gt;+ keepend contains=htmlItem,htmlScript</B>
<B>   :syn match htmlItem +&lt;[^&gt;]*&gt;+ contained</B>
<B>   :syn region htmlScript start=+&lt;script+ end=+&lt;/script[^&gt;]*&gt;+ contained extend</B>

 	Here the htmlItem item does not make the htmlRef item continue
	further, <A HREF="motion.html#it">it</A> is only used to highlight the <A HREF="intro.html#&lt;&gt;">&lt;&gt;</A> items.  The htmlScript
	item does extend the htmlRef item.

	Another example:
<B>   :syn region xmlFold start="&lt;a&gt;" end="&lt;/a&gt;" fold transparent keepend extend</B>
 	This defines a region with &quot;keepend&quot;, so that its end cannot be
	changed by contained items, like when the &quot;&lt;/a&gt;&quot; is matched to
	highlight <A HREF="motion.html#it">it</A> differently.  But when the xmlFold region is nested (it
	includes itself), the &quot;extend&quot; applies, so that the &quot;&lt;/a&gt;&quot; of a nested
	region only ends that region, and not the one <A HREF="motion.html#it">it</A> is contained in.


							*<A NAME=":syn-excludenl"></A><B>:syn-excludenl</B>*
	When a <A HREF="pattern.html#pattern">pattern</A> for a match or end <A HREF="pattern.html#pattern">pattern</A> of a region includes a '<A HREF="motion.html#$">$</A>'
	to match the end-of-line, <A HREF="motion.html#it">it</A> will make a region item that <A HREF="motion.html#it">it</A> is
	contained in continue on the next line.  For example, a match with
	&quot;\\$&quot; (backslash at the end of the line) can make a region continue
	that would normally stop at the end of the line.  This is the default
	behavior.  If this is not wanted, there are two ways to avoid <A HREF="motion.html#it">it</A>:
	1. Use &quot;keepend&quot; for the containing item.  This will keep all
	   contained matches from extending the match or region.  It can be
	   used when all contained items must not extend the containing item.
	2. Use &quot;excludenl&quot; in the contained item.  This will keep that match
	   from extending the containing match or region.  It can be used if
	   only some contained items must not extend the containing item.
	   &quot;excludenl&quot; must be given before the <A HREF="pattern.html#pattern">pattern</A> <A HREF="motion.html#it">it</A> applies to.


							*<A NAME=":syn-matchgroup"></A><B>:syn-matchgroup</B>*
	&quot;matchgroup&quot; can be used to highlight the start and/or end <A HREF="pattern.html#pattern">pattern</A>
	differently than the body of the region.  Example:
<B>  :syntax region String matchgroup=Quote start=+"+  skip=+\\"+	end=+"+</B>
 	This will highlight the <A HREF="quotes.html#quotes">quotes</A> with the &quot;Quote&quot; group, and the text in
	between with the &quot;String&quot; group.
	The &quot;matchgroup&quot; is used for all start and end patterns that follow,
	until the next &quot;matchgroup&quot;.  Use &quot;matchgroup=NONE&quot; to go back to not
	using a matchgroup.

	In a start or end <A HREF="pattern.html#pattern">pattern</A> that is highlighted with &quot;matchgroup&quot; the
	contained items of the region are not used.  This can be used to avoid
	that a contained item matches in the start or end <A HREF="pattern.html#pattern">pattern</A> match.  When
	using &quot;transparent&quot;, this does not apply to a start or end <A HREF="pattern.html#pattern">pattern</A>
	match that is highlighted with &quot;matchgroup&quot;.

	Here is an example, which highlights three levels of parentheses in
	different colors:
<B>   :sy region par1 matchgroup=par1 start=/(/ end=/)/ contains=par2</B>
<B>   :sy region par2 matchgroup=par2 start=/(/ end=/)/ contains=par3 contained</B>
<B>   :sy region par3 matchgroup=par3 start=/(/ end=/)/ contains=par1 contained</B>
<B>   :hi par1 ctermfg=red guifg=red</B>
<B>   :hi par2 ctermfg=blue guifg=blue</B>
<B>   :hi par3 ctermfg=darkgreen guifg=darkgreen</B>
 

						*<A NAME="E849"></A><B>E849</B>*
The maximum number of <A HREF="#syntax">syntax</A> groups is 19999.

==============================================================================

6. <A HREF="#:syntax">:syntax</A> arguments					*<A NAME=":syn-arguments"></A><B>:syn-arguments</B>*

The <A HREF="#:syntax">:syntax</A> commands that define <A HREF="#syntax">syntax</A> items take a number of arguments.
The common ones are explained here.  The arguments may be given in any order
and may be mixed with patterns.

Not all commands accept all arguments.	This table shows which arguments
can not be used for all commands:

							*<A NAME="E395"></A><B>E395</B>*
<B><FONT COLOR="PURPLE">		    contains  oneline	fold  display  extend concealends</FONT></B>
<A HREF="#:syntax">:syntax</A> keyword		 -	 -	 -	 -	 -      -
<A HREF="#:syntax">:syntax</A> match		yes	 -	yes	yes	yes     -
<A HREF="#:syntax">:syntax</A> region		yes	yes	yes	yes	yes    yes

These arguments can be used for all three commands:
	<A HREF="#conceal">conceal</A>
	cchar
	contained
	containedin
	nextgroup
	transparent
	skipwhite
	skipnl
	skipempty


<A HREF="#conceal">conceal</A>						*<A NAME="conceal"></A><B>conceal</B>* *<A NAME=":syn-conceal"></A><B>:syn-conceal</B>*

When the &quot;<A HREF="#conceal">conceal</A>&quot; argument is given, the item is marked <A HREF="motion.html#as">as</A> concealable.
Whether or not <A HREF="motion.html#it">it</A> is actually concealed depends on the value of the
<A HREF="options.html#'conceallevel'">'conceallevel'</A> option.  The <A HREF="options.html#'concealcursor'">'concealcursor'</A> option is used to decide whether
concealable items in the current line are displayed unconcealed to be able to
edit the line.


concealends						*<A NAME=":syn-concealends"></A><B>:syn-concealends</B>*

When the &quot;concealends&quot; argument is given, the start and end matches of
the region, but not the contents of the region, are marked <A HREF="motion.html#as">as</A> concealable.
Whether or not they are actually concealed depends on the setting on the
<A HREF="options.html#'conceallevel'">'conceallevel'</A> option. The ends of a region can only be concealed separately
in this way when they have their own highlighting via &quot;matchgroup&quot;


cchar							*<A NAME=":syn-cchar"></A><B>:syn-cchar</B>*

							*<A NAME="E844"></A><B>E844</B>*
The &quot;cchar&quot; argument defines the character shown in place of the item
when <A HREF="motion.html#it">it</A> is concealed (setting &quot;cchar&quot; only makes sense when the <A HREF="#conceal">conceal</A>
argument is given.) If &quot;cchar&quot; is not set then the default <A HREF="#conceal">conceal</A>
character defined in the <A HREF="options.html#'listchars'">'listchars'</A> option is used.  The character cannot be
a <A HREF="intro.html#control">control</A> character such <A HREF="motion.html#as">as</A> <A HREF="intro.html#Tab">Tab</A>.  Example:
<B>   :syntax match Entity "&amp;amp;" conceal cchar=&amp;</B>
See |<A HREF="#hl-Conceal">hl-Conceal</A>| for highlighting.


contained						*<A NAME=":syn-contained"></A><B>:syn-contained</B>*

When the &quot;contained&quot; argument is given, this item will not be recognized at
the top level, but only when <A HREF="motion.html#it">it</A> is mentioned in the &quot;contains&quot; field of
another match.	Example:
<B>   :syntax keyword Todo    TODO    contained</B>
<B>   :syntax match   Comment "//.*"  contains=Todo</B>



display							*<A NAME=":syn-display"></A><B>:syn-display</B>*

If the &quot;display&quot; argument is given, this item will be skipped when the
detected highlighting will not be displayed.  This will speed up highlighting,
by skipping this item when only finding the <A HREF="#syntax">syntax</A> state for the text that is
to be displayed.

Generally, you can use &quot;display&quot; for match and region items that meet these
conditions:
- The item does not continue past the end of a line.  Example for C: A region
  for a &quot;/*&quot; comment can't contain &quot;display&quot;, because <A HREF="motion.html#it">it</A> continues on the next
  line.
- The item does not contain items that continue past the end of the line or
  make <A HREF="motion.html#it">it</A> continue on the next line.
- The item does not change the size of any item <A HREF="motion.html#it">it</A> is contained in.  Example
  for C: A match with &quot;\\$&quot; in a preprocessor match can't have &quot;display&quot;,
  because <A HREF="motion.html#it">it</A> may make that preprocessor match shorter.
- The item does not allow other items to match that didn't match otherwise,
  and that item may extend the match too far.  Example for C: A match for a
  &quot;<A HREF="version7.html#//">//</A>&quot; comment can't use &quot;display&quot;, because a &quot;/*&quot; inside that comment would
  match then and start a comment which extends past the end of the line.

Examples, for the C language, where &quot;display&quot; can be used:
- match with a number
- match with a label



transparent						*<A NAME=":syn-transparent"></A><B>:syn-transparent</B>*

If the &quot;transparent&quot; argument is given, this item will not be highlighted
itself, but will take the highlighting of the item <A HREF="motion.html#it">it</A> is contained in.	This
is useful for <A HREF="#syntax">syntax</A> items that don't need any highlighting but are used
only to skip over a part of the text.

The &quot;contains=&quot; argument is also inherited from the item <A HREF="motion.html#it">it</A> is contained in,
unless a &quot;contains&quot; argument is given for the transparent item itself.	To
avoid that unwanted items are contained, use &quot;contains=NONE&quot;.  Example, which
highlights words in strings, but makes an exception for &quot;vim&quot;:
<B>	:syn match myString /'[^']*'/ contains=myWord,myVim</B>
<B>	:syn match myWord   /\&lt;[a-z]*\&gt;/ contained</B>
<B>	:syn match myVim    /\&lt;vim\&gt;/ transparent contained contains=NONE</B>
<B>	:hi link myString String</B>
<B>	:hi link myWord   Comment</B>
Since the &quot;myVim&quot; match comes after &quot;myWord&quot; <A HREF="motion.html#it">it</A> is the preferred match (last
match in the same position overrules an earlier one).  The &quot;transparent&quot;
argument makes the &quot;myVim&quot; match use the same highlighting <A HREF="motion.html#as">as</A> &quot;myString&quot;.  But
<A HREF="motion.html#it">it</A> does not contain anything.  If the &quot;contains=NONE&quot; argument would be left
out, then &quot;myVim&quot; would use the contains argument from myString and allow
&quot;myWord&quot; to be contained, which will be highlighted <A HREF="motion.html#as">as</A> a Constant.  This
happens because a contained match doesn't match inside itself in the same
position, thus the &quot;myVim&quot; match doesn't overrule the &quot;myWord&quot; match here.

When you look at the colored text, <A HREF="motion.html#it">it</A> is like looking at layers of contained
items.	The contained item is on top of the item <A HREF="motion.html#it">it</A> is contained in, thus you
see the contained item.  When a contained item is transparent, you can look
through, thus you see the item <A HREF="motion.html#it">it</A> is contained in.  In a picture:

		look from here

	    &#124;	&#124;   &#124;	&#124;   &#124;	|
	    <A HREF="visual.html#V">V</A>	<A HREF="visual.html#V">V</A>   <A HREF="visual.html#V">V</A>	<A HREF="visual.html#V">V</A>   <A HREF="visual.html#V">V</A>	<A HREF="visual.html#V">V</A>

	       xxxx	  yyy		more contained items
	    ....................	contained item (transparent)
	=============================	first item

The '<A HREF="change.html#x">x</A>', '<A HREF="change.html#y">y</A>' and '<A HREF="change.html#=">=</A>' represent a highlighted <A HREF="#syntax">syntax</A> item.  The '<A HREF="repeat.html#.">.</A>' represent a
transparent group.

What you see is:

	=======xxxx=======yyy========

Thus you look through the transparent &quot;....&quot;.



oneline							*<A NAME=":syn-oneline"></A><B>:syn-oneline</B>*

The &quot;oneline&quot; argument indicates that the region does not cross a line
boundary.  It must match completely in the current line.  However, when the
region has a contained item that does cross a line boundary, <A HREF="motion.html#it">it</A> continues on
the next line anyway.  A contained item can be used to recognize a line
continuation <A HREF="pattern.html#pattern">pattern</A>.  But the &quot;end&quot; <A HREF="pattern.html#pattern">pattern</A> must still match in the first
line, otherwise the region doesn't even start.

When the start <A HREF="pattern.html#pattern">pattern</A> includes a &quot;\n&quot; to match an end-of-line, the end
<A HREF="pattern.html#pattern">pattern</A> must be found in the same line <A HREF="motion.html#as">as</A> where the start <A HREF="pattern.html#pattern">pattern</A> ends.  The
end <A HREF="pattern.html#pattern">pattern</A> may also include an end-of-line.  Thus the &quot;oneline&quot; argument
means that the end of the start <A HREF="pattern.html#pattern">pattern</A> and the start of the end <A HREF="pattern.html#pattern">pattern</A> must
be within one line.  This can't be changed by a skip <A HREF="pattern.html#pattern">pattern</A> that matches a
line break.



fold							*<A NAME=":syn-fold"></A><B>:syn-fold</B>*

The &quot;fold&quot; argument makes the fold level increase by one for this item.
Example:
<B>   :syn region myFold start="{" end="}" transparent fold</B>
<B>   :syn sync fromstart</B>
<B>   :set foldmethod=syntax</B>
This will make each <A HREF="intro.html#{}">{}</A> block form one fold.

The fold will start on the line where the item starts, and end where the item
ends.  If the start and end are within the same line, there is no fold.
The <A HREF="options.html#'foldnestmax'">'foldnestmax'</A> option <A HREF="vi_diff.html#limits">limits</A> the nesting of <A HREF="#syntax">syntax</A> <A HREF="fold.html#folds">folds</A>.
{not available when Vim was compiled without |<A HREF="various.html#+folding">+folding</A>| feature}



			*<A NAME=":syn-contains"></A><B>:syn-contains</B>* *<A NAME="E405"></A><B>E405</B>* *<A NAME="E406"></A><B>E406</B>* *<A NAME="E407"></A><B>E407</B>* *<A NAME="E408"></A><B>E408</B>* *<A NAME="E409"></A><B>E409</B>*
contains={groupname},..

The &quot;contains&quot; argument is followed by a list of <A HREF="#syntax">syntax</A> group names.  These
groups will be allowed to begin inside the item (they may extend past the
containing group's end).  This allows for recursive nesting of matches and
regions.  If there is no &quot;contains&quot; argument, no groups will be contained in
this item.  The group names <A HREF="diff.html#do">do</A> not need to be defined before they can be used
here.

contains=ALL
		If the only item in the contains list is &quot;ALL&quot;, then all
		groups will be accepted inside the item.

contains=ALLBUT,{group-name},..
		If the first item in the contains list is &quot;ALLBUT&quot;, then all
		groups will be accepted inside the item, except the ones that
		are listed.  Example:
<B>  :syntax region Block start="{" end="}" ... contains=ALLBUT,Function</B>

contains=TOP
		If the first item in the contains list is &quot;TOP&quot;, then all
		groups will be accepted that don't have the &quot;contained&quot;
		argument.
contains=TOP,{group-name},..
		Like &quot;TOP&quot;, but excluding the groups that are listed.

contains=CONTAINED
		If the first item in the contains list is &quot;CONTAINED&quot;, then
		all groups will be accepted that have the &quot;contained&quot;
		argument.
contains=CONTAINED,{group-name},..
		Like &quot;CONTAINED&quot;, but excluding the groups that are
		listed.


The <A HREF="#{group-name}">{group-name}</A> in the &quot;contains&quot; list can be a <A HREF="pattern.html#pattern">pattern</A>.  All group names
that match the <A HREF="pattern.html#pattern">pattern</A> will be included (or excluded, if &quot;ALLBUT&quot; is used).
The <A HREF="pattern.html#pattern">pattern</A> cannot contain white space or a '<A HREF="motion.html#,">,</A>'.  Example:
<B>   ... contains=Comment.*,Keyw[0-3]</B>
The matching will be done at moment the <A HREF="#syntax">syntax</A> command is executed.  Groups
that are defined later will not be matched.  Also, if the current <A HREF="#syntax">syntax</A>
command defines a new group, <A HREF="motion.html#it">it</A> is not matched.  Be careful: When putting
<A HREF="#syntax">syntax</A> commands in a file you can't rely on groups NOT being defined, because
the file may have been sourced before, and &quot;<A HREF="#:syn">:syn</A> clear&quot; doesn't remove the
group names.

The contained groups will also match in the start and end patterns of a
region.  If this is not wanted, the &quot;matchgroup&quot; argument can be used
|<A HREF="#:syn-matchgroup">:syn-matchgroup</A>|.  The &quot;ms=&quot; and &quot;me=&quot; offsets can be used to change the
region where contained items <A HREF="diff.html#do">do</A> match.	Note that this may also limit the
area that is highlighted



containedin={groupname}...				*<A NAME=":syn-containedin"></A><B>:syn-containedin</B>*

The &quot;containedin&quot; argument is followed by a list of <A HREF="#syntax">syntax</A> group names.  The
item will be allowed to begin inside these groups.  This works <A HREF="motion.html#as">as</A> if the
containing item has a &quot;contains=&quot; argument that includes this item.

The {groupname}... can be used just like for &quot;contains&quot;, <A HREF="motion.html#as">as</A> explained above.

This is useful when adding a <A HREF="#syntax">syntax</A> item afterwards.  An item can be told to
be included inside an already existing item, without <A HREF="change.html#changing">changing</A> the definition
of that item.  For example, to highlight a <A HREF="motion.html#word">word</A> in a C comment after loading
the C <A HREF="#syntax">syntax</A>:
<B>	:syn keyword myword HELP containedin=cComment contained</B>
Note that &quot;contained&quot; is also used, to avoid that the item matches at the top
level.

Matches for &quot;containedin&quot; are added to the other places where the item can
appear.  A &quot;contains&quot; argument may also be added <A HREF="motion.html#as">as</A> usual.  Don't forget that
keywords never contain another item, thus adding them to &quot;containedin&quot; won't
work.



nextgroup={groupname},..				*<A NAME=":syn-nextgroup"></A><B>:syn-nextgroup</B>*

The &quot;nextgroup&quot; argument is followed by a list of <A HREF="#syntax">syntax</A> group names,
separated by commas (just like with &quot;contains&quot;, so you can also use patterns).

If the &quot;nextgroup&quot; argument is given, the mentioned <A HREF="#syntax">syntax</A> groups will be
tried for a match, after the match or region ends.  If none of the groups have
a match, highlighting continues normally.  If there is a match, this group
will be used, even when <A HREF="motion.html#it">it</A> is not mentioned in the &quot;contains&quot; field of the
current group.	This is like giving the mentioned group priority over all
other groups.  Example:
<B>   :syntax match  ccFoobar  "Foo.\{-}Bar"  contains=ccFoo</B>
<B>   :syntax match  ccFoo     "Foo"	    contained nextgroup=ccFiller</B>
<B>   :syntax region ccFiller  start="."  matchgroup=ccBar  end="Bar"  contained</B>

This will highlight &quot;Foo&quot; and &quot;Bar&quot; differently, and only when there is a
&quot;Bar&quot; after &quot;Foo&quot;.  In the text line below, &quot;<A HREF="motion.html#f">f</A>&quot; shows where ccFoo is used for
highlighting, and &quot;bbb&quot; where ccBar is used.

<B>   Foo asdfasd Bar asdf Foo asdf Bar asdf</B>
<B>   fff	       bbb	fff	 bbb</B>

Note the use of &quot;.\{-}&quot; to skip <A HREF="motion.html#as">as</A> little <A HREF="motion.html#as">as</A> possible until the next Bar.
when &quot;.*&quot; would be used, the &quot;asdf&quot; in between &quot;Bar&quot; and &quot;Foo&quot; would be
highlighted according to the &quot;ccFoobar&quot; group, because the ccFooBar match
would include the first &quot;Foo&quot; and the last &quot;Bar&quot; in the line (see |<A HREF="pattern.html#pattern">pattern</A>|).



skipwhite						*<A NAME=":syn-skipwhite"></A><B>:syn-skipwhite</B>*

skipnl							*<A NAME=":syn-skipnl"></A><B>:syn-skipnl</B>*

skipempty						*<A NAME=":syn-skipempty"></A><B>:syn-skipempty</B>*

These arguments are only used in combination with &quot;nextgroup&quot;.	They can be
used to allow the next group to match after skipping some text:
	skipwhite	skip over space and <A HREF="intro.html#tab">tab</A> characters
	skipnl		skip over the end of a line
	skipempty	skip over empty lines (implies a &quot;skipnl&quot;)

When &quot;skipwhite&quot; is present, the white space is only skipped if there is no
next group that matches the white space.

When &quot;skipnl&quot; is present, the match with nextgroup may be found in the next
line.  This only happens when the current item ends at the end of the current
line!  When &quot;skipnl&quot; is not present, the nextgroup will only be found after
the current item in the same line.

When skipping text while looking for a next group, the matches for other
groups are ignored.  Only when no next group matches, other items are tried
for a match again.  This means that matching a next group and skipping white
space and &lt;EOL&gt;s has a higher priority than other items.

Example:
<B>  :syn match ifstart "\&lt;if.*"	  nextgroup=ifline skipwhite skipempty</B>
<B>  :syn match ifline  "[^ \t].*" nextgroup=ifline skipwhite skipempty contained</B>
<B>  :syn match ifline  "endif"	contained</B>
Note that the &quot;[^ \t].*&quot; match matches all non-white text.  Thus <A HREF="motion.html#it">it</A> would also
match &quot;endif&quot;.	Therefore the &quot;endif&quot; match is put last, so that <A HREF="motion.html#it">it</A> takes
precedence.
Note that this example doesn't work for nested &quot;if&quot;s.  You need to add
&quot;contains&quot; arguments to make that work (omitted for simplicity of the
example).


IMPLICIT CONCEAL					*<A NAME=":syn-conceal-implicit"></A><B>:syn-conceal-implicit</B>*

:sy[ntax] <A HREF="#conceal">conceal</A> [on|off]
	This defines if the following &quot;<A HREF="#:syntax">:syntax</A>&quot; commands will define keywords,
	matches or regions with the &quot;<A HREF="#conceal">conceal</A>&quot; flag set. After &quot;<A HREF="#:syn">:syn</A> <A HREF="#conceal">conceal</A>
	on&quot;, all subsequent &quot;<A HREF="#:syn">:syn</A> keyword&quot;, &quot;<A HREF="#:syn">:syn</A> match&quot; or &quot;<A HREF="#:syn">:syn</A> region&quot;
	defined will have the &quot;<A HREF="#conceal">conceal</A>&quot; flag set implicitly. &quot;<A HREF="#:syn">:syn</A> <A HREF="#conceal">conceal</A>
	off&quot; returns to the normal state where the &quot;<A HREF="#conceal">conceal</A>&quot; flag must be
	given explicitly.

==============================================================================

7. <A HREF="autocmd.html#Syntax">Syntax</A> patterns				*<A NAME=":syn-pattern"></A><B>:syn-pattern</B>* *<A NAME="E401"></A><B>E401</B>* *<A NAME="E402"></A><B>E402</B>*

In the <A HREF="#syntax">syntax</A> commands, a <A HREF="pattern.html#pattern">pattern</A> must be surrounded by two identical
characters.  This is like <A HREF="motion.html#it">it</A> works for the &quot;<A HREF="change.html#:s">:s</A>&quot; command.  The most common to
use is the double <A HREF="change.html#quote.">quote.</A>  But if the <A HREF="pattern.html#pattern">pattern</A> contains a double <A HREF="change.html#quote">quote</A>, you can
use another character that is not used in the <A HREF="pattern.html#pattern">pattern</A>.	Examples:
<B>  :syntax region Comment  start="/\*"  end="\*/"</B>
<B>  :syntax region String   start=+"+    end=+"+	 skip=+\\"+</B>

See |<A HREF="pattern.html#pattern">pattern</A>| for the explanation of what a pattern is.  <A HREF="autocmd.html#Syntax">Syntax</A> patterns are
always interpreted like the <A HREF="options.html#'magic'">'magic'</A> option is set, no matter what the actual
value of <A HREF="options.html#'magic'">'magic'</A> is.  And the patterns are interpreted like the '<A HREF="motion.html#l">l</A>' flag is
not included in <A HREF="options.html#'cpoptions'">'cpoptions'</A>.  This was done to make <A HREF="#syntax">syntax</A> files portable and
independent of <A HREF="options.html#'compatible'">'compatible'</A> and <A HREF="options.html#'magic'">'magic'</A> settings.

Try to avoid patterns that can match an empty string, such <A HREF="motion.html#as">as</A> &quot;[a-z]*&quot;.
This slows down the highlighting a lot, because <A HREF="motion.html#it">it</A> matches everywhere.


						*<A NAME=":syn-pattern-offset"></A><B>:syn-pattern-offset</B>*
The <A HREF="pattern.html#pattern">pattern</A> can be followed by a character offset.  This can be used to
change the highlighted part, and to change the text area included in the
match or region (which only matters when trying to match other items).	Both
are relative to the matched <A HREF="pattern.html#pattern">pattern</A>.  The character offset for a skip
<A HREF="pattern.html#pattern">pattern</A> can be used to tell where to continue looking for an end <A HREF="pattern.html#pattern">pattern</A>.

The offset takes the form of &quot;{what}={offset}&quot;
The {what} can be one of seven strings:

ms	Match Start	offset for the start of the matched text
me	Match End	offset for the end of the matched text
hs	Highlight Start	offset for where the highlighting starts
he	Highlight End	offset for where the highlighting ends
rs	Region Start	offset for where the body of a region starts
re	Region End	offset for where the body of a region ends
lc	Leading Context	offset past &quot;leading context&quot; of <A HREF="pattern.html#pattern">pattern</A>

The <A HREF="pattern.html#{offset}">{offset}</A> can be:

<A HREF="change.html#s">s</A>	start of the matched <A HREF="pattern.html#pattern">pattern</A>
s+{nr}	start of the matched <A HREF="pattern.html#pattern">pattern</A> plus {nr} chars to the right
s-{nr}	start of the matched <A HREF="pattern.html#pattern">pattern</A> plus {nr} chars to the left
<A HREF="motion.html#e">e</A>	end of the matched <A HREF="pattern.html#pattern">pattern</A>
e+{nr}	end of the matched <A HREF="pattern.html#pattern">pattern</A> plus {nr} chars to the right
e-{nr}	end of the matched <A HREF="pattern.html#pattern">pattern</A> plus {nr} chars to the left
{nr}	(for &quot;lc&quot; only): start matching {nr} chars right of the start

Examples: &quot;ms=s+1&quot;, &quot;hs=e-2&quot;, &quot;lc=3&quot;.

Although all offsets are accepted after any <A HREF="pattern.html#pattern">pattern</A>, they are not always
meaningful.  This table shows which offsets are actually used:

<B><FONT COLOR="PURPLE">		    ms	 me   hs   he	rs   re	  lc </FONT></B>
match item	    yes  yes  yes  yes	-    -	  yes
region item start   yes  -    yes  -	yes  -	  yes
region item skip    -	 yes  -    -	-    -	  yes
region item end     -	 yes  -    yes	-    yes  yes

Offsets can be concatenated, with a '<A HREF="motion.html#,">,</A>' in between.  Example:
<B>  :syn match String  /"[^"]*"/hs=s+1,he=e-1</B>
 
    some &quot;string&quot; text
	  ^^^^^^		highlighted

Notes:
- There must be no white space between the <A HREF="pattern.html#pattern">pattern</A> and the character
  offset(s).
- The highlighted area will never be outside of the matched text.
- A negative offset for an end <A HREF="pattern.html#pattern">pattern</A> may not always work, because the end
  <A HREF="pattern.html#pattern">pattern</A> may be detected when the highlighting should already have stopped.
- Before Vim 7.2 the offsets were counted in bytes instead of characters.
  This didn't work well for <A HREF="mbyte.html#multi-byte">multi-byte</A> characters, so <A HREF="motion.html#it">it</A> was changed with the
  Vim 7.2 release.
- The start of a match cannot be in a line other than where the <A HREF="pattern.html#pattern">pattern</A>
  matched.  This doesn't work: &quot;a\nb&quot;ms=e.  You can make the highlighting
  start in another line, this does work: &quot;a\nb&quot;hs=e.

Example (match a comment but don't highlight the /* and */):
<B>  :syntax region Comment start="/\*"hs=e+1 end="\*/"he=s-1</B>
 
	/* this is a comment */
	  ^^^^^^^^^^^^^^^^^^^	  highlighted

A more complicated Example:
<B>  :syn region Exa matchgroup=Foo start="foo"hs=s+2,rs=e+2 matchgroup=Bar end="bar"me=e-1,he=e-1,re=s-1</B>
 
	 abcfoostringbarabc
	    mmmmmmmmmmm	    match
	      sssrrreee	    highlight start/region/end (&quot;Foo&quot;, &quot;Exa&quot; and &quot;Bar&quot;)


Leading context			*<A NAME=":syn-lc"></A><B>:syn-lc</B>* *<A NAME=":syn-leading"></A><B>:syn-leading</B>* *<A NAME=":syn-context"></A><B>:syn-context</B>*

Note: This is an obsolete feature, only included for backwards compatibility
with previous Vim versions.  It's now recommended to use the |<A HREF="pattern.html#/\@&lt;=">/\@&lt;=</A>| construct
in the <A HREF="pattern.html#pattern">pattern</A>.

The &quot;lc&quot; offset specifies leading context <A HREF="starting.html#--">--</A> a part of the <A HREF="pattern.html#pattern">pattern</A> that must
be present, but is not considered part of the match.  An offset of &quot;lc=n&quot; will
cause Vim to step back <A HREF="pattern.html#n">n</A> columns before attempting the <A HREF="pattern.html#pattern">pattern</A> match, allowing
characters which have already been matched in previous patterns to also be
used <A HREF="motion.html#as">as</A> leading context for this match.  This can be used, for instance, to
specify that an &quot;escaping&quot; character must not precede the match:

<B>  :syn match ZNoBackslash "[^\\]z"ms=s+1</B>
<B>  :syn match WNoBackslash "[^\\]w"lc=1</B>
<B>  :syn match Underline "_\+"</B>
 
	  ___zzzz ___wwww
	  ^^^	  ^^^	  matches Underline
	      ^ ^	  matches ZNoBackslash
		     ^^^^ matches WNoBackslash

The &quot;ms&quot; offset is automatically set to the same value <A HREF="motion.html#as">as</A> the &quot;lc&quot; offset,
unless you set &quot;ms&quot; explicitly.



Multi-line patterns					*<A NAME=":syn-multi-line"></A><B>:syn-multi-line</B>*

The patterns can include &quot;\n&quot; to match an end-of-line.	Mostly this works <A HREF="motion.html#as">as</A>
expected, but there are a few exceptions.

When using a start <A HREF="pattern.html#pattern">pattern</A> with an offset, the start of the match is not
allowed to start in a following line.  The highlighting can start in a
following line though.  Using the &quot;\zs&quot; item also requires that the start of
the match doesn't move to another line.

The skip <A HREF="pattern.html#pattern">pattern</A> can include the &quot;\n&quot;, but the search for an end <A HREF="pattern.html#pattern">pattern</A> will
continue in the first character of the next line, also when that character is
matched by the skip <A HREF="pattern.html#pattern">pattern</A>.  This is because redrawing may start in any line
halfway a region and there is no check if the skip <A HREF="pattern.html#pattern">pattern</A> started in a
previous line.	For example, if the skip <A HREF="pattern.html#pattern">pattern</A> is &quot;a\nb&quot; and an end <A HREF="pattern.html#pattern">pattern</A>
is &quot;<A HREF="motion.html#b">b</A>&quot;, the end <A HREF="pattern.html#pattern">pattern</A> does match in the second line of this:
<B>	 x x a</B>
<B>	 b x x</B>
Generally this means that the skip <A HREF="pattern.html#pattern">pattern</A> should not match any characters
after the &quot;\n&quot;.



External matches					*<A NAME=":syn-ext-match"></A><B>:syn-ext-match</B>*

These extra regular <A HREF="eval.html#expression">expression</A> items are available in region patterns:


					*<A NAME="/\z("></A><B>/\z(</B>* *<A NAME="/\z(\)"></A><B>/\z(\)</B>* *<A NAME="E50"></A><B>E50</B>* *<A NAME="E52"></A><B>E52</B>* *<A NAME="E879"></A><B>E879</B>*
    \z(\)	Marks the sub-expression <A HREF="motion.html#as">as</A> &quot;external&quot;, meaning that <A HREF="motion.html#it">it</A> can be
		accessed from another <A HREF="pattern.html#pattern">pattern</A> match.  Currently only usable in
		defining a <A HREF="#syntax">syntax</A> region start <A HREF="pattern.html#pattern">pattern</A>.


					*<A NAME="/\z1"></A><B>/\z1</B>* *<A NAME="/\z2"></A><B>/\z2</B>* *<A NAME="/\z3"></A><B>/\z3</B>* *<A NAME="/\z4"></A><B>/\z4</B>* *<A NAME="/\z5"></A><B>/\z5</B>*

    \z1  <A HREF="eval.html#...">...</A>  \z9			*<A NAME="/\z6"></A><B>/\z6</B>* *<A NAME="/\z7"></A><B>/\z7</B>* *<A NAME="/\z8"></A><B>/\z8</B>* *<A NAME="/\z9"></A><B>/\z9</B>* *<A NAME="E66"></A><B>E66</B>* *<A NAME="E67"></A><B>E67</B>*
		Matches the same string that was matched by the corresponding
		sub-expression in a previous start <A HREF="pattern.html#pattern">pattern</A> match.

Sometimes the start and end patterns of a region need to share a common
sub-expression.  A common example is the &quot;here&quot; document in <A HREF="if_perl.html#Perl">Perl</A> and many <A HREF="os_unix.html#Unix">Unix</A>
shells.  This effect can be achieved with the &quot;\z&quot; special regular <A HREF="eval.html#expression">expression</A>
items, which marks a sub-expression <A HREF="motion.html#as">as</A> &quot;external&quot;, in the sense that <A HREF="motion.html#it">it</A> can be
referenced from outside the <A HREF="pattern.html#pattern">pattern</A> in which <A HREF="motion.html#it">it</A> is defined.  The here-document
example, for instance, can be done like this:
<B>  :syn region hereDoc start="&lt;&lt;\z(\I\i*\)" end="^\z1$"</B>

As can be seen here, the \z actually does double duty.	In the start <A HREF="pattern.html#pattern">pattern</A>,
<A HREF="motion.html#it">it</A> marks the &quot;\(\I\i*\)&quot; sub-expression <A HREF="motion.html#as">as</A> external; in the end <A HREF="pattern.html#pattern">pattern</A>, <A HREF="motion.html#it">it</A>
changes the \1 back-reference into an external reference referring to the
first external sub-expression in the start <A HREF="pattern.html#pattern">pattern</A>.  External references can
also be used in skip patterns:
<B>  :syn region foo start="start \(\I\i*\)" skip="not end \z1" end="end \z1"</B>

Note that normal and external sub-expressions are completely orthogonal and
indexed separately; for instance, if the <A HREF="pattern.html#pattern">pattern</A> &quot;\z(..\)\(..\)&quot; is applied
to the string &quot;aabb&quot;, then \1 will refer to &quot;bb&quot; and \z1 will refer to &quot;aa&quot;.
Note also that external sub-expressions cannot be accessed <A HREF="motion.html#as">as</A> back-references
within the same <A HREF="pattern.html#pattern">pattern</A> like normal sub-expressions.  If you want to use one
sub-expression <A HREF="motion.html#as">as</A> both a normal and an external sub-expression, you can nest
the two, <A HREF="motion.html#as">as</A> in &quot;\(\z(...\)\)&quot;.

Note that only matches within a single line can be used.  Multi-line matches
cannot be referred to.

==============================================================================

8. <A HREF="autocmd.html#Syntax">Syntax</A> clusters					*<A NAME=":syn-cluster"></A><B>:syn-cluster</B>* *<A NAME="E400"></A><B>E400</B>*

:sy[ntax] cluster {cluster-name} [contains={group-name}..]
				 [add={group-name}..]
				 [remove={group-name}..]

This command allows you to cluster a list of <A HREF="#syntax">syntax</A> groups together under a
single name.

	contains={group-name}..
		The cluster is set to the specified list of groups.
	add={group-name}..
		The specified groups are added to the cluster.
	remove={group-name}..
		The specified groups are removed from the cluster.

A cluster so defined may be referred to in a contains=.., containedin=..,
nextgroup=.., add=..  or remove=.. list with a &quot;<A HREF="repeat.html#@">@</A>&quot; prefix.  You can also use
this <A HREF="intro.html#notation">notation</A> to implicitly declare a cluster before specifying its contents.

Example:
<B>   :syntax match Thing "# [^#]\+ #" contains=@ThingMembers</B>
<B>   :syntax cluster ThingMembers contains=ThingMember1,ThingMember2</B>

As the previous example suggests, modifications to a cluster are effectively
retroactive; the membership of the cluster is checked at the last minute, so
to speak:
<B>   :syntax keyword A aaa</B>
<B>   :syntax keyword B bbb</B>
<B>   :syntax cluster AandB contains=A</B>
<B>   :syntax match Stuff "( aaa bbb )" contains=@AandB</B>
<B>   :syntax cluster AandB add=B	  " now both keywords are matched in Stuff</B>

This also has implications for nested clusters:
<B>   :syntax keyword A aaa</B>
<B>   :syntax keyword B bbb</B>
<B>   :syntax cluster SmallGroup contains=B</B>
<B>   :syntax cluster BigGroup contains=A,@SmallGroup</B>
<B>   :syntax match Stuff "( aaa bbb )" contains=@BigGroup</B>
<B>   :syntax cluster BigGroup remove=B	" no effect, since B isn't in BigGroup</B>
<B>   :syntax cluster SmallGroup remove=B	" now bbb isn't matched within Stuff</B>
 

						*<A NAME="E848"></A><B>E848</B>*
The maximum number of clusters is 9767.

==============================================================================

9. Including <A HREF="#syntax">syntax</A> files				*<A NAME=":syn-include"></A><B>:syn-include</B>* *<A NAME="E397"></A><B>E397</B>*

It is often useful for one language's <A HREF="#syntax">syntax</A> file to include a <A HREF="#syntax">syntax</A> file for
a related language.  Depending on the exact relationship, this can be done in
two different ways:

	- If top-level <A HREF="#syntax">syntax</A> items in the included <A HREF="#syntax">syntax</A> file are to be
	  allowed at the top level in the including <A HREF="#syntax">syntax</A>, you can simply use
	  the |<A HREF="repeat.html#:runtime">:runtime</A>| command:

<B>  " In cpp.vim:</B>
<B>  :runtime! syntax/c.vim</B>
<B>  :unlet b:current_syntax</B>

 	- If top-level <A HREF="#syntax">syntax</A> items in the included <A HREF="#syntax">syntax</A> file are to be
	  contained within a region in the including <A HREF="#syntax">syntax</A>, you can use the
	  &quot;<A HREF="#:syntax">:syntax</A> include&quot; command:

:sy[ntax] include [@{grouplist-name}] {file-name}

	  All <A HREF="#syntax">syntax</A> items declared in the included file will have the
	  &quot;contained&quot; flag added.  In addition, if a group list is specified,
	  all top-level <A HREF="#syntax">syntax</A> items in the included file will be added to
	  that list.

<B>   " In perl.vim:</B>
<B>   :syntax include @Pod &lt;sfile&gt;:p:h/pod.vim</B>
<B>   :syntax region perlPOD start="^=head" end="^=cut" contains=@Pod</B>
 
	  When {file-name} is an absolute path (starts with &quot;<A HREF="pattern.html#/">/</A>&quot;, &quot;c:&quot;, &quot;$VAR&quot;
	  or &quot;<A HREF="cmdline.html#&lt;sfile&gt;">&lt;sfile&gt;</A>&quot;) that file is sourced.  When <A HREF="motion.html#it">it</A> is a relative path
	  (e.g., &quot;syntax/pod.vim&quot;) the file is searched for in <A HREF="options.html#'runtimepath'">'runtimepath'</A>.
	  All matching files are loaded.  Using a relative path is
	  recommended, because <A HREF="motion.html#it">it</A> allows a user to replace the included file
	  with his own version, without <A HREF="change.html#replacing">replacing</A> the file that does the &quot;<A HREF="#:syn">:syn</A>
	  include&quot;.


						*<A NAME="E847"></A><B>E847</B>*
The maximum number of includes is 999.

==============================================================================

10. Synchronizing				*<A NAME=":syn-sync"></A><B>:syn-sync</B>* *<A NAME="E403"></A><B>E403</B>* *<A NAME="E404"></A><B>E404</B>*

Vim wants to be able to start redrawing in any position in the document.  To
make this possible <A HREF="motion.html#it">it</A> needs to know the <A HREF="#syntax">syntax</A> state at the position where
redrawing starts.

:sy[ntax] sync [ccomment [group-name] &#124; minlines={N} &#124; ...]

There are four ways to synchronize:
1. Always parse from the start of the file.
   |<A HREF="#:syn-sync-first">:syn-sync-first</A>|
2. Based on C-style comments.  Vim understands how C-comments work and can
   figure out if the current line starts inside or outside a comment.
   |<A HREF="#:syn-sync-second">:syn-sync-second</A>|
3. Jumping back a certain number of lines and start parsing there.
   |<A HREF="#:syn-sync-third">:syn-sync-third</A>|
4. Searching backwards in the text for a <A HREF="pattern.html#pattern">pattern</A> to sync on.
   |<A HREF="#:syn-sync-fourth">:syn-sync-fourth</A>|


				*<A NAME=":syn-sync-maxlines"></A><B>:syn-sync-maxlines</B>* *<A NAME=":syn-sync-minlines"></A><B>:syn-sync-minlines</B>*
For the last three methods, the line range where the parsing can start is
limited by &quot;minlines&quot; and &quot;maxlines&quot;.

If the &quot;minlines={N}&quot; argument is given, the parsing always starts at least
that many lines backwards.  This can be used if the parsing may take a few
lines before it's correct, or when it's not possible to use syncing.

If the &quot;maxlines={N}&quot; argument is given, the number of lines that are searched
for a comment or syncing <A HREF="pattern.html#pattern">pattern</A> is restricted to N lines backwards (after
adding &quot;minlines&quot;).  This is useful if you have few things to sync on and a
slow machine.  Example:
<B>   :syntax sync ccomment maxlines=500</B>
 

						*<A NAME=":syn-sync-linebreaks"></A><B>:syn-sync-linebreaks</B>*
When using a <A HREF="pattern.html#pattern">pattern</A> that matches multiple lines, a change in one line may
cause a <A HREF="pattern.html#pattern">pattern</A> to no longer match in a previous line.	This means has to
start above where the change was made.	How many lines can be specified with
the &quot;linebreaks&quot; argument.  For example, when a <A HREF="pattern.html#pattern">pattern</A> may include one line
break use this:
<B>   :syntax sync linebreaks=1</B>
The result is that redrawing always starts at least one line before where a
change was made.  The default value for &quot;linebreaks&quot; is zero.  Usually the
value for &quot;minlines&quot; is bigger than &quot;linebreaks&quot;.



First syncing method:			*<A NAME=":syn-sync-first"></A><B>:syn-sync-first</B>*

<B>   :syntax sync fromstart</B>

The file will be parsed from the start.  This makes <A HREF="#syntax">syntax</A> highlighting
accurate, but can be slow for long files.  Vim caches previously parsed text,
so that it's only slow when parsing the text for the first time.  However,
when making changes some part of the text needs to be parsed again (worst
<A HREF="change.html#case">case</A>: to the end of the file).

Using &quot;fromstart&quot; is equivalent to using &quot;minlines&quot; with a very large number.



Second syncing method:			*<A NAME=":syn-sync-second"></A><B>:syn-sync-second</B>* *<A NAME=":syn-sync-ccomment"></A><B>:syn-sync-ccomment</B>*

For the second method, only the &quot;ccomment&quot; argument needs to be given.
Example:
<B>   :syntax sync ccomment</B>

When Vim finds that the line where displaying starts is inside a C-style
comment, the last region <A HREF="#syntax">syntax</A> item with the <A HREF="#group-name">group-name</A> &quot;Comment&quot; will be
used.  This requires that there is a region with the <A HREF="#group-name">group-name</A> &quot;Comment&quot;!
An alternate group name can be specified, for example:
<B>   :syntax sync ccomment javaComment</B>
This means that the last item specified with &quot;syn region javaComment&quot; will be
used for the detected C comment region.  This only works properly if that
region does have a start <A HREF="pattern.html#pattern">pattern</A> &quot;\/*&quot; and an end <A HREF="pattern.html#pattern">pattern</A> &quot;*\/&quot;.

The &quot;maxlines&quot; argument can be used to restrict the search to a number of
lines.	The &quot;minlines&quot; argument can be used to at least start a number of
lines back (e.g., for when there is some construct that only takes a few
lines, but <A HREF="motion.html#it">it</A> hard to sync on).

Note: Syncing on a C comment doesn't work properly when strings are used
that cross a line and contain a &quot;*/&quot;.  Since letting strings cross a line
is a bad programming habit (many compilers give a warning message), and the
chance of a &quot;*/&quot; appearing inside a comment is very small, this restriction
is hardly ever noticed.



Third syncing method:				*<A NAME=":syn-sync-third"></A><B>:syn-sync-third</B>*

For the third method, only the &quot;minlines={N}&quot; argument needs to be given.
Vim will subtract {N} from the line number and start parsing there.  This
means {N} extra lines need to be parsed, which makes this method a bit slower.
Example:
<B>   :syntax sync minlines=50</B>

&quot;lines&quot; is equivalent to &quot;minlines&quot; (used by older versions).



Fourth syncing method:				*<A NAME=":syn-sync-fourth"></A><B>:syn-sync-fourth</B>*

The idea is to synchronize on the end of a few specific regions, called a
sync <A HREF="pattern.html#pattern">pattern</A>.  Only regions can cross lines, so when we find the end of some
region, we might be able to know in which <A HREF="#syntax">syntax</A> item we are.  The search
starts in the line just above the one where redrawing starts.  From there
the search continues backwards in the file.

This works just like the non-syncing <A HREF="#syntax">syntax</A> items.  You can use contained
matches, nextgroup, etc.  But there are a few differences:
- Keywords cannot be used.
- The <A HREF="#syntax">syntax</A> items with the &quot;sync&quot; keyword form a completely separated group
  of <A HREF="#syntax">syntax</A> items.  You can't mix syncing groups and non-syncing groups.
- The matching works backwards in the buffer (line by line), instead of
  forwards.
- A line continuation <A HREF="pattern.html#pattern">pattern</A> can be given.  It is used to decide which group
  of lines need to be searched like they were one line.  This means that the
  search for a match with the specified items starts in the first of the
  consecutive that contain the continuation <A HREF="pattern.html#pattern">pattern</A>.
- When using &quot;nextgroup&quot; or &quot;contains&quot;, this only works within one line (or
  group of continued lines).
- When using a region, <A HREF="motion.html#it">it</A> must start and end in the same line (or group of
  continued lines).  Otherwise the end is assumed to be at the end of the
  line (or group of continued lines).
- When a match with a sync <A HREF="pattern.html#pattern">pattern</A> is found, the rest of the line (or group of
  continued lines) is searched for another match.  The last match is used.
  This is used when a line can contain both the start end the end of a region
  (e.g., in a C-comment like /* this */, the last &quot;*/&quot; is used).

There are two ways how a match with a sync <A HREF="pattern.html#pattern">pattern</A> can be used:
1. Parsing for highlighting starts where redrawing starts (and where the
   search for the sync <A HREF="pattern.html#pattern">pattern</A> started).  The <A HREF="#syntax">syntax</A> group that is expected
   to be valid there must be specified.  This works well when the regions
   that cross lines cannot contain other regions.
2. Parsing for highlighting continues just after the match.  The <A HREF="#syntax">syntax</A> group
   that is expected to be present just after the match must be specified.
   This can be used when the previous method doesn't work well.  It's much
   slower, because more text needs to be parsed.
Both types of sync patterns can be used at the same time.

Besides the sync patterns, other matches and regions can be specified, to
avoid finding unwanted matches.

[The reason that the sync patterns are given separately, is that mostly the
search for the sync point can be much simpler than figuring out the
highlighting.  The reduced number of patterns means <A HREF="motion.html#it">it</A> will go (much)
faster.]


					    *<A NAME="syn-sync-grouphere"></A><B>syn-sync-grouphere</B>* *<A NAME="E393"></A><B>E393</B>* *<A NAME="E394"></A><B>E394</B>*
    <A HREF="#:syntax">:syntax</A> sync match {sync-group-name} grouphere <A HREF="#{group-name}">{group-name}</A> &quot;<A HREF="pattern.html#pattern">pattern</A>&quot; ..

	Define a match that is used for syncing.  <A HREF="#{group-name}">{group-name}</A> is the
	name of a <A HREF="#syntax">syntax</A> group that follows just after the match.  Parsing
	of the text for highlighting starts just after the match.  A region
	must exist for this <A HREF="#{group-name}">{group-name}</A>.  The first one defined will be used.
	&quot;NONE&quot; can be used for when there is no <A HREF="#syntax">syntax</A> group after the match.


						*<A NAME="syn-sync-groupthere"></A><B>syn-sync-groupthere</B>*
    <A HREF="#:syntax">:syntax</A> sync match {sync-group-name} groupthere <A HREF="#{group-name}">{group-name}</A> &quot;<A HREF="pattern.html#pattern">pattern</A>&quot; ..

	Like &quot;grouphere&quot;, but <A HREF="#{group-name}">{group-name}</A> is the name of a <A HREF="#syntax">syntax</A> group that
	is to be used at the start of the line where searching for the sync
	point started.	The text between the match and the start of the sync
	<A HREF="pattern.html#pattern">pattern</A> searching is assumed not to change the <A HREF="#syntax">syntax</A> highlighting.
	For example, in C you could search backwards for &quot;/*&quot; and &quot;*/&quot;.  If
	&quot;/*&quot; is found first, you know that you are inside a comment, so the
	&quot;groupthere&quot; is &quot;cComment&quot;.  If &quot;*/&quot; is found first, you know that you
	are not in a comment, so the &quot;groupthere&quot; is &quot;NONE&quot;.  (in practice
	it's a bit more complicated, because the &quot;/*&quot; and &quot;*/&quot; could appear
	inside a string.  That's left <A HREF="motion.html#as">as</A> an exercise to the reader...).

    <A HREF="#:syntax">:syntax</A> sync match ..
    <A HREF="#:syntax">:syntax</A> sync region ..

	Without a &quot;groupthere&quot; argument.  Define a region or match that is
	skipped while searching for a sync point.


						*<A NAME="syn-sync-linecont"></A><B>syn-sync-linecont</B>*
    <A HREF="#:syntax">:syntax</A> sync linecont {pattern}

	When {pattern} matches in a line, <A HREF="motion.html#it">it</A> is considered to continue in
	the next line.	This means that the search for a sync point will
	consider the lines to be concatenated.

If the &quot;maxlines={N}&quot; argument is given too, the number of lines that are
searched for a match is restricted to N.  This is useful if you have very
few things to sync on and a slow machine.  Example:
<B>   :syntax sync maxlines=100</B>

You can clear all sync settings with:
<B>   :syntax sync clear</B>

You can clear specific sync patterns with:
<B>   :syntax sync clear {sync-group-name} ..</B>

==============================================================================

11. Listing <A HREF="#syntax">syntax</A> items		*<A NAME=":syntax"></A><B>:syntax</B>* *<A NAME=":sy"></A><B>:sy</B>* *<A NAME=":syn"></A><B>:syn</B>* *<A NAME=":syn-list"></A><B>:syn-list</B>*

This command lists all the <A HREF="#syntax">syntax</A> items:

<B>    :sy[ntax] [list]</B>

To show the <A HREF="#syntax">syntax</A> items for one <A HREF="#syntax">syntax</A> group:

<B>    :sy[ntax] list {group-name}</B>


To list the <A HREF="#syntax">syntax</A> groups in one cluster:			*<A NAME="E392"></A><B>E392</B>*	

<B>    :sy[ntax] list @{cluster-name}</B>

See above for other arguments for the &quot;<A HREF="#:syntax">:syntax</A>&quot; command.

Note that the &quot;<A HREF="#:syntax">:syntax</A>&quot; command can be abbreviated to &quot;<A HREF="#:sy">:sy</A>&quot;, although &quot;<A HREF="#:syn">:syn</A>&quot;
is mostly used, because <A HREF="motion.html#it">it</A> looks better.

==============================================================================

12. Highlight command			*<A NAME=":highlight"></A><B>:highlight</B>* *<A NAME=":hi"></A><B>:hi</B>* *<A NAME="E28"></A><B>E28</B>* *<A NAME="E411"></A><B>E411</B>* *<A NAME="E415"></A><B>E415</B>*

There are three types of highlight groups:
- The ones used for specific languages.  For these the name starts with the
  name of the language.  Many of these don't have any attributes, but are
  linked to a group of the second type.
- The ones used for all <A HREF="#syntax">syntax</A> languages.
- The ones used for the <A HREF="options.html#'highlight'">'highlight'</A> option.

							*<A NAME="hitest.vim"></A><B>hitest.vim</B>*
You can see all the groups currently active with this command:
<B>    :so $VIMRUNTIME/syntax/hitest.vim</B>
This will open a new <A HREF="windows.html#window">window</A> containing all highlight group names, displayed
in their own color.


						*<A NAME=":colo"></A><B>:colo</B>* *<A NAME=":colorscheme"></A><B>:colorscheme</B>* *<A NAME="E185"></A><B>E185</B>*
:colo[rscheme]		Output the name of the currently active color scheme.
			This is basically the same <A HREF="motion.html#as">as</A>
<B>				:echo g:colors_name</B>
 			In <A HREF="change.html#case">case</A> <A HREF="options.html#g:colors_name">g:colors_name</A> has not been defined <A HREF="#:colo">:colo</A> will
			output &quot;default&quot;.  When compiled without the |<A HREF="various.html#+eval">+eval</A>|
			feature <A HREF="motion.html#it">it</A> will output &quot;unknown&quot;.

:colo[rscheme] {name}	Load color scheme {name}.  This searches <A HREF="options.html#'runtimepath'">'runtimepath'</A>
			for the file &quot;colors/{name}.vim&quot;.  The first one that
			is found is loaded.
			To see the name of the currently active color scheme:
<B>				:colo</B>
 			The name is also stored in the <A HREF="options.html#g:colors_name">g:colors_name</A> variable.
			Doesn't work recursively, thus you can't use
			&quot;<A HREF="#:colorscheme">:colorscheme</A>&quot; in a color scheme <A HREF="usr_41.html#script">script</A>.
			After the color scheme has been loaded the
			|<A HREF="autocmd.html#ColorScheme">ColorScheme</A>| <A HREF="autocmd.html#autocommand">autocommand</A> event is triggered.
			For info about <A HREF="editing.html#writing">writing</A> a colorscheme file:
<B>				:edit $VIMRUNTIME/colors/README.txt</B>

:hi[ghlight]		<A HREF="eval.html#List">List</A> all the current highlight groups that have
			attributes set.

:hi[ghlight] <A HREF="#{group-name}">{group-name}</A>
			<A HREF="eval.html#List">List</A> one highlight group.

:hi[ghlight] clear	Reset all highlighting to the defaults.  Removes all
			highlighting for groups added by the user!
			Uses the current value of <A HREF="options.html#'background'">'background'</A> to decide which
			default colors to use.

:hi[ghlight] clear <A HREF="#{group-name}">{group-name}</A>
:hi[ghlight] <A HREF="#{group-name}">{group-name}</A> NONE
			Disable the highlighting for one highlight group.  It
			is _not_ set back to the default colors.

:hi[ghlight] [default] <A HREF="#{group-name}">{group-name}</A> {key}={arg} ..
			Add a highlight group, or change the highlighting for
			an existing group.
			See |<A HREF="#highlight-args">highlight-args</A>| for the {key}={arg} arguments.
			See |<A HREF="#:highlight-default">:highlight-default</A>| for the optional [default]
			argument.

Normally a highlight group is added once when starting up.  This sets the
default values for the highlighting.  After that, you can use additional
highlight commands to change the arguments that you want to set to non-default
values.  The value &quot;NONE&quot; can be used to switch the value off or go back to
the default value.

A simple way to change colors is with the |<A HREF="#:colorscheme">:colorscheme</A>| command.  This loads
a file with &quot;<A HREF="#:highlight">:highlight</A>&quot; commands such <A HREF="motion.html#as">as</A> this:

<B>   :hi Comment	gui=bold</B>

Note that all settings that are not included remain the same, only the
specified field is used, and settings are merged with previous ones.  So, the
result is like this single command has been used:
<B>   :hi Comment	term=bold ctermfg=Cyan guifg=#80a0ff gui=bold</B>
 

							*<A NAME=":highlight-verbose"></A><B>:highlight-verbose</B>*
When listing a highlight group and <A HREF="options.html#'verbose'">'verbose'</A> is non-zero, the listing will
also tell where <A HREF="motion.html#it">it</A> was last set.  Example:
<B>	:verbose hi Comment</B>
<B><FONT COLOR="PURPLE"> 	Comment        xxx term=bold ctermfg=4 guifg=Blue </FONT></B>
<B><FONT COLOR="PURPLE">	   Last set from /home/mool/vim/vim7/runtime/syntax/syncolor.vim </FONT></B>

When &quot;<A HREF="#:hi">:hi</A> clear&quot; is used then the <A HREF="usr_41.html#script">script</A> where this command is used will be
mentioned for the default values. See |<A HREF="various.html#:verbose-cmd">:verbose-cmd</A>| for more information.


					*<A NAME="highlight-args"></A><B>highlight-args</B>* *<A NAME="E416"></A><B>E416</B>* *<A NAME="E417"></A><B>E417</B>* *<A NAME="E423"></A><B>E423</B>*
There are three types of terminals for highlighting:
term	a normal terminal (vt100, xterm)
cterm	a color terminal (MS-DOS console, <A HREF="#color-xterm">color-xterm</A>, these have the &quot;Co&quot;
	<A HREF="term.html#termcap">termcap</A> entry)
<A HREF="gui.html#gui">gui</A>	the <A HREF="gui.html#GUI">GUI</A>

For each type the highlighting can be given.  This makes <A HREF="motion.html#it">it</A> possible to use
the same <A HREF="#syntax">syntax</A> file on all terminals, and use the optimal highlighting.

1. highlight arguments for normal terminals


					*<A NAME="bold"></A><B>bold</B>* *<A NAME="underline"></A><B>underline</B>* *<A NAME="undercurl"></A><B>undercurl</B>*

					*<A NAME="inverse"></A><B>inverse</B>* *<A NAME="italic"></A><B>italic</B>* *<A NAME="standout"></A><B>standout</B>*

term={attr-list}			*<A NAME="attr-list"></A><B>attr-list</B>* *<A NAME="highlight-term"></A><B>highlight-term</B>* *<A NAME="E418"></A><B>E418</B>*
	<A HREF="#attr-list">attr-list</A> is a comma separated list (without spaces) of the
	following items (in any order):
		<A HREF="#bold">bold</A>
		<A HREF="#underline">underline</A>
		<A HREF="#undercurl">undercurl</A>	not always available
		reverse
		<A HREF="#inverse">inverse</A>		same <A HREF="motion.html#as">as</A> reverse
		<A HREF="#italic">italic</A>
		<A HREF="#standout">standout</A>
		NONE		no attributes used (used to reset <A HREF="motion.html#it">it</A>)

	Note that &quot;<A HREF="#bold">bold</A>&quot; can be used here and by using a <A HREF="#bold">bold</A> font.  They
	have the same effect.
	&quot;<A HREF="#undercurl">undercurl</A>&quot; is a curly <A HREF="#underline">underline</A>.  When &quot;<A HREF="#undercurl">undercurl</A>&quot; is not possible
	then &quot;<A HREF="#underline">underline</A>&quot; is used.  In general &quot;<A HREF="#undercurl">undercurl</A>&quot; is only available in
	the <A HREF="gui.html#GUI">GUI</A>.  The color is set with |<A HREF="#highlight-guisp">highlight-guisp</A>|.


start={term-list}				*<A NAME="highlight-start"></A><B>highlight-start</B>* *<A NAME="E422"></A><B>E422</B>*

stop={term-list}				*<A NAME="term-list"></A><B>term-list</B>* *<A NAME="highlight-stop"></A><B>highlight-stop</B>*
	These lists of terminal codes can be used to get
	non-standard attributes on a terminal.

	The <A HREF="intro.html#escape">escape</A> sequence specified with the &quot;start&quot; argument
	is written before the characters in the highlighted
	area.  It can be anything that you want to send to the
	terminal to highlight this area.  The <A HREF="intro.html#escape">escape</A> sequence
	specified with the &quot;stop&quot; argument is written after the
	highlighted area.  This should <A HREF="undo.html#undo">undo</A> the &quot;start&quot; argument.
	Otherwise the screen will look messed up.

	The {term-list} can have two forms:

	1. A string with <A HREF="intro.html#escape">escape</A> sequences.
	   This is any string of characters, except that <A HREF="motion.html#it">it</A> can't start with
	   &quot;t_&quot; and blanks are not allowed.  The <A HREF="intro.html#&lt;&gt;">&lt;&gt;</A> <A HREF="intro.html#notation">notation</A> is recognized
	   here, so you can use things like &quot;<A HREF="intro.html#&lt;Esc&gt;">&lt;Esc&gt;</A>&quot; and &quot;<A HREF="motion.html#&lt;Space&gt;">&lt;Space&gt;</A>&quot;.  Example:
		start=&lt;Esc&gt;[27h;&lt;Esc&gt;[&lt;Space&gt;r;

	2. A list of terminal codes.
	   Each terminal code has the form &quot;t_xx&quot;, where &quot;xx&quot; is the name of
	   the <A HREF="term.html#termcap">termcap</A> entry.  The codes have to be separated with commas.
	   White space is not allowed.	Example:
		start=t_C1,t_BL
	   The terminal codes must exist for this to work.


2. highlight arguments for color terminals


cterm={attr-list}					*<A NAME="highlight-cterm"></A><B>highlight-cterm</B>*
	See above for the description of {attr-list} |<A HREF="#attr-list">attr-list</A>|.
	The &quot;cterm&quot; argument is likely to be different from &quot;term&quot;, when
	colors are used.  For example, in a normal terminal comments could
	be underlined, in a color terminal they can be made Blue.
	Note: Many terminals (e.g., <A HREF="os_dos.html#DOS">DOS</A> console) can't mix these attributes
	with <A HREF="#coloring">coloring</A>.	Use only one of &quot;cterm=&quot; OR &quot;ctermfg=&quot; OR &quot;ctermbg=&quot;.


ctermfg={color-nr}				*<A NAME="highlight-ctermfg"></A><B>highlight-ctermfg</B>* *<A NAME="E421"></A><B>E421</B>*

ctermbg={color-nr}				*<A NAME="highlight-ctermbg"></A><B>highlight-ctermbg</B>*
	The {color-nr} argument is a color number.  Its range is zero to
	(not including) the number given by the <A HREF="term.html#termcap">termcap</A> entry &quot;Co&quot;.
	The actual color with this number depends on the type of terminal
	and its settings.  Sometimes the color also depends on the settings of
	&quot;cterm&quot;.  For example, on some systems &quot;cterm=bold ctermfg=3&quot; gives
	another color, on others you just get color 3.

	For an xterm this depends on your resources, and is a bit
	unpredictable.	See your xterm documentation for the defaults.	The
	colors for a <A HREF="#color-xterm">color-xterm</A> can be changed from the <A HREF="gui_x11.html#.Xdefaults">.Xdefaults</A> file.
	Unfortunately this means that it's not possible to get the same colors
	for each user.	See |<A HREF="#xterm-color">xterm-color</A>| for info about color xterms.

	The <A HREF="os_msdos.html#MSDOS">MSDOS</A> standard colors are fixed (in a console window), so these
	have been used for the names.  But the meaning of color names in <A HREF="options.html#X11">X11</A>
	are fixed, so these color settings have been used, to make the
	highlighting settings portable (complicated, isn't it?).  The
	following names are recognized, with the color number used:


							*<A NAME="cterm-colors"></A><B>cterm-colors</B>*
<B><FONT COLOR="PURPLE">	    NR-16   NR-8    COLOR NAME </FONT></B>
	    0	    0	    Black
	    1	    4	    DarkBlue
	    2	    2	    DarkGreen
	    3	    6	    DarkCyan
	    4	    1	    DarkRed
	    5	    5	    DarkMagenta
	    6	    3	    Brown, DarkYellow
	    7	    7	    LightGray, LightGrey, Gray, Grey
	    8	    0*	    DarkGray, DarkGrey
	    9	    4*	    Blue, LightBlue
	    10	    2*	    Green, LightGreen
	    11	    6*	    Cyan, LightCyan
	    12	    1*	    Red, LightRed
	    13	    5*	    Magenta, LightMagenta
	    14	    3*	    Yellow, LightYellow
	    15	    7*	    White

	The number under &quot;NR-16&quot; is used for 16-color terminals ('t_Co'
	greater than or equal to 16).  The number under &quot;NR-8&quot; is used for
	8-color terminals ('t_Co' <A HREF="various.html#less">less</A> than 16).  The '*' indicates that the
	<A HREF="#bold">bold</A> attribute is set for ctermfg.  In many 8-color terminals (e.g.,
	&quot;linux&quot;), this causes the bright colors to appear.  This doesn't work
	for background colors!	Without the '*' the <A HREF="#bold">bold</A> attribute is removed.
	If you want to set the <A HREF="#bold">bold</A> attribute in a different way, put a
	&quot;cterm=&quot; argument AFTER the &quot;ctermfg=&quot; or &quot;ctermbg=&quot; argument.	Or use
	a number instead of a color name.

	The <A HREF="change.html#case">case</A> of the color names is ignored.
	Note that for 16 color ansi style terminals (including xterms), the
	numbers in the NR-8 column is used.  Here '*' means 'add 8' so that Blue
	is 12, DarkGray is 8 etc.

	Note that for some color terminals these names may result in the wrong
	colors!


							*<A NAME=":hi-normal-cterm"></A><B>:hi-normal-cterm</B>*
	When setting the &quot;ctermfg&quot; or &quot;ctermbg&quot; colors for the <A HREF="intro.html#Normal">Normal</A> group,
	these will become the colors used for the non-highlighted text.
	Example:
<B>		:highlight Normal ctermfg=grey ctermbg=darkblue</B>
 	When setting the &quot;ctermbg&quot; color for the <A HREF="intro.html#Normal">Normal</A> group, the
	<A HREF="options.html#'background'">'background'</A> option will be adjusted automatically.  This causes the
	highlight groups that depend on <A HREF="options.html#'background'">'background'</A> to change!  This means
	you should set the colors for <A HREF="intro.html#Normal">Normal</A> first, before setting other
	colors.
	When a colorscheme is being used, <A HREF="change.html#changing">changing</A> <A HREF="options.html#'background'">'background'</A> causes <A HREF="motion.html#it">it</A> to
	be reloaded, which may reset all colors (including <A HREF="intro.html#Normal">Normal</A>).  First
	delete the &quot;<A HREF="options.html#g:colors_name">g:colors_name</A>&quot; variable when you don't want this.

	When you have set &quot;ctermfg&quot; or &quot;ctermbg&quot; for the <A HREF="intro.html#Normal">Normal</A> group, Vim
	needs to reset the color when exiting.	This is done with the &quot;op&quot;
	<A HREF="term.html#termcap">termcap</A> entry |<A HREF="term.html#t_op">t_op</A>|.  If this doesn't work correctly, try setting the
	<A HREF="term.html#'t_op'">'t_op'</A> option in your <A HREF="starting.html#.vimrc">.vimrc</A>.

							*<A NAME="E419"></A><B>E419</B>* *<A NAME="E420"></A><B>E420</B>*
	When Vim knows the normal foreground and background colors, &quot;fg&quot; and
	&quot;bg&quot; can be used <A HREF="motion.html#as">as</A> color names.  This only works after setting the
	colors for the <A HREF="intro.html#Normal">Normal</A> group and for the <A HREF="os_msdos.html#MS-DOS">MS-DOS</A> console.  Example, for
	reverse video:
<B>	    :highlight Visual ctermfg=bg ctermbg=fg</B>
 	Note that the colors are used that are valid at the moment this
	command are given.  If the <A HREF="intro.html#Normal">Normal</A> group colors are changed later, the
	&quot;fg&quot; and &quot;bg&quot; colors will not be adjusted.


3. highlight arguments for the <A HREF="gui.html#GUI">GUI</A>


gui={attr-list}						*<A NAME="highlight-gui"></A><B>highlight-gui</B>*
	These give the attributes to use in the <A HREF="gui.html#GUI">GUI</A> mode.
	See |<A HREF="#attr-list">attr-list</A>| for a description.
	Note that &quot;<A HREF="#bold">bold</A>&quot; can be used here and by using a <A HREF="#bold">bold</A> font.  They
	have the same effect.
	Note that the attributes are ignored for the &quot;<A HREF="intro.html#Normal">Normal</A>&quot; group.


font={font-name}					*<A NAME="highlight-font"></A><B>highlight-font</B>*
	font-name is the name of a font, <A HREF="motion.html#as">as</A> <A HREF="motion.html#it">it</A> is used on the system Vim
	runs on.  For <A HREF="options.html#X11">X11</A> this is a complicated name, for example:
<B>   font=-misc-fixed-bold-r-normal--14-130-75-75-c-70-iso8859-1</B>
 
	The font-name &quot;NONE&quot; can be used to revert to the default font.
	When setting the font for the &quot;<A HREF="intro.html#Normal">Normal</A>&quot; group, this becomes the default
	font (until the <A HREF="options.html#'guifont'">'guifont'</A> option is changed; the last one set is
	used).
	The following only works with <A HREF="gui_x11.html#Motif">Motif</A> and <A HREF="gui_x11.html#Athena">Athena</A>, not with other GUIs:
	When setting the font for the &quot;Menu&quot; group, the <A HREF="gui.html#menus">menus</A> will be changed.
	When setting the font for the &quot;Tooltip&quot; group, the tooltips will be
	changed.
	All fonts used, except for Menu and Tooltip, should be of the same
	character size <A HREF="motion.html#as">as</A> the default font!  Otherwise redrawing problems will
	occur.


guifg={color-name}					*<A NAME="highlight-guifg"></A><B>highlight-guifg</B>*

guibg={color-name}					*<A NAME="highlight-guibg"></A><B>highlight-guibg</B>*

guisp={color-name}					*<A NAME="highlight-guisp"></A><B>highlight-guisp</B>*
	These give the foreground (guifg), background (guibg) and special
	(guisp) color to use in the <A HREF="gui.html#GUI">GUI</A>.  &quot;guisp&quot; is used for <A HREF="#undercurl">undercurl</A>.
	There are a few special names:
		NONE		no color (transparent)
		bg		use normal background color
		background	use normal background color
		fg		use normal foreground color
		foreground	use normal foreground color
	To use a color name with an embedded space or other special character,
	put <A HREF="motion.html#it">it</A> in single <A HREF="quotes.html#quotes">quotes</A>.  The single <A HREF="change.html#quote">quote</A> cannot be used then.
	Example:
<B>	    :hi comment guifg='salmon pink'</B>
 

							*<A NAME="gui-colors"></A><B>gui-colors</B>*
	Suggested color names (these are available on most systems):
	    Red		LightRed	DarkRed
	    Green	LightGreen	DarkGreen	SeaGreen
	    Blue	LightBlue	DarkBlue	SlateBlue
	    Cyan	LightCyan	DarkCyan
	    Magenta	LightMagenta	DarkMagenta
	    Yellow	LightYellow	Brown		DarkYellow
	    Gray	LightGray	DarkGray
	    Black	White
	    Orange	Purple		Violet

	In the <A HREF="os_win32.html#Win32">Win32</A> <A HREF="gui.html#GUI">GUI</A> version, additional system colors are available.  See
	|<A HREF="gui_w32.html#win32-colors">win32-colors</A>|.

	You can also specify a color by its Red, Green and Blue values.
	The format is &quot;#rrggbb&quot;, where
		&quot;rr&quot;	is the Red value
		&quot;<A HREF="motion.html#gg">gg</A>&quot;	is the Green value
		&quot;bb&quot;	is the Blue value
	All values are hexadecimal, range from &quot;00&quot; to &quot;ff&quot;.  Examples:
<B>  :highlight Comment guifg=#11f0c3 guibg=#ff00ff</B>
 

					*<A NAME="highlight-groups"></A><B>highlight-groups</B>* *<A NAME="highlight-default"></A><B>highlight-default</B>*
These are the default highlighting groups.  These groups are used by the
<A HREF="options.html#'highlight'">'highlight'</A> option default.  Note that the highlighting depends on the value
of <A HREF="options.html#'background'">'background'</A>.  You can see the current settings with the &quot;<A HREF="#:highlight">:highlight</A>&quot;
command.

							*<A NAME="hl-ColorColumn"></A><B>hl-ColorColumn</B>*
ColorColumn	used for the columns set with <A HREF="options.html#'colorcolumn'">'colorcolumn'</A>

							*<A NAME="hl-Conceal"></A><B>hl-Conceal</B>*
Conceal		placeholder characters substituted for concealed
		text (see <A HREF="options.html#'conceallevel'">'conceallevel'</A>)

							*<A NAME="hl-Cursor"></A><B>hl-Cursor</B>*
Cursor		the character under the cursor

							*<A NAME="hl-CursorIM"></A><B>hl-CursorIM</B>*
CursorIM	like Cursor, but used when in <A HREF="mbyte.html#IME">IME</A> mode |<A HREF="mbyte.html#CursorIM">CursorIM</A>|

							*<A NAME="hl-CursorColumn"></A><B>hl-CursorColumn</B>*
CursorColumn	the screen column that the cursor is in when <A HREF="options.html#'cursorcolumn'">'cursorcolumn'</A> is
		set

							*<A NAME="hl-CursorLine"></A><B>hl-CursorLine</B>*
CursorLine	the screen line that the cursor is in when <A HREF="options.html#'cursorline'">'cursorline'</A> is
		set

							*<A NAME="hl-Directory"></A><B>hl-Directory</B>*
Directory	directory names (and other special names in listings)

							*<A NAME="hl-DiffAdd"></A><B>hl-DiffAdd</B>*
DiffAdd		diff mode: Added line |<A HREF="diff.html">diff.txt</A>|

							*<A NAME="hl-DiffChange"></A><B>hl-DiffChange</B>*
DiffChange	diff mode: Changed line |<A HREF="diff.html">diff.txt</A>|

							*<A NAME="hl-DiffDelete"></A><B>hl-DiffDelete</B>*
DiffDelete	diff mode: Deleted line |<A HREF="diff.html">diff.txt</A>|

							*<A NAME="hl-DiffText"></A><B>hl-DiffText</B>*
DiffText	diff mode: Changed text within a changed line |<A HREF="diff.html">diff.txt</A>|

							*<A NAME="hl-ErrorMsg"></A><B>hl-ErrorMsg</B>*
ErrorMsg	error <A HREF="message.html#messages">messages</A> on the command line

							*<A NAME="hl-VertSplit"></A><B>hl-VertSplit</B>*
VertSplit	the column separating vertically split <A HREF="windows.html#windows">windows</A>

							*<A NAME="hl-Folded"></A><B>hl-Folded</B>*
Folded		line used for closed <A HREF="fold.html#folds">folds</A>

							*<A NAME="hl-FoldColumn"></A><B>hl-FoldColumn</B>*
FoldColumn	<A HREF="options.html#'foldcolumn'">'foldcolumn'</A>

							*<A NAME="hl-SignColumn"></A><B>hl-SignColumn</B>*
SignColumn	column where |<A HREF="sign.html#signs">signs</A>| are displayed

							*<A NAME="hl-IncSearch"></A><B>hl-IncSearch</B>*
IncSearch	<A HREF="options.html#'incsearch'">'incsearch'</A> highlighting; also used for the text replaced with
		&quot;:s///c&quot;

							*<A NAME="hl-LineNr"></A><B>hl-LineNr</B>*
LineNr		Line number for &quot;<A HREF="various.html#:number">:number</A>&quot; and &quot;<A HREF="various.html#:#">:#</A>&quot; commands, and when <A HREF="options.html#'number'">'number'</A>
		or <A HREF="options.html#'relativenumber'">'relativenumber'</A> option is set.

							*<A NAME="hl-CursorLineNr"></A><B>hl-CursorLineNr</B>*
CursorLineNr	Like LineNr when <A HREF="options.html#'cursorline'">'cursorline'</A> or <A HREF="options.html#'relativenumber'">'relativenumber'</A> is set for
		the cursor line.

							*<A NAME="hl-MatchParen"></A><B>hl-MatchParen</B>*
MatchParen	The character under the cursor or just before <A HREF="motion.html#it">it</A>, if <A HREF="motion.html#it">it</A>
		is a paired bracket, and its match. |<A HREF="pi_paren.html">pi_paren.txt</A>|


							*<A NAME="hl-ModeMsg"></A><B>hl-ModeMsg</B>*
ModeMsg		<A HREF="options.html#'showmode'">'showmode'</A> message (e.g., &quot;<A HREF="starting.html#--">--</A> INSERT --&quot;)

							*<A NAME="hl-MoreMsg"></A><B>hl-MoreMsg</B>*
MoreMsg		|<A HREF="message.html#more-prompt">more-prompt</A>|

							*<A NAME="hl-NonText"></A><B>hl-NonText</B>*
NonText		'<A HREF="change.html#~">~</A>' and '<A HREF="repeat.html#@">@</A>' at the end of the <A HREF="windows.html#window">window</A>, characters from
		<A HREF="options.html#'showbreak'">'showbreak'</A> and other characters that <A HREF="diff.html#do">do</A> not really exist in
		the text (e.g., &quot;<A HREF="change.html#&gt;">&gt;</A>&quot; displayed when a double-wide character
		doesn't fit at the end of the line).

							*<A NAME="hl-Normal"></A><B>hl-Normal</B>*
<A HREF="intro.html#Normal">Normal</A>		normal text

							*<A NAME="hl-Pmenu"></A><B>hl-Pmenu</B>*
Pmenu		Popup menu: normal item.

							*<A NAME="hl-PmenuSel"></A><B>hl-PmenuSel</B>*
PmenuSel	Popup menu: selected item.

							*<A NAME="hl-PmenuSbar"></A><B>hl-PmenuSbar</B>*
PmenuSbar	Popup menu: scrollbar.

							*<A NAME="hl-PmenuThumb"></A><B>hl-PmenuThumb</B>*
PmenuThumb	Popup menu: Thumb of the scrollbar.

							*<A NAME="hl-Question"></A><B>hl-Question</B>*
Question	|<A HREF="message.html#hit-enter">hit-enter</A>| prompt and yes/no questions

							*<A NAME="hl-Search"></A><B>hl-Search</B>*
Search		Last search <A HREF="pattern.html#pattern">pattern</A> highlighting (see <A HREF="options.html#'hlsearch'">'hlsearch'</A>).
		Also used for highlighting the current line in the <A HREF="quickfix.html#quickfix">quickfix</A>
		<A HREF="windows.html#window">window</A> and similar items that need to stand out.

							*<A NAME="hl-SpecialKey"></A><B>hl-SpecialKey</B>*
SpecialKey	Meta and special keys listed with &quot;<A HREF="map.html#:map">:map</A>&quot;, also for text used
		to show unprintable characters in the text, <A HREF="options.html#'listchars'">'listchars'</A>.
		Generally: text that is displayed differently from what <A HREF="motion.html#it">it</A>
		really is.

							*<A NAME="hl-SpellBad"></A><B>hl-SpellBad</B>*
SpellBad	Word that is not recognized by the spellchecker. |<A HREF="spell.html#spell">spell</A>|
		This will be combined with the highlighting used otherwise.

							*<A NAME="hl-SpellCap"></A><B>hl-SpellCap</B>*
SpellCap	Word that should start with a capital. |<A HREF="spell.html#spell">spell</A>|
		This will be combined with the highlighting used otherwise.

							*<A NAME="hl-SpellLocal"></A><B>hl-SpellLocal</B>*
SpellLocal	Word that is recognized by the spellchecker <A HREF="motion.html#as">as</A> one that is
		used in another region. |<A HREF="spell.html#spell">spell</A>|
		This will be combined with the highlighting used otherwise.

							*<A NAME="hl-SpellRare"></A><B>hl-SpellRare</B>*
SpellRare	Word that is recognized by the spellchecker <A HREF="motion.html#as">as</A> one that is
		hardly ever used. |<A HREF="spell.html#spell">spell</A>|
		This will be combined with the highlighting used otherwise.

							*<A NAME="hl-StatusLine"></A><B>hl-StatusLine</B>*
StatusLine	status line of current <A HREF="windows.html#window">window</A>

							*<A NAME="hl-StatusLineNC"></A><B>hl-StatusLineNC</B>*
StatusLineNC	status lines of not-current <A HREF="windows.html#windows">windows</A>
		Note: if this is equal to &quot;StatusLine&quot; Vim will use &quot;^^^&quot; in
		the status line of the current <A HREF="windows.html#window">window</A>.

							*<A NAME="hl-TabLine"></A><B>hl-TabLine</B>*
TabLine		<A HREF="intro.html#tab">tab</A> pages line, not active <A HREF="intro.html#tab">tab</A> page label

							*<A NAME="hl-TabLineFill"></A><B>hl-TabLineFill</B>*
TabLineFill	<A HREF="intro.html#tab">tab</A> pages line, where there are no labels

							*<A NAME="hl-TabLineSel"></A><B>hl-TabLineSel</B>*
TabLineSel	<A HREF="intro.html#tab">tab</A> pages line, active <A HREF="intro.html#tab">tab</A> page label

							*<A NAME="hl-Title"></A><B>hl-Title</B>*
Title		titles for output from &quot;<A HREF="options.html#:set">:set</A> all&quot;, &quot;<A HREF="autocmd.html#:autocmd">:autocmd</A>&quot; etc.

							*<A NAME="hl-Visual"></A><B>hl-Visual</B>*
<A HREF="visual.html#Visual">Visual</A>		<A HREF="visual.html#Visual">Visual</A> mode selection

							*<A NAME="hl-VisualNOS"></A><B>hl-VisualNOS</B>*
VisualNOS	<A HREF="visual.html#Visual">Visual</A> mode selection when vim is &quot;Not Owning the Selection&quot;.
		Only <A HREF="options.html#X11">X11</A> Gui's |<A HREF="gui_x11.html#gui-x11">gui-x11</A>| and |<A HREF="term.html#xterm-clipboard">xterm-clipboard</A>| supports this.

							*<A NAME="hl-WarningMsg"></A><B>hl-WarningMsg</B>*
WarningMsg	warning <A HREF="message.html#messages">messages</A>

							*<A NAME="hl-WildMenu"></A><B>hl-WildMenu</B>*
WildMenu	current match in <A HREF="options.html#'wildmenu'">'wildmenu'</A> completion


					*<A NAME="hl-User1"></A><B>hl-User1</B>* *<A NAME="hl-User1..9"></A><B>hl-User1..9</B>* *<A NAME="hl-User9"></A><B>hl-User9</B>*
The <A HREF="options.html#'statusline'">'statusline'</A> <A HREF="#syntax">syntax</A> allows the use of 9 different highlights in the
statusline and ruler (via <A HREF="options.html#'rulerformat'">'rulerformat'</A>).  The names are User1 to User9.

For the <A HREF="gui.html#GUI">GUI</A> you can use the following groups to set the colors for the menu,
scrollbars and tooltips.  They don't have defaults.  This doesn't work for the
<A HREF="os_win32.html#Win32">Win32</A> <A HREF="gui.html#GUI">GUI</A>.  Only three highlight arguments have any effect here: font, guibg,
and guifg.


							*<A NAME="hl-Menu"></A><B>hl-Menu</B>*
Menu		Current font, background and foreground colors of the <A HREF="gui.html#menus">menus</A>.
		Also used for the toolbar.
		Applicable highlight arguments: font, guibg, guifg.

		NOTE: For <A HREF="gui_x11.html#Motif">Motif</A> and <A HREF="gui_x11.html#Athena">Athena</A> the font argument actually
		specifies a <A HREF="mbyte.html#fontset">fontset</A> at all times, no matter if <A HREF="options.html#'guifontset'">'guifontset'</A> is
		empty, and <A HREF="motion.html#as">as</A> such <A HREF="motion.html#it">it</A> is tied to the current |<A HREF="mlang.html#:language">:language</A>| when
		set.


							*<A NAME="hl-Scrollbar"></A><B>hl-Scrollbar</B>*
Scrollbar	Current background and foreground of the main window's
		scrollbars.
		Applicable highlight arguments: guibg, guifg.


							*<A NAME="hl-Tooltip"></A><B>hl-Tooltip</B>*
Tooltip		Current font, background and foreground of the tooltips.
		Applicable highlight arguments: font, guibg, guifg.

		NOTE: For <A HREF="gui_x11.html#Motif">Motif</A> and <A HREF="gui_x11.html#Athena">Athena</A> the font argument actually
		specifies a <A HREF="mbyte.html#fontset">fontset</A> at all times, no matter if <A HREF="options.html#'guifontset'">'guifontset'</A> is
		empty, and <A HREF="motion.html#as">as</A> such <A HREF="motion.html#it">it</A> is tied to the current |<A HREF="mlang.html#:language">:language</A>| when
		set.

==============================================================================

13. Linking groups		*<A NAME=":hi-link"></A><B>:hi-link</B>* *<A NAME=":highlight-link"></A><B>:highlight-link</B>* *<A NAME="E412"></A><B>E412</B>* *<A NAME="E413"></A><B>E413</B>*

When you want to use the same highlighting for several <A HREF="#syntax">syntax</A> groups, you
can <A HREF="diff.html#do">do</A> this more easily by linking the groups into one common highlight
group, and give the color attributes only for that group.

To set a link:

    :hi[ghlight][!] [default] link {from-group} {to-group}

To remove a link:

    :hi[ghlight][!] [default] link {from-group} NONE


Notes:							*<A NAME="E414"></A><B>E414</B>*
- If the {from-group} and/or {to-group} doesn't exist, <A HREF="motion.html#it">it</A> is created.  You
  don't get an error message for a non-existing group.
- As soon <A HREF="motion.html#as">as</A> you use a &quot;<A HREF="#:highlight">:highlight</A>&quot; command for a linked group, the link is
  removed.
- If there are already highlight settings for the {from-group}, the link is
  not made, unless the '<A HREF="change.html#!">!</A>' is given.  For a &quot;<A HREF="#:highlight">:highlight</A> link&quot; command in a
  sourced file, you don't get an error message.  This can be used to skip
  links for groups that already have settings.


					*<A NAME=":hi-default"></A><B>:hi-default</B>* *<A NAME=":highlight-default"></A><B>:highlight-default</B>*
The [default] argument is used for setting the default highlighting for a
group.	If highlighting has already been specified for the group the command
will be ignored.  Also when there is an existing link.

Using [default] is especially useful to overrule the highlighting of a
specific <A HREF="#syntax">syntax</A> file.  For example, the C <A HREF="#syntax">syntax</A> file contains:
<B>	:highlight default link cComment Comment</B>
If you like Question highlighting for C comments, put this in your <A HREF="starting.html#vimrc">vimrc</A> file:
<B>	:highlight link cComment Question</B>
Without the &quot;default&quot; in the C <A HREF="#syntax">syntax</A> file, the highlighting would be
overruled when the <A HREF="#syntax">syntax</A> file is loaded.

==============================================================================

14. Cleaning up						*<A NAME=":syn-clear"></A><B>:syn-clear</B>* *<A NAME="E391"></A><B>E391</B>*

If you want to clear the <A HREF="#syntax">syntax</A> stuff for the current buffer, you can use this
command:
<B>  :syntax clear</B>

This command should be used when you want to switch off <A HREF="#syntax">syntax</A> highlighting,
or when you want to switch to using another <A HREF="#syntax">syntax</A>.  It's normally not needed
in a <A HREF="#syntax">syntax</A> file itself, because <A HREF="#syntax">syntax</A> is cleared by the autocommands that
load the <A HREF="#syntax">syntax</A> file.
The command also deletes the &quot;b:current_syntax&quot; variable, since no <A HREF="#syntax">syntax</A> is
loaded after this command.

If you want to disable <A HREF="#syntax">syntax</A> highlighting for all <A HREF="windows.html#buffers">buffers</A>, you need to remove
the autocommands that load the <A HREF="#syntax">syntax</A> files:
<B>  :syntax off</B>

What this command actually does, is executing the command
<B>  :source $VIMRUNTIME/syntax/nosyntax.vim</B>
See the &quot;nosyntax.vim&quot; file for details.  Note that for this to work
$VIMRUNTIME must be valid.  See |<A HREF="starting.html#$VIMRUNTIME">$VIMRUNTIME</A>|.

To clean up specific <A HREF="#syntax">syntax</A> groups for the current buffer:
<B>  :syntax clear {group-name} ..</B>
This removes all patterns and keywords for <A HREF="#{group-name}">{group-name}</A>.

To clean up specific <A HREF="#syntax">syntax</A> group lists for the current buffer:
<B>  :syntax clear @{grouplist-name} ..</B>
This sets {grouplist-name}'s contents to an empty list.


						*<A NAME=":syntax-reset"></A><B>:syntax-reset</B>* *<A NAME=":syn-reset"></A><B>:syn-reset</B>*
If you have changed the colors and messed them up, use this command to get the
defaults back:

<B>  :syntax reset</B>

This doesn't change the colors for the <A HREF="options.html#'highlight'">'highlight'</A> option.

Note that the <A HREF="#syntax">syntax</A> colors that you set in your <A HREF="starting.html#vimrc">vimrc</A> file will also be reset
back to their Vim default.
Note that if you are using a color scheme, the colors defined by the color
scheme for <A HREF="#syntax">syntax</A> highlighting will be lost.

What this actually does is:

<B>	let g:syntax_cmd = "reset"</B>
<B>	runtime! syntax/syncolor.vim</B>

Note that this uses the <A HREF="options.html#'runtimepath'">'runtimepath'</A> option.


							*<A NAME="syncolor"></A><B>syncolor</B>*
If you want to use different colors for <A HREF="#syntax">syntax</A> highlighting, you can add a Vim
<A HREF="usr_41.html#script">script</A> file to set these colors.  Put this file in a directory in
<A HREF="options.html#'runtimepath'">'runtimepath'</A> which comes after <A HREF="starting.html#$VIMRUNTIME">$VIMRUNTIME</A>, so that your settings overrule
the default colors.  This way these colors will be used after the &quot;<A HREF="#:syntax">:syntax</A>
reset&quot; command.

For <A HREF="os_unix.html#Unix">Unix</A> you can use the file ~/.vim/after/syntax/syncolor.vim.  Example:

<B>	if &amp;background == "light"</B>
<B>	  highlight comment ctermfg=darkgreen guifg=darkgreen</B>
<B>	else</B>
<B>	  highlight comment ctermfg=green guifg=green</B>
<B>	endif</B>

<B>								*E679*</B>
Do make sure this syncolor.vim <A HREF="usr_41.html#script">script</A> does not use a &quot;<A HREF="#syntax">syntax</A> on&quot;, set the
<A HREF="options.html#'background'">'background'</A> option or uses a &quot;colorscheme&quot; command, because <A HREF="motion.html#it">it</A> results in an
endless loop.

Note that when a color scheme is used, there might be some confusion whether
your defined colors are to be used or the colors from the scheme.  This
depends on the color scheme file.  See |<A HREF="#:colorscheme">:colorscheme</A>|.


							*<A NAME="syntax_cmd"></A><B>syntax_cmd</B>*
The &quot;<A HREF="#syntax_cmd">syntax_cmd</A>&quot; variable is set to one of these values when the
syntax/syncolor.vim files are loaded:
   &quot;on&quot;		&quot;<A HREF="#:syntax">:syntax</A> on&quot; command.  Highlight colors are overruled but
		links are kept
   &quot;enable&quot;	&quot;<A HREF="#:syntax">:syntax</A> enable&quot; command.  Only define colors for groups that
		don't have highlighting yet.  Use &quot;<A HREF="#:syntax">:syntax</A> default&quot;.
   &quot;reset&quot;	&quot;<A HREF="#:syntax">:syntax</A> reset&quot; command or loading a color scheme.  Define all
		the colors.
   &quot;skip&quot;	Don't define colors.  Used to skip the default settings when a
		syncolor.vim file earlier in <A HREF="options.html#'runtimepath'">'runtimepath'</A> has already set
		them.

==============================================================================

15. Highlighting <A HREF="tagsrch.html#tags">tags</A>					*<A NAME="tag-highlight"></A><B>tag-highlight</B>*

If you want to highlight all the <A HREF="tagsrch.html#tags">tags</A> in your file, you can use the following
mappings.

	<A HREF="term.html#&lt;F11&gt;">&lt;F11&gt;</A>	<A HREF="starting.html#--">--</A> Generate tags.vim file, and highlight <A HREF="tagsrch.html#tags">tags</A>.
	<A HREF="term.html#&lt;F12&gt;">&lt;F12&gt;</A>	<A HREF="starting.html#--">--</A> Just highlight <A HREF="tagsrch.html#tags">tags</A> based on existing tags.vim file.

<B>  :map &lt;F11&gt;  :sp tags&lt;CR&gt;:%s/^\([^	:]*:\)\=\([^	]*\).*/syntax keyword Tag \2/&lt;CR&gt;:wq! tags.vim&lt;CR&gt;/^&lt;CR&gt;&lt;F12&gt;</B>
<B>  :map &lt;F12&gt;  :so tags.vim&lt;CR&gt;</B>

WARNING: The longer the <A HREF="tagsrch.html#tags">tags</A> file, the slower this will be, and the more
memory Vim will consume.

Only highlighting typedefs, unions and structs can be done too.  For this you
 must use Exuberant ctags found at	<A HREF="http://ctags.sf.net">http://ctags.sf.net</A>.

Put these lines in your Makefile:

# Make a highlight file for types.  Requires Exuberant <A HREF="tagsrch.html#ctags">ctags</A> and awk
types: types.vim
types.vim: *.[ch]
	<A HREF="tagsrch.html#ctags">ctags</A> --c-kinds=gstu -o- *.[ch] YXXY\
		awk 'BEGIN{printf(&quot;syntax keyword Type\t&quot;)}\
			{printf(&quot;&#37;s &quot;<A HREF="motion.html#,">,</A> $$1)}END{print &quot;&quot;}' <A HREF="change.html#&gt;">&gt;</A> $@

And put these lines in your <A HREF="starting.html#.vimrc">.vimrc</A>:

<B>   " load the types.vim highlighting file, if it exists</B>
<B>   autocmd BufRead,BufNewFile *.[ch] let fname = expand('&lt;afile&gt;:p:h') . '/types.vim'</B>
<B>   autocmd BufRead,BufNewFile *.[ch] if filereadable(fname)</B>
<B>   autocmd BufRead,BufNewFile *.[ch]   exe 'so ' . fname</B>
<B>   autocmd BufRead,BufNewFile *.[ch] endif</B>

==============================================================================

16. Window-local <A HREF="#syntax">syntax</A>				*<A NAME=":ownsyntax"></A><B>:ownsyntax</B>*

Normally all <A HREF="windows.html#windows">windows</A> on a buffer share the same <A HREF="#syntax">syntax</A> settings. It is
possible, however, to set a particular <A HREF="windows.html#window">window</A> on a file to have its own
private <A HREF="#syntax">syntax</A> setting. A possible example would be to edit LaTeX source
with conventional highlighting in one <A HREF="windows.html#window">window</A>, while seeing the same source
highlighted differently (so <A HREF="motion.html#as">as</A> to hide <A HREF="intro.html#control">control</A> sequences and indicate <A HREF="#bold">bold</A>,
<A HREF="#italic">italic</A> etc regions) in another. The <A HREF="options.html#'scrollbind'">'scrollbind'</A> option is useful here.

To set the current <A HREF="windows.html#window">window</A> to have the <A HREF="#syntax">syntax</A> &quot;foo&quot;, separately from all other
<A HREF="windows.html#windows">windows</A> on the buffer:
<B>   :ownsyntax foo</B>

 						*<A NAME="w:current_syntax"></A><B>w:current_syntax</B>*
This will set the &quot;<A HREF="#w:current_syntax">w:current_syntax</A>&quot; variable to &quot;foo&quot;.  The value of
&quot;b:current_syntax&quot; does not change.  This is implemented by saving and
restoring &quot;b:current_syntax&quot;, since the <A HREF="#syntax">syntax</A> files <A HREF="diff.html#do">do</A> set
&quot;b:current_syntax&quot;.  The value set by the <A HREF="#syntax">syntax</A> file is assigned to
&quot;<A HREF="#w:current_syntax">w:current_syntax</A>&quot;.

Once a <A HREF="windows.html#window">window</A> has its own <A HREF="#syntax">syntax</A>, <A HREF="#syntax">syntax</A> commands executed from other <A HREF="windows.html#windows">windows</A>
on the same buffer (including <A HREF="#:syntax">:syntax</A> clear) have no effect. Conversely,
<A HREF="#syntax">syntax</A> commands executed from that <A HREF="windows.html#window">window</A> <A HREF="diff.html#do">do</A> not affect other <A HREF="windows.html#windows">windows</A> on the
same buffer.

A <A HREF="windows.html#window">window</A> with its own <A HREF="#syntax">syntax</A> reverts to normal behavior when another buffer
is loaded into that <A HREF="windows.html#window">window</A> or the file is reloaded.
When splitting the <A HREF="windows.html#window">window</A>, the new <A HREF="windows.html#window">window</A> will use the original <A HREF="#syntax">syntax</A>.

==============================================================================

17. Color xterms				*<A NAME="xterm-color"></A><B>xterm-color</B>* *<A NAME="color-xterm"></A><B>color-xterm</B>*

Most color xterms have only eight colors.  If you don't get colors with the
default setup, <A HREF="motion.html#it">it</A> should work with these lines in your <A HREF="starting.html#.vimrc">.vimrc</A>:
<B>   :if &amp;term =~ "xterm"</B>
<B>   :  if has("terminfo")</B>
<B>   :	set t_Co=8</B>
<B>   :	set t_Sf=&lt;Esc&gt;[3%p1%dm</B>
<B>   :	set t_Sb=&lt;Esc&gt;[4%p1%dm</B>
<B>   :  else</B>
<B>   :	set t_Co=8</B>
<B>   :	set t_Sf=&lt;Esc&gt;[3%dm</B>
<B>   :	set t_Sb=&lt;Esc&gt;[4%dm</B>
<B>   :  endif</B>
<B>   :endif</B>
 	[&lt;Esc&gt; is a real <A HREF="intro.html#escape">escape</A>, type <A HREF="visual.html#CTRL-V">CTRL-V</A> &lt;Esc&gt;]

You might want to change the first &quot;if&quot; to match the name of your terminal,
e.g. &quot;dtterm&quot; instead of &quot;xterm&quot;.

Note: Do these settings BEFORE doing &quot;<A HREF="#:syntax">:syntax</A> on&quot;.  Otherwise the colors may
be wrong.

							*<A NAME="xiterm"></A><B>xiterm</B>* *<A NAME="rxvt"></A><B>rxvt</B>*
The above settings have been mentioned to work for <A HREF="#xiterm">xiterm</A> and <A HREF="#rxvt">rxvt</A> too.
But for using 16 colors in an <A HREF="#rxvt">rxvt</A> these should work with <A HREF="term.html#terminfo">terminfo</A>:
<B>	:set t_AB=&lt;Esc&gt;[%?%p1%{8}%&lt;%t25;%p1%{40}%+%e5;%p1%{32}%+%;%dm</B>
<B>	:set t_AF=&lt;Esc&gt;[%?%p1%{8}%&lt;%t22;%p1%{30}%+%e1;%p1%{22}%+%;%dm</B>
 

							*<A NAME="colortest.vim"></A><B>colortest.vim</B>*
To test your color setup, a file has been included in the Vim <A HREF="intro.html#distribution">distribution</A>.
To use <A HREF="motion.html#it">it</A>, execute this command:
<B>   :runtime syntax/colortest.vim</B>

Some versions of xterm (and other terminals, like the Linux console) can
output lighter foreground colors, even though the number of colors is defined
at 8.  Therefore Vim sets the &quot;cterm=bold&quot; attribute for light foreground
colors, when <A HREF="term.html#'t_Co'">'t_Co'</A> is 8.


							*<A NAME="xfree-xterm"></A><B>xfree-xterm</B>*
To get 16 colors or more, get the newest xterm version (which should be
included with XFree86 3.3 and later).  You can also find the latest version
at:
<B>	http://invisible-island.net/xterm/xterm.html</B>
Here is a good way to configure <A HREF="motion.html#it">it</A>.  This uses 88 colors and enables the
termcap-query feature, which allows Vim to ask the xterm how many colors <A HREF="motion.html#it">it</A>
supports.
<B>	./configure --disable-bold-color --enable-88-color --enable-tcap-query</B>
If you only get 8 colors, check the xterm compilation settings.
(Also see |<A HREF="mbyte.html#UTF8-xterm">UTF8-xterm</A>| for using this xterm with <A HREF="mbyte.html#UTF-8">UTF-8</A> character encoding).

This xterm should work with these lines in your <A HREF="starting.html#.vimrc">.vimrc</A> (for 16 colors):
<B>   :if has("terminfo")</B>
<B>   :  set t_Co=16</B>
<B>   :  set t_AB=&lt;Esc&gt;[%?%p1%{8}%&lt;%t%p1%{40}%+%e%p1%{92}%+%;%dm</B>
<B>   :  set t_AF=&lt;Esc&gt;[%?%p1%{8}%&lt;%t%p1%{30}%+%e%p1%{82}%+%;%dm</B>
<B>   :else</B>
<B>   :  set t_Co=16</B>
<B>   :  set t_Sf=&lt;Esc&gt;[3%dm</B>
<B>   :  set t_Sb=&lt;Esc&gt;[4%dm</B>
<B>   :endif</B>
 	[&lt;Esc&gt; is a real <A HREF="intro.html#escape">escape</A>, type <A HREF="visual.html#CTRL-V">CTRL-V</A> &lt;Esc&gt;]

Without |<A HREF="various.html#+terminfo">+terminfo</A>|, Vim will recognize these settings, and automatically
translate cterm colors of 8 and above to &quot;&lt;Esc&gt;[9&#37;dm&quot; and &quot;&lt;Esc&gt;[10&#37;dm&quot;.
Colors above 16 are also translated automatically.

For 256 colors this has been reported to work:

<B>   :set t_AB=&lt;Esc&gt;[48;5;%dm</B>
<B>   :set t_AF=&lt;Esc&gt;[38;5;%dm</B>

Or just set the <A HREF="starting.html#TERM">TERM</A> environment variable to &quot;<A HREF="#xterm-color">xterm-color</A>&quot; or &quot;xterm-16color&quot;
and try if that works.

You probably want to use these X resources (in your ~/.Xdefaults file):
	XTerm*color0:			#000000
	XTerm*color1:			#c00000
	XTerm*color2:			#008000
	XTerm*color3:			#808000
	XTerm*color4:			#0000c0
	XTerm*color5:			#c000c0
	XTerm*color6:			#008080
	XTerm*color7:			#c0c0c0
	XTerm*color8:			#808080
	XTerm*color9:			#ff6060
	XTerm*color10:			#00ff00
	XTerm*color11:			#ffff00
	XTerm*color12:			#8080ff
	XTerm*color13:			#ff40ff
	XTerm*color14:			#00ffff
	XTerm*color15:			#ffffff
	Xterm*cursorColor:		Black

[Note: The cursorColor is required to work around a bug, which changes the
cursor color to the color of the last drawn text.  This has been fixed by a
newer version of xterm, but not everybody is using <A HREF="motion.html#it">it</A> yet.]

To get these right away, <A HREF="editing.html#reload">reload</A> the <A HREF="gui_x11.html#.Xdefaults">.Xdefaults</A> file to the X Option database
Manager (you only need to <A HREF="diff.html#do">do</A> this when you just changed the <A HREF="gui_x11.html#.Xdefaults">.Xdefaults</A> file):
<B>  xrdb -merge ~/.Xdefaults</B>
 

					*<A NAME="xterm-blink"></A><B>xterm-blink</B>* *<A NAME="xterm-blinking-cursor"></A><B>xterm-blinking-cursor</B>*
To make the cursor blink in an xterm, see tools/blink.c.  Or use Thomas
Dickey's xterm above patchlevel 107 (see above for where to get it), with
these resources:
	XTerm*cursorBlink:	on
	XTerm*cursorOnTime:	400
	XTerm*cursorOffTime:	250
	XTerm*cursorColor:	White


							*<A NAME="hpterm-color"></A><B>hpterm-color</B>*
These settings work (more or <A HREF="various.html#less">less</A>) for an <A HREF="term.html#hpterm">hpterm</A>, which only supports 8
foreground colors:
<B>   :if has("terminfo")</B>
<B>   :  set t_Co=8</B>
<B>   :  set t_Sf=&lt;Esc&gt;[&amp;v%p1%dS</B>
<B>   :  set t_Sb=&lt;Esc&gt;[&amp;v7S</B>
<B>   :else</B>
<B>   :  set t_Co=8</B>
<B>   :  set t_Sf=&lt;Esc&gt;[&amp;v%dS</B>
<B>   :  set t_Sb=&lt;Esc&gt;[&amp;v7S</B>
<B>   :endif</B>
 	[&lt;Esc&gt; is a real <A HREF="intro.html#escape">escape</A>, type <A HREF="visual.html#CTRL-V">CTRL-V</A> &lt;Esc&gt;]


						*<A NAME="Eterm"></A><B>Eterm</B>* *<A NAME="enlightened-terminal"></A><B>enlightened-terminal</B>*
These settings have been reported to work for the Enlightened terminal
emulator, or <A HREF="#Eterm">Eterm</A>.  They might work for all xterm-like terminals that use the
<A HREF="#bold">bold</A> attribute to get bright colors.  Add an &quot;<A HREF="eval.html#:if">:if</A>&quot; like above when needed.
<B>       :set t_Co=16</B>
<B>       :set t_AF=^[[%?%p1%{8}%&lt;%t3%p1%d%e%p1%{22}%+%d;1%;m</B>
<B>       :set t_AB=^[[%?%p1%{8}%&lt;%t4%p1%d%e%p1%{32}%+%d;1%;m</B>
 

						*<A NAME="TTpro-telnet"></A><B>TTpro-telnet</B>*
These settings should work for TTpro telnet.  Tera Term Pro is a freeware /
open-source program for <A HREF="os_win32.html#MS-Windows">MS-Windows</A>.
<B>	set t_Co=16</B>
<B>	set t_AB=^[[%?%p1%{8}%&lt;%t%p1%{40}%+%e%p1%{32}%+5;%;%dm</B>
<B>	set t_AF=^[[%?%p1%{8}%&lt;%t%p1%{30}%+%e%p1%{22}%+1;%;%dm</B>
Also make sure TTpro's Setup / Window / Full Color is enabled, and make sure
that Setup / Font / Enable Bold is NOT enabled.
(info provided by John Love-Jensen &lt;eljay@Adobe.COM&gt;)


==============================================================================

18. When <A HREF="#syntax">syntax</A> is slow						*<A NAME=":syntime"></A><B>:syntime</B>*

This is aimed at authors of a <A HREF="#syntax">syntax</A> file.

If your <A HREF="#syntax">syntax</A> causes redrawing to be slow, here are a few hints on making <A HREF="motion.html#it">it</A>
faster.  To see slowness switch on some features that usually interfere, such
<A HREF="motion.html#as">as</A> <A HREF="options.html#'relativenumber'">'relativenumber'</A> and |<A HREF="fold.html#folding">folding</A>|.

Note: this is only available when compiled with the |<A HREF="various.html#+profile">+profile</A>| feature.
You many need to build Vim with &quot;huge&quot; features.

To find out what patterns are consuming most time, get an overview with this
sequence:
<B>	:syntime on</B>
<B>	[ redraw the text at least once with CTRL-L ]</B>
<B>	:syntime report</B>

This will display a list of <A HREF="#syntax">syntax</A> patterns that were used, sorted by the time
<A HREF="motion.html#it">it</A> took to match them against the text.

<A HREF="#:syntime">:syntime</A> on		Start measuring <A HREF="#syntax">syntax</A> times.  This will add some
			overhead to compute the time spent on <A HREF="#syntax">syntax</A> <A HREF="pattern.html#pattern">pattern</A>
			matching.

<A HREF="#:syntime">:syntime</A> off		Stop measuring <A HREF="#syntax">syntax</A> times.

<A HREF="#:syntime">:syntime</A> clear		Set all the counters to zero, restart measuring.

<A HREF="#:syntime">:syntime</A> report		Show the <A HREF="#syntax">syntax</A> items used since &quot;<A HREF="#:syntime">:syntime</A> on&quot; in the
			current <A HREF="windows.html#window">window</A>.  Use a wider display to see more of
			the output.

			The list is sorted by total time. The columns are:
			TOTAL		Total time in seconds spent on
					matching this <A HREF="pattern.html#pattern">pattern</A>.
			COUNT		<A HREF="eval.html#Number">Number</A> of times the <A HREF="pattern.html#pattern">pattern</A> was used.
			MATCH		<A HREF="eval.html#Number">Number</A> of times the <A HREF="pattern.html#pattern">pattern</A> actually
					matched
			SLOWEST		The longest time for one try.
			AVERAGE		The average time for one try.
			NAME		Name of the <A HREF="#syntax">syntax</A> item.  Note that
					this is not unique.
			PATTERN		The <A HREF="pattern.html#pattern">pattern</A> being used.

<A HREF="pattern.html#Pattern">Pattern</A> matching gets slow when <A HREF="motion.html#it">it</A> has to try many alternatives.  Try to
include <A HREF="motion.html#as">as</A> much literal text <A HREF="motion.html#as">as</A> possible to reduce the number of ways a
<A HREF="pattern.html#pattern">pattern</A> does NOT match.

When using the &quot;\@&lt;=&quot; and &quot;\@&lt;!&quot; items, add a maximum size to avoid trying at
all positions in the current and previous line.  For example, if the item is
literal text specify the size of that text (in bytes):

&quot;&lt;\@&lt;=span&quot;	Matches &quot;span&quot; in &quot;&lt;span&quot;.  This tries matching with &quot;<A HREF="change.html#&lt;">&lt;</A>&quot; in
		many places.
&quot;&lt;\@1&lt;=span&quot;	Matches the same, but only tries one byte before &quot;span&quot;.


<A HREF="#top">top</A> - <A HREF="index.html">main help file</A>
</PRE>
</BODY>


</HTML>

<HTML>
<HEAD>
<META HTTP-EQUIV="Content-type" content="text/html; charset=ISO-8859-1">
<TITLE>Vim documentation: usr_40</TITLE>
</HEAD>
<BODY BGCOLOR="#ffffff">
<H1>Vim documentation: usr_40</H1>
<A NAME="top"></A>
<A HREF="index.html">main help file</A>

<HR>
<PRE>

*<A NAME="usr_40.txt"></A><B>usr_40.txt</B>*	For Vim version 7.4.  Last change: 2013 Aug 05

		     VIM USER MANUAL - by <A HREF="intro.html#Bram">Bram</A> <A HREF="intro.html#Moolenaar">Moolenaar</A>

			      Make new commands


Vim is an extensible editor.  You can take a sequence of commands you use
often and turn <A HREF="motion.html#it">it</A> into a new command.  Or redefine an existing command.
Autocommands make <A HREF="motion.html#it">it</A> possible to execute commands automatically.

|<A HREF="#40.1">40.1</A>|	Key <A HREF="map.html#mapping">mapping</A>
|<A HREF="#40.2">40.2</A>|	Defining command-line commands
|<A HREF="#40.3">40.3</A>|	Autocommands

     Next chapter: |<A HREF="usr_41.html">usr_41.txt</A>|  Write a Vim <A HREF="usr_41.html#script">script</A>
 Previous chapter: |<A HREF="usr_32.html">usr_32.txt</A>|  The <A HREF="undo.html#undo">undo</A> tree
Table of contents: |<A HREF="usr_toc.html">usr_toc.txt</A>|

==============================================================================

*<A NAME="40.1"></A><B>40.1</B>*	Key <A HREF="map.html#mapping">mapping</A>

A simple <A HREF="map.html#mapping">mapping</A> was explained in section |<A HREF="usr_05.html#05.3">05.3</A>|.  The principle is that one
sequence of key strokes is translated into another sequence of key strokes.
This is a simple, yet powerful mechanism.
   The simplest form is that one key is mapped to a sequence of keys.  Since
the function keys, except <A HREF="helphelp.html#&lt;F1&gt;">&lt;F1&gt;</A>, have no predefined meaning in Vim, these are
good choices to map.  Example:

<B>	:map &lt;F2&gt; GoDate: &lt;Esc&gt;:read !date&lt;CR&gt;kJ</B>

This shows how three modes are used.  After going to the last line with &quot;<A HREF="motion.html#G">G</A>&quot;,
the &quot;<A HREF="insert.html#o">o</A>&quot; command opens a new line and starts <A HREF="insert.html#Insert">Insert</A> mode.  The text &quot;Date: &quot; is
inserted and <A HREF="intro.html#&lt;Esc&gt;">&lt;Esc&gt;</A> takes you out of insert mode.
   Notice the use of special keys inside <A HREF="intro.html#&lt;&gt;">&lt;&gt;</A>.  This is called angle bracket
<A HREF="intro.html#notation">notation</A>.  You type these <A HREF="motion.html#as">as</A> separate characters, not by pressing the key
itself.  This makes the mappings better readable and you can copy and paste
the text without problems.
   The &quot;<A HREF="cmdline.html#:">:</A>&quot; character takes Vim to the command line.  The &quot;<A HREF="insert.html#:read">:read</A> !date&quot; command
reads the output from the &quot;date&quot; command and appends <A HREF="motion.html#it">it</A> below the current
line.  The <A HREF="motion.html#&lt;CR&gt;">&lt;CR&gt;</A> is required to execute the &quot;<A HREF="insert.html#:read">:read</A>&quot; command.
   At this point of execution the text looks like this:

<B><FONT COLOR="PURPLE">	Date:  </FONT></B>
<B><FONT COLOR="PURPLE">	Fri Jun 15 12:54:34 CEST 2001 </FONT></B>

Now &quot;kJ&quot; moves the cursor up and joins the lines together.
   To decide which key or keys you use for <A HREF="map.html#mapping">mapping</A>, see |<A HREF="map.html#map-which-keys">map-which-keys</A>|.


MAPPING AND MODES

The &quot;<A HREF="map.html#:map">:map</A>&quot; command defines remapping for keys in <A HREF="intro.html#Normal">Normal</A> mode.  You can also
define mappings for other modes.  For example, &quot;<A HREF="map.html#:imap">:imap</A>&quot; applies to <A HREF="insert.html#Insert">Insert</A> mode.
You can use <A HREF="motion.html#it">it</A> to insert a date below the cursor:

<B>	:imap &lt;F2&gt; &lt;CR&gt;Date: &lt;Esc&gt;:read !date&lt;CR&gt;kJ</B>

It looks a lot like the <A HREF="map.html#mapping">mapping</A> for <A HREF="term.html#&lt;F2&gt;">&lt;F2&gt;</A> in <A HREF="intro.html#Normal">Normal</A> mode, only the start is
different.  The <A HREF="term.html#&lt;F2&gt;">&lt;F2&gt;</A> <A HREF="map.html#mapping">mapping</A> for <A HREF="intro.html#Normal">Normal</A> mode is still there.  Thus you can map
the same key differently for each mode.
   Notice that, although this <A HREF="map.html#mapping">mapping</A> starts in <A HREF="insert.html#Insert">Insert</A> mode, <A HREF="motion.html#it">it</A> ends in <A HREF="intro.html#Normal">Normal</A>
mode.  If you want <A HREF="motion.html#it">it</A> to continue in <A HREF="insert.html#Insert">Insert</A> mode, append an &quot;<A HREF="insert.html#a">a</A>&quot; to the
<A HREF="map.html#mapping">mapping</A>.

Here is an overview of map commands and in which mode they work:

	<A HREF="map.html#:map">:map</A>		<A HREF="intro.html#Normal">Normal</A>, <A HREF="visual.html#Visual">Visual</A> and <A HREF="intro.html#Operator-pending">Operator-pending</A>
	<A HREF="map.html#:vmap">:vmap</A>		<A HREF="visual.html#Visual">Visual</A>
	<A HREF="map.html#:nmap">:nmap</A>		<A HREF="intro.html#Normal">Normal</A>
	<A HREF="map.html#:omap">:omap</A>		<A HREF="intro.html#Operator-pending">Operator-pending</A>
	<A HREF="map.html#:map!">:map!</A>		<A HREF="insert.html#Insert">Insert</A> and <A HREF="cmdline.html#Command-line">Command-line</A>
	<A HREF="map.html#:imap">:imap</A>		<A HREF="insert.html#Insert">Insert</A>
	<A HREF="map.html#:cmap">:cmap</A>		<A HREF="cmdline.html#Command-line">Command-line</A>

<A HREF="intro.html#Operator-pending">Operator-pending</A> mode is when you typed an <A HREF="motion.html#operator">operator</A> character, such <A HREF="motion.html#as">as</A> &quot;<A HREF="change.html#d">d</A>&quot; or
&quot;<A HREF="change.html#y">y</A>&quot;, and you are expected to type the motion command or a text object.  Thus
when you type &quot;dw&quot;, the &quot;<A HREF="motion.html#w">w</A>&quot; is entered in operator-pending mode.

Suppose that you want to define <A HREF="term.html#&lt;F7&gt;">&lt;F7&gt;</A> so that the command d&lt;F7&gt; deletes a C
program block (text enclosed in curly braces, <A HREF="intro.html#{}">{}</A>).  Similarly y&lt;F7&gt; would <A HREF="change.html#yank">yank</A>
the program block into the unnamed <A HREF="sponsor.html#register">register</A>.  Therefore, what you need to <A HREF="diff.html#do">do</A>
is to define <A HREF="term.html#&lt;F7&gt;">&lt;F7&gt;</A> to select the current program block.  You can <A HREF="diff.html#do">do</A> this with
the following command:

<B>	:omap &lt;F7&gt; a{</B>

This causes <A HREF="term.html#&lt;F7&gt;">&lt;F7&gt;</A> to perform a select block &quot;<A HREF="motion.html#a{">a{</A>&quot; in operator-pending mode, just
like you typed <A HREF="motion.html#it">it</A>.  This <A HREF="map.html#mapping">mapping</A> is useful if typing a { on your keyboard is a
bit difficult.


LISTING MAPPINGS

To see the currently defined mappings, use &quot;<A HREF="map.html#:map">:map</A>&quot; without arguments.  Or one
of the variants that include the mode in which they work.  The output could
look like this:

<B><FONT COLOR="PURPLE">	   _g		 :call MyGrep(1)&lt;CR&gt; </FONT></B>
<B><FONT COLOR="PURPLE">	v  &lt;F2&gt;		 :s/^/&gt; /&lt;CR&gt;:noh&lt;CR&gt;`` </FONT></B>
<B><FONT COLOR="PURPLE">	n  &lt;F2&gt;		 :.,$s/^/&gt; /&lt;CR&gt;:noh&lt;CR&gt;`` </FONT></B>
	   <A HREF="term.html#&lt;xHome&gt;">&lt;xHome&gt;</A>	 <A HREF="motion.html#&lt;Home&gt;">&lt;Home&gt;</A>
	   <A HREF="term.html#&lt;xEnd&gt;">&lt;xEnd&gt;</A>	 <A HREF="motion.html#&lt;End&gt;">&lt;End&gt;</A>


The first column of the list shows in which mode the <A HREF="map.html#mapping">mapping</A> is effective.
This is &quot;<A HREF="pattern.html#n">n</A>&quot; for <A HREF="intro.html#Normal">Normal</A> mode, &quot;<A HREF="insert.html#i">i</A>&quot; for <A HREF="insert.html#Insert">Insert</A> mode, etc.  A blank is used for a
<A HREF="map.html#mapping">mapping</A> defined with &quot;<A HREF="map.html#:map">:map</A>&quot;, thus effective in both <A HREF="intro.html#Normal">Normal</A> and <A HREF="visual.html#Visual">Visual</A> mode.
   One useful purpose of listing the <A HREF="map.html#mapping">mapping</A> is to check if special keys in <A HREF="intro.html#&lt;&gt;">&lt;&gt;</A>
form have been recognized (this only works when color is supported).  For
example, when <A HREF="intro.html#&lt;Esc&gt;">&lt;Esc&gt;</A> is displayed in color, <A HREF="motion.html#it">it</A> stands for the <A HREF="intro.html#escape">escape</A> character.
When <A HREF="motion.html#it">it</A> has the same color <A HREF="motion.html#as">as</A> the other text, <A HREF="motion.html#it">it</A> is five characters.


REMAPPING

The result of a <A HREF="map.html#mapping">mapping</A> is inspected for other mappings in <A HREF="motion.html#it">it</A>.  For example,
the mappings for <A HREF="term.html#&lt;F2&gt;">&lt;F2&gt;</A> above could be shortened to:

<B>	:map &lt;F2&gt; G&lt;F3&gt;</B>
<B>	:imap &lt;F2&gt; &lt;Esc&gt;&lt;F3&gt;</B>
<B>	:map &lt;F3&gt;  oDate: &lt;Esc&gt;:read !date&lt;CR&gt;kJ</B>

For <A HREF="intro.html#Normal">Normal</A> mode <A HREF="term.html#&lt;F2&gt;">&lt;F2&gt;</A> is mapped to go to the last line, and then behave like
<A HREF="term.html#&lt;F3&gt;">&lt;F3&gt;</A> was pressed.  In <A HREF="insert.html#Insert">Insert</A> mode <A HREF="term.html#&lt;F2&gt;">&lt;F2&gt;</A> stops <A HREF="insert.html#Insert">Insert</A> mode with <A HREF="intro.html#&lt;Esc&gt;">&lt;Esc&gt;</A> and then
also uses <A HREF="term.html#&lt;F3&gt;">&lt;F3&gt;</A>.  Then <A HREF="term.html#&lt;F3&gt;">&lt;F3&gt;</A> is mapped to <A HREF="diff.html#do">do</A> the actual work.

Suppose you hardly ever use <A HREF="intro.html#Ex">Ex</A> mode, and want to use the &quot;<A HREF="intro.html#Q">Q</A>&quot; command to format
text (this was so in old versions of Vim).  This <A HREF="map.html#mapping">mapping</A> will <A HREF="diff.html#do">do</A> <A HREF="motion.html#it">it</A>:

<B>	:map Q gq</B>

But, in rare cases you need to use <A HREF="intro.html#Ex">Ex</A> mode anyway.  Let's map &quot;<A HREF="intro.html#gQ">gQ</A>&quot; to <A HREF="intro.html#Q">Q</A>, so
that you can still go to <A HREF="intro.html#Ex">Ex</A> mode:

<B>	:map gQ Q</B>

What happens now is that when you type &quot;<A HREF="intro.html#gQ">gQ</A>&quot; <A HREF="motion.html#it">it</A> is mapped to &quot;<A HREF="intro.html#Q">Q</A>&quot;.  So far so
good.  But then &quot;<A HREF="intro.html#Q">Q</A>&quot; is mapped to &quot;<A HREF="change.html#gq">gq</A>&quot;, thus typing &quot;<A HREF="intro.html#gQ">gQ</A>&quot; results in &quot;<A HREF="change.html#gq">gq</A>&quot;, and
you don't get to <A HREF="intro.html#Ex">Ex</A> mode at all.
   To avoid keys to be mapped again, use the &quot;<A HREF="map.html#:noremap">:noremap</A>&quot; command:

<B>	:noremap gQ Q</B>

Now Vim knows that the &quot;<A HREF="intro.html#Q">Q</A>&quot; is not to be inspected for mappings that apply to
<A HREF="motion.html#it">it</A>.  There is a similar command for every mode:

	<A HREF="map.html#:noremap">:noremap</A>	<A HREF="intro.html#Normal">Normal</A>, <A HREF="visual.html#Visual">Visual</A> and <A HREF="intro.html#Operator-pending">Operator-pending</A>
	<A HREF="map.html#:vnoremap">:vnoremap</A>	<A HREF="visual.html#Visual">Visual</A>
	<A HREF="map.html#:nnoremap">:nnoremap</A>	<A HREF="intro.html#Normal">Normal</A>
	<A HREF="map.html#:onoremap">:onoremap</A>	<A HREF="intro.html#Operator-pending">Operator-pending</A>
	<A HREF="map.html#:noremap!">:noremap!</A>	<A HREF="insert.html#Insert">Insert</A> and <A HREF="cmdline.html#Command-line">Command-line</A>
	<A HREF="map.html#:inoremap">:inoremap</A>	<A HREF="insert.html#Insert">Insert</A>
	<A HREF="map.html#:cnoremap">:cnoremap</A>	<A HREF="cmdline.html#Command-line">Command-line</A>


RECURSIVE MAPPING

When a <A HREF="map.html#mapping">mapping</A> triggers itself, <A HREF="motion.html#it">it</A> will run forever.  This can be used to
repeat an action an unlimited number of times.
   For example, you have a list of files that contain a version number in the
first line.  You edit these files with &quot;vim *.txt&quot;.  You are now editing the
first file.  Define this <A HREF="map.html#mapping">mapping</A>:

<B>	:map ,, :s/5.1/5.2/&lt;CR&gt;:wnext&lt;CR&gt;,,</B>

Now you type &quot;,,&quot;.  This triggers the <A HREF="map.html#mapping">mapping</A>.  It replaces &quot;5.1&quot; with &quot;5.2&quot;
in the first line.  Then <A HREF="motion.html#it">it</A> does a &quot;<A HREF="editing.html#:wnext">:wnext</A>&quot; to write the file and edit the
next one.  The <A HREF="map.html#mapping">mapping</A> ends in &quot;,,&quot;.  This triggers the same <A HREF="map.html#mapping">mapping</A> again,
thus doing the substitution, etc.
   This continues until there is an error.  In this <A HREF="change.html#case">case</A> <A HREF="motion.html#it">it</A> could be a file
where the substitute command doesn't find a match for &quot;5.1&quot;.  You can then
make a change to insert &quot;5.1&quot; and continue by typing &quot;,,&quot; again.  Or the
&quot;<A HREF="editing.html#:wnext">:wnext</A>&quot; fails, because you are in the last file in the list.
   When a <A HREF="map.html#mapping">mapping</A> runs into an error halfway, the rest of the <A HREF="map.html#mapping">mapping</A> is
discarded.  <A HREF="pattern.html#CTRL-C">CTRL-C</A> interrupts the <A HREF="map.html#mapping">mapping</A> (CTRL-Break on <A HREF="os_win32.html#MS-Windows">MS-Windows</A>).


DELETE A MAPPING

To remove a <A HREF="map.html#mapping">mapping</A> use the &quot;<A HREF="map.html#:unmap">:unmap</A>&quot; command.  Again, the mode the unmapping
applies to depends on the command used:

	<A HREF="map.html#:unmap">:unmap</A>		<A HREF="intro.html#Normal">Normal</A>, <A HREF="visual.html#Visual">Visual</A> and <A HREF="intro.html#Operator-pending">Operator-pending</A>
	<A HREF="map.html#:vunmap">:vunmap</A>		<A HREF="visual.html#Visual">Visual</A>
	<A HREF="map.html#:nunmap">:nunmap</A>		<A HREF="intro.html#Normal">Normal</A>
	<A HREF="map.html#:ounmap">:ounmap</A>		<A HREF="intro.html#Operator-pending">Operator-pending</A>
	<A HREF="map.html#:unmap!">:unmap!</A>		<A HREF="insert.html#Insert">Insert</A> and <A HREF="cmdline.html#Command-line">Command-line</A>
	<A HREF="map.html#:iunmap">:iunmap</A>		<A HREF="insert.html#Insert">Insert</A>
	<A HREF="map.html#:cunmap">:cunmap</A>		<A HREF="cmdline.html#Command-line">Command-line</A>

There is a trick to define a <A HREF="map.html#mapping">mapping</A> that works in <A HREF="intro.html#Normal">Normal</A> and <A HREF="intro.html#Operator-pending">Operator-pending</A>
mode, but not in <A HREF="visual.html#Visual">Visual</A> mode.  First define <A HREF="motion.html#it">it</A> for all three modes, then
delete <A HREF="motion.html#it">it</A> for <A HREF="visual.html#Visual">Visual</A> mode:

<B>	:map &lt;C-A&gt; /---&gt;&lt;CR&gt;</B>
<B>	:vunmap &lt;C-A&gt;</B>

Notice that the five characters &quot;&lt;C-A&gt;&quot; stand for the single key <A HREF="change.html#CTRL-A">CTRL-A</A>.

To remove all mappings use the |<A HREF="map.html#:mapclear">:mapclear</A>| command.  You can guess the
variations for different modes by now.  Be careful with this command, <A HREF="motion.html#it">it</A> can't
be undone.


SPECIAL CHARACTERS

The &quot;<A HREF="map.html#:map">:map</A>&quot; command can be followed by another command.  A &#124; character
separates the two commands.  This also means that a &#124; character can't be used
inside a map command.  To include one, use <A HREF="intro.html#&lt;Bar&gt;">&lt;Bar&gt;</A> (five characters).  Example:

<B>	:map &lt;F8&gt; :write &lt;Bar&gt; !checkin %&lt;CR&gt;</B>

The same problem applies to the &quot;<A HREF="map.html#:unmap">:unmap</A>&quot; command, with the addition that you
have to watch out for trailing white space.  These two commands are different:

<B>	:unmap a | unmap b</B>
<B>	:unmap a| unmap b</B>

The first command tries to unmap &quot;a &quot;<A HREF="motion.html#,">,</A> with a trailing space.

When using a space inside a <A HREF="map.html#mapping">mapping</A>, use <A HREF="motion.html#&lt;Space&gt;">&lt;Space&gt;</A> (seven characters):

<B>	:map &lt;Space&gt; W</B>

This makes the spacebar move a blank-separated <A HREF="motion.html#word">word</A> forward.

It is not possible to put a comment directly after a <A HREF="map.html#mapping">mapping</A>, because the &quot;
character is considered to be part of the <A HREF="map.html#mapping">mapping</A>.  You can use |&quot;, this
starts a new, empty command with a comment.  Example:

<B>	:map &lt;Space&gt; W|     " Use spacebar to move forward a word</B>


MAPPINGS AND ABBREVIATIONS

<A HREF="map.html#Abbreviations">Abbreviations</A> are a lot like <A HREF="insert.html#Insert">Insert</A> mode mappings.  The arguments are handled
in the same way.  The main difference is the way they are triggered.  An
abbreviation is triggered by typing a non-word character after the <A HREF="motion.html#word">word</A>.  A
<A HREF="map.html#mapping">mapping</A> is triggered when typing the last character.
   Another difference is that the characters you type for an abbreviation are
inserted in the text while you type them.  When the abbreviation is triggered
these characters are deleted and replaced by what the abbreviation produces.
When typing the characters for a <A HREF="map.html#mapping">mapping</A>, nothing is inserted until you type
the last character that triggers <A HREF="motion.html#it">it</A>.  If the <A HREF="options.html#'showcmd'">'showcmd'</A> option is set, the
typed characters are displayed in the last line of the Vim <A HREF="windows.html#window">window</A>.
   An exception is when a <A HREF="map.html#mapping">mapping</A> is ambiguous.  Suppose you have done two
mappings:

<B>	:imap aa foo</B>
<B>	:imap aaa bar</B>

Now, when you type &quot;aa&quot;, Vim doesn't know if <A HREF="motion.html#it">it</A> should apply the first or the
second <A HREF="map.html#mapping">mapping</A>.  It waits for another character to be typed.  If <A HREF="motion.html#it">it</A> is an &quot;<A HREF="insert.html#a">a</A>&quot;,
the second <A HREF="map.html#mapping">mapping</A> is applied and results in &quot;<A HREF="motion.html#bar">bar</A>&quot;.  If <A HREF="motion.html#it">it</A> is a space, for
example, the first <A HREF="map.html#mapping">mapping</A> is applied, resulting in &quot;foo&quot;, and then the space
is inserted.


ADDITIONALLY...

The &lt;script&gt; keyword can be used to make a <A HREF="map.html#mapping">mapping</A> local to a <A HREF="usr_41.html#script">script</A>.  See
|<A HREF="map.html#:map-&lt;script&gt;">:map-&lt;script&gt;</A>|.

The &lt;buffer&gt; keyword can be used to make a <A HREF="map.html#mapping">mapping</A> local to a specific buffer.
See |<A HREF="map.html#:map-&lt;buffer&gt;">:map-&lt;buffer&gt;</A>|

The &lt;unique&gt; keyword can be used to make defining a new <A HREF="map.html#mapping">mapping</A> fail when <A HREF="motion.html#it">it</A>
already exists.  Otherwise a new <A HREF="map.html#mapping">mapping</A> simply overwrites the old one.  See
|<A HREF="map.html#:map-&lt;unique&gt;">:map-&lt;unique&gt;</A>|.

To make a key <A HREF="diff.html#do">do</A> nothing, map <A HREF="motion.html#it">it</A> to <A HREF="map.html#&lt;Nop&gt;">&lt;Nop&gt;</A> (five characters).  This will make
the <A HREF="term.html#&lt;F7&gt;">&lt;F7&gt;</A> key <A HREF="diff.html#do">do</A> nothing at all:

<B>	:map &lt;F7&gt; &lt;Nop&gt;| map! &lt;F7&gt; &lt;Nop&gt;</B>

There must be no space after <A HREF="map.html#&lt;Nop&gt;">&lt;Nop&gt;</A>.

==============================================================================

*<A NAME="40.2"></A><B>40.2</B>*	Defining command-line commands

The Vim editor enables you to define your own commands.  You execute these
commands just like any other <A HREF="cmdline.html#Command-line">Command-line</A> mode command.
   To define a command, use the &quot;<A HREF="map.html#:command">:command</A>&quot; command, <A HREF="motion.html#as">as</A> follows:

<B>	:command DeleteFirst 1delete</B>

Now when you execute the command &quot;:DeleteFirst&quot; Vim executes &quot;:1delete&quot;, which
deletes the first line.

	Note:
	User-defined commands must start with a capital <A HREF="print.html#letter">letter</A>.  You cannot
	use &quot;<A HREF="editing.html#:X">:X</A>&quot;, &quot;<A HREF="editing.html#:Next">:Next</A>&quot; and &quot;<A HREF="various.html#:Print">:Print</A>&quot;.  The underscore cannot be used!  You
	can use digits, but this is discouraged.

To list the user-defined commands, execute the following command:

<B>	:command</B>

Just like with the builtin commands, the user defined commands can be
abbreviated.  You need to type just enough to distinguish the command from
another.  Command line completion can be used to get the full name.


NUMBER OF ARGUMENTS

User-defined commands can take a series of arguments.  The number of arguments
must be specified by the -nargs option.  For instance, the example
:DeleteFirst command takes no arguments, so you could have defined <A HREF="motion.html#it">it</A> <A HREF="motion.html#as">as</A>
follows:

<B>	:command -nargs=0 DeleteFirst 1delete</B>

However, because zero arguments is the default, you <A HREF="diff.html#do">do</A> not need to add
&quot;-nargs=0&quot;.  The other values of -nargs are <A HREF="motion.html#as">as</A> follows:

	-nargs=0	No arguments
	-nargs=1	One argument
	-nargs=*	Any number of arguments
	-nargs=?	Zero or one argument
	-nargs=+	One or more arguments


USING THE ARGUMENTS

Inside the command definition, the arguments are represented by the
<A HREF="map.html#&lt;args&gt;">&lt;args&gt;</A> keyword.  For example:

<B>	:command -nargs=+ Say :echo "&lt;args&gt;"</B>

Now when you type

<B>	:Say Hello World</B>

Vim echoes &quot;Hello World&quot;.  However, if you add a double <A HREF="change.html#quote">quote</A>, <A HREF="motion.html#it">it</A> won't work.
For example:

<B>	:Say he said "hello"</B>

To get special characters turned into a string, properly escaped to use <A HREF="motion.html#as">as</A> an
<A HREF="eval.html#expression">expression</A>, use &quot;<A HREF="map.html#&lt;q-args&gt;">&lt;q-args&gt;</A>&quot;:

<B>	:command -nargs=+ Say :echo &lt;q-args&gt;</B>

Now the above &quot;:Say&quot; command will result in this to be executed:

<B>	:echo "he said \"hello\""</B>

The <A HREF="map.html#&lt;f-args&gt;">&lt;f-args&gt;</A> keyword contains the same information <A HREF="motion.html#as">as</A> the <A HREF="map.html#&lt;args&gt;">&lt;args&gt;</A> keyword,
except in a format suitable for use <A HREF="motion.html#as">as</A> function call arguments.  For example:

<B>	:command -nargs=* DoIt :call AFunction(&lt;f-args&gt;)</B>
<B>	:DoIt a b c</B>

Executes the following command:

<B>	:call AFunction("a", "b", "c")</B>


LINE RANGE

Some commands take a range <A HREF="motion.html#as">as</A> their argument.  To tell Vim that you are
defining such a command, you need to specify a -range option.  The values for
this option are <A HREF="motion.html#as">as</A> follows:

	-range		Range is allowed; default is the current line.
	-range=&#37;	Range is allowed; default is the whole file.
	-range={count}	Range is allowed; the last number in <A HREF="motion.html#it">it</A> is used <A HREF="motion.html#as">as</A> a
			single number whose default is {count}.

When a range is specified, the keywords <A HREF="map.html#&lt;line1&gt;">&lt;line1&gt;</A> and <A HREF="map.html#&lt;line2&gt;">&lt;line2&gt;</A> get the values of
the first and last line in the range.  For example, the following command
defines the SaveIt command, which writes out the specified range to the file
&quot;save_file&quot;:

<B>	:command -range=% SaveIt :&lt;line1&gt;,&lt;line2&gt;write! save_file</B>


OTHER OPTIONS

Some of the other <A HREF="options.html#options">options</A> and keywords are <A HREF="motion.html#as">as</A> follows:

	-count={number}		The command can take a <A HREF="intro.html#count">count</A> whose default is
				{number}.  The resulting <A HREF="intro.html#count">count</A> can be used
				through the <A HREF="map.html#&lt;count&gt;">&lt;count&gt;</A> keyword.
	-bang			You can use a !.  If present, using <A HREF="map.html#&lt;bang&gt;">&lt;bang&gt;</A> will
				result in a !.
	<A HREF="if_ole.html#-register">-register</A>		You can specify a <A HREF="sponsor.html#register">register</A>.  (The default is
				the unnamed <A HREF="sponsor.html#register">register</A>.)
				The <A HREF="sponsor.html#register">register</A> specification is available <A HREF="motion.html#as">as</A>
				<A HREF="map.html#&lt;reg&gt;">&lt;reg&gt;</A> (a.k.a. <A HREF="map.html#&lt;register&gt;">&lt;register&gt;</A>).
	-complete={type}	Type of command-line completion used.  See
				|<A HREF="map.html#:command-completion">:command-completion</A>| for the list of possible
				values.
	-bar			The command can be followed by &#124; and another
				command, or &quot; and a comment.
	-buffer			The command is only available for the current
				buffer.

Finally, you have the <A HREF="intro.html#&lt;lt&gt;">&lt;lt&gt;</A> keyword.  It stands for the character <A HREF="change.html#&lt;">&lt;</A>.  Use this
to <A HREF="intro.html#escape">escape</A> the special meaning of the <A HREF="intro.html#&lt;&gt;">&lt;&gt;</A> items mentioned.


REDEFINING AND DELETING

To redefine the same command use the ! argument:

<B>	:command -nargs=+ Say :echo "&lt;args&gt;"</B>
<B>	:command! -nargs=+ Say :echo &lt;q-args&gt;</B>

To delete a user command use &quot;<A HREF="map.html#:delcommand">:delcommand</A>&quot;.  It takes a single argument, which
is the name of the command.  Example:

<B>	:delcommand SaveIt</B>

To delete all the user commands:

<B>	:comclear</B>

Careful, this can't be undone!

More details about all this in the reference manual: |<A HREF="map.html#user-commands">user-commands</A>|.

==============================================================================

*<A NAME="40.3"></A><B>40.3</B>*	Autocommands

An <A HREF="autocmd.html#autocommand">autocommand</A> is a command that is executed automatically in response to some
event, such <A HREF="motion.html#as">as</A> a file being read or written or a buffer change.  Through the
use of autocommands you can train Vim to edit compressed files, for example.
That is used in the |<A HREF="pi_gzip.html#gzip">gzip</A>| <A HREF="usr_05.html#plugin">plugin</A>.
   Autocommands are very powerful.  Use them with care and they will help you
avoid typing many commands.  Use them carelessly and they will cause a lot of
trouble.

Suppose you want to replace a datestamp on the end of a file every time <A HREF="motion.html#it">it</A> is
written.  First you define a function:

<B>	:function DateInsert()</B>
<B>	:  $delete</B>
<B>	:  read !date</B>
<B>	:endfunction</B>

You want this function to be called each time, just before a buffer is written
to a file.  This will make that happen:

<B>	:autocmd BufWritePre *  call DateInsert()</B>

&quot;<A HREF="autocmd.html#BufWritePre">BufWritePre</A>&quot; is the event for which this <A HREF="autocmd.html#autocommand">autocommand</A> is triggered: Just
before (pre) <A HREF="editing.html#writing">writing</A> a buffer to a file.  The &quot;*&quot; is a <A HREF="pattern.html#pattern">pattern</A> to match with
the file name.  In this <A HREF="change.html#case">case</A> <A HREF="motion.html#it">it</A> matches all files.
   With this command enabled, when you <A HREF="diff.html#do">do</A> a &quot;<A HREF="editing.html#:write">:write</A>&quot;, Vim checks for any
matching <A HREF="autocmd.html#BufWritePre">BufWritePre</A> autocommands and executes them, and then <A HREF="motion.html#it">it</A>
performs the &quot;<A HREF="editing.html#:write">:write</A>&quot;.
   The general form of the <A HREF="autocmd.html#:autocmd">:autocmd</A> command is <A HREF="motion.html#as">as</A> follows:

<B>	:autocmd [group] {events} {file_pattern} [nested] {command}</B>

The [group] name is optional.  It is used in managing and calling the commands
(more on this later).  The {events} parameter is a list of events (comma
separated) that trigger the command.
   {file_pattern} is a filename, usually with <A HREF="editing.html#wildcards">wildcards</A>.  For example, using
&quot;*.txt&quot; makes the <A HREF="autocmd.html#autocommand">autocommand</A> be used for all files whose name end in &quot;.txt&quot;.
The optional [nested] flag allows for nesting of autocommands (see below), and
finally, {command} is the command to be executed.


EVENTS

One of the most useful events is <A HREF="autocmd.html#BufReadPost">BufReadPost</A>.  It is triggered after a new
file is being edited.  It is commonly used to set option values.  For example,
you know that &quot;*.gsm&quot; files are GNU assembly language.  To get the <A HREF="syntax.html#syntax">syntax</A> file
right, define this <A HREF="autocmd.html#autocommand">autocommand</A>:

<B>	:autocmd BufReadPost *.gsm  set filetype=asm</B>

If Vim is able to detect the type of file, <A HREF="motion.html#it">it</A> will set the <A HREF="options.html#'filetype'">'filetype'</A> option
for you.  This triggers the Filetype event.  Use this to <A HREF="diff.html#do">do</A> something when a
certain type of file is edited.  For example, to load a list of <A HREF="map.html#abbreviations">abbreviations</A>
for text files:

<B>	:autocmd Filetype text  source ~/.vim/abbrevs.vim</B>

When starting to edit a new file, you could make Vim insert a <A HREF="autocmd.html#skeleton">skeleton</A>:

<B>	:autocmd BufNewFile *.[ch]  0read ~/skeletons/skel.c</B>

See |<A HREF="autocmd.html#autocmd-events">autocmd-events</A>| for a complete list of events.


PATTERNS

The {file_pattern} argument can actually be a comma-separated list of file
patterns.  For example: &quot;*.c,*.h&quot; matches files ending in &quot;.c&quot; and &quot;.h&quot;.
   The usual file <A HREF="editing.html#wildcards">wildcards</A> can be used.  Here is a summary of the most often
used ones:

	&#42;		Match any character any number of times
	?		Match any character once
	[abc]		Match the character a, <A HREF="motion.html#b">b</A> or <A HREF="change.html#c">c</A>
	.		Matches a dot
	a{b,c}		Matches &quot;<A HREF="motion.html#ab">ab</A>&quot; and &quot;ac&quot;

When the <A HREF="pattern.html#pattern">pattern</A> includes a slash (/) Vim will compare directory names.
Without the slash only the last part of a file name is used.  For example,
&quot;*.txt&quot; matches &quot;/home/biep/readme.txt&quot;.  The <A HREF="pattern.html#pattern">pattern</A> &quot;/home/biep/*&quot; would
also match <A HREF="motion.html#it">it</A>.  But &quot;home/foo/*.txt&quot; wouldn't.
   When including a slash, Vim matches the <A HREF="pattern.html#pattern">pattern</A> against both the full path
of the file (&quot;/home/biep/readme.txt&quot;) and the relative path (e.g.,
&quot;biep/readme.txt&quot;).

	Note:
	When working on a system that uses a <A HREF="intro.html#backslash">backslash</A> <A HREF="motion.html#as">as</A> file separator, such
	<A HREF="motion.html#as">as</A> <A HREF="os_win32.html#MS-Windows">MS-Windows</A>, you still use forward slashes in autocommands.  This
	makes <A HREF="motion.html#it">it</A> easier to write the <A HREF="pattern.html#pattern">pattern</A>, since a <A HREF="intro.html#backslash">backslash</A> has a special
	meaning.  It also makes the autocommands portable.


DELETING

To delete an <A HREF="autocmd.html#autocommand">autocommand</A>, use the same command <A HREF="motion.html#as">as</A> what <A HREF="motion.html#it">it</A> was defined with,
but leave out the {command} at the end and use a !.  Example:

<B>	:autocmd! FileWritePre *</B>

This will delete all autocommands for the &quot;<A HREF="autocmd.html#FileWritePre">FileWritePre</A>&quot; event that use the
&quot;*&quot; <A HREF="pattern.html#pattern">pattern</A>.


LISTING

To list all the currently defined autocommands, use this:

<B>	:autocmd</B>

The list can be very long, especially when <A HREF="filetype.html#filetype">filetype</A> detection is used.  To
list only part of the commands, specify the group, event and/or <A HREF="pattern.html#pattern">pattern</A>.  For
example, to list all <A HREF="autocmd.html#BufNewFile">BufNewFile</A> autocommands:

<B>	:autocmd BufNewFile</B>

To list all autocommands for the <A HREF="pattern.html#pattern">pattern</A> &quot;*.c&quot;:

<B>	:autocmd * *.c</B>

Using &quot;*&quot; for the event will list all the events.  To list all autocommands
for the cprograms group:

<B>	:autocmd cprograms</B>


GROUPS

The {group} item, used when defining an <A HREF="autocmd.html#autocommand">autocommand</A>, groups related autocommands
together.  This can be used to delete all the autocommands in a certain group,
for example.
   When defining several autocommands for a certain group, use the &quot;<A HREF="autocmd.html#:augroup">:augroup</A>&quot;
command.  For example, let's define autocommands for C programs:

<B>	:augroup cprograms</B>
<B>	:  autocmd BufReadPost *.c,*.h :set sw=4 sts=4</B>
<B>	:  autocmd BufReadPost *.cpp   :set sw=3 sts=3</B>
<B>	:augroup END</B>

This will <A HREF="diff.html#do">do</A> the same <A HREF="motion.html#as">as</A>:

<B>	:autocmd cprograms BufReadPost *.c,*.h :set sw=4 sts=4</B>
<B>	:autocmd cprograms BufReadPost *.cpp   :set sw=3 sts=3</B>

To delete all autocommands in the &quot;cprograms&quot; group:

<B>	:autocmd! cprograms</B>


NESTING

Generally, commands executed <A HREF="motion.html#as">as</A> the result of an <A HREF="autocmd.html#autocommand">autocommand</A> event will not
trigger any new events.  If you read a file in response to a <A HREF="autocmd.html#FileChangedShell">FileChangedShell</A>
event, <A HREF="motion.html#it">it</A> will not trigger the autocommands that would set the <A HREF="syntax.html#syntax">syntax</A>, for
example.  To make the events triggered, add the &quot;nested&quot; argument:

<B>	:autocmd FileChangedShell * nested  edit</B>


EXECUTING AUTOCOMMANDS

It is possible to trigger an <A HREF="autocmd.html#autocommand">autocommand</A> by pretending an event has occurred.
This is useful to have one <A HREF="autocmd.html#autocommand">autocommand</A> trigger another one.  Example:

<B>	:autocmd BufReadPost *.new  execute "doautocmd BufReadPost " . expand("&lt;afile&gt;:r")</B>

This defines an <A HREF="autocmd.html#autocommand">autocommand</A> that is triggered when a new file has been edited.
The file name must end in &quot;.new&quot;.  The &quot;<A HREF="eval.html#:execute">:execute</A>&quot; command uses <A HREF="eval.html#expression">expression</A>
evaluation to form a new command and execute <A HREF="motion.html#it">it</A>.  When editing the file
&quot;tryout.c.new&quot; the executed command will be:

<B>	:doautocmd BufReadPost tryout.c</B>

The <A HREF="eval.html#expand()">expand()</A> function takes the &quot;<A HREF="cmdline.html#&lt;afile&gt;">&lt;afile&gt;</A>&quot; argument, which stands for the file
name the <A HREF="autocmd.html#autocommand">autocommand</A> was executed for, and takes the root of the file name
with &quot;<A HREF="insert.html#:r">:r</A>&quot;.

&quot;<A HREF="autocmd.html#:doautocmd">:doautocmd</A>&quot; executes on the current buffer.  The &quot;<A HREF="autocmd.html#:doautoall">:doautoall</A>&quot; command works
like &quot;doautocmd&quot; except <A HREF="motion.html#it">it</A> executes on all the <A HREF="windows.html#buffers">buffers</A>.


USING NORMAL MODE COMMANDS

The commands executed by an <A HREF="autocmd.html#autocommand">autocommand</A> are <A HREF="cmdline.html#Command-line">Command-line</A> commands.  If you
want to use a <A HREF="intro.html#Normal">Normal</A> mode command, the &quot;<A HREF="various.html#:normal">:normal</A>&quot; command can be used.
Example:

<B>	:autocmd BufReadPost *.log normal G</B>

This will make the cursor jump to the last line of *.log files when you start
to edit <A HREF="motion.html#it">it</A>.
   Using the &quot;<A HREF="various.html#:normal">:normal</A>&quot; command is a bit tricky.  First of all, make sure its
argument is a complete command, including all the arguments.  When you use &quot;<A HREF="insert.html#i">i</A>&quot;
to go to <A HREF="insert.html#Insert">Insert</A> mode, there must also be a <A HREF="intro.html#&lt;Esc&gt;">&lt;Esc&gt;</A> to leave <A HREF="insert.html#Insert">Insert</A> mode again.
If you use a &quot;<A HREF="pattern.html#/">/</A>&quot; to start a search <A HREF="pattern.html#pattern">pattern</A>, there must be a <A HREF="motion.html#&lt;CR&gt;">&lt;CR&gt;</A> to execute
<A HREF="motion.html#it">it</A>.
   The &quot;<A HREF="various.html#:normal">:normal</A>&quot; command uses all the text after <A HREF="motion.html#it">it</A> <A HREF="motion.html#as">as</A> commands.  Thus there
can be no &#124; and another command following.  To work around this, put the
&quot;<A HREF="various.html#:normal">:normal</A>&quot; command inside an &quot;<A HREF="eval.html#:execute">:execute</A>&quot; command.  This also makes <A HREF="motion.html#it">it</A> possible
to pass unprintable characters in a convenient way.  Example:

<B>	:autocmd BufReadPost *.chg execute "normal ONew entry:\&lt;Esc&gt;" |</B>
<B>		\ 1read !date</B>

This also shows the use of a <A HREF="intro.html#backslash">backslash</A> to break a long command into more
lines.  This can be used in Vim scripts (not at the command line).

When you want the <A HREF="autocmd.html#autocommand">autocommand</A> <A HREF="diff.html#do">do</A> something complicated, which involves jumping
around in the file and then returning to the original position, you may want
to restore the <A HREF="starting.html#view">view</A> on the file.  See |<A HREF="tips.html#restore-position">restore-position</A>| for an example.


IGNORING EVENTS

At times, you will not want to trigger an <A HREF="autocmd.html#autocommand">autocommand</A>.  The <A HREF="options.html#'eventignore'">'eventignore'</A>
option contains a list of events that will be totally ignored.  For example,
the following causes events for entering and leaving a <A HREF="windows.html#window">window</A> to be ignored:

<B>	:set eventignore=WinEnter,WinLeave</B>

To ignore all events, use the following command:

<B>	:set eventignore=all</B>

To set <A HREF="motion.html#it">it</A> back to the normal behavior, make <A HREF="options.html#'eventignore'">'eventignore'</A> empty:

<B>	:set eventignore=</B>

==============================================================================

Next chapter: |<A HREF="usr_41.html">usr_41.txt</A>|  Write a Vim <A HREF="usr_41.html#script">script</A>

Copyright: see |<A HREF="usr_01.html#manual-copyright">manual-copyright</A>|  vim:tw=78:ts=8:ft=help:norl:
<A HREF="#top">top</A> - <A HREF="index.html">main help file</A>
</PRE>
</BODY>


</HTML>
